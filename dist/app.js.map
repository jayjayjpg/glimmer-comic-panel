{"version":3,"file":"app.js","sources":["../../node_modules/@glimmer/di/dist/modules/es2017/src/container.ts","../../node_modules/@glimmer/di/dist/modules/es2017/src/registry.ts","../../node_modules/@glimmer/di/dist/modules/es2017/src/owner.ts","../../node_modules/@glimmer/util/dist/modules/es2017/lib/namespaces.ts","../../node_modules/@glimmer/util/dist/modules/es2017/lib/object-utils.ts","../../node_modules/@glimmer/util/dist/modules/es2017/lib/guid.ts","../../node_modules/@glimmer/util/dist/modules/es2017/lib/collections.ts","../../node_modules/@glimmer/util/dist/modules/es2017/lib/list-utils.ts","../../node_modules/@glimmer/util/dist/modules/es2017/lib/weakmap.ts","../../node_modules/@glimmer/util/dist/modules/es2017/lib/array-utils.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/opcodes.ts","../../node_modules/@glimmer/reference/dist/modules/es2017/lib/validators.ts","../../node_modules/@glimmer/reference/dist/modules/es2017/lib/const.ts","../../node_modules/@glimmer/reference/dist/modules/es2017/lib/iterable.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/expressions/concat.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/references.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/expressions.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/vm.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/vm/arguments.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/dom.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/component.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/bounds.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/upsert.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/builder.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/content.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/debugger.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/partial.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/lists.ts","../../node_modules/@glimmer/wire-format/dist/modules/es2017/lib/opcodes.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiled/opcodes/builder.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compiler.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/scanner.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/syntax/functions.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/environment/constants.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/dom/sanitized-values.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/dom/props.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compat/inner-html-fix.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compat/svg-inner-html-fix.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/compat/text-node-merging-fix.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/dom/helper.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/dom/attribute-managers.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/environment.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/vm/update.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/vm/render-result.ts","../../node_modules/@glimmer/runtime/dist/modules/es2017/lib/vm/append.ts","../../node_modules/@glimmer/object-reference/dist/modules/es2017/lib/references/path.ts","../../node_modules/@glimmer/object-reference/dist/modules/es2017/lib/references/root.ts","../../node_modules/@glimmer/object-reference/dist/modules/es2017/lib/meta.ts","../../node_modules/@glimmer/object-reference/dist/modules/es2017/lib/references/descriptors.ts","../../node_modules/@glimmer/object-reference/dist/modules/es2017/lib/object.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/application-registry.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/dynamic-scope.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/iterable.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/helpers/action.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/helpers/user-helper.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/environment.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/templates/main.ts","../../node_modules/@glimmer/application/dist/modules/es2017/src/application.ts","../../node_modules/@glimmer/resolver/node_modules/@glimmer/di/dist/modules/es2017/src/owner.ts","../../node_modules/@glimmer/resolver/node_modules/@glimmer/di/dist/modules/es2017/src/specifier.ts","../../node_modules/@glimmer/resolver/dist/modules/es2017/src/utils/debug.ts","../../node_modules/@glimmer/resolver/dist/modules/es2017/src/resolver.ts","../../node_modules/@glimmer/component/dist/modules/es2017/src/tracked.ts","../../node_modules/@glimmer/component/dist/modules/es2017/src/component.ts","../../node_modules/@glimmer/component/dist/modules/es2017/src/references.ts","../../node_modules/@glimmer/component/dist/modules/es2017/src/component-manager.ts","src/ui/components/comic-panel/comic-panel-layer/template.ts","src/ui/components/comic-panel/component.ts","src/ui/components/comic-panel/play-button/template.ts","src/ui/components/comic-panel/template.ts","config/module-map.js","config/resolver-configuration.js","src/main.ts","../../node_modules/@glimmer/web-component/dist/modules/es2017/src/initialize-custom-elements.ts","src/index.ts"],"sourcesContent":["import { Factory, FactoryDefinition } from './factory';\nimport { RegistryReader, Injection } from './registry';\nimport { Resolver } from './resolver';\nimport { Dict } from './dict';\n\nexport default class Container {\n  private _registry: RegistryReader;\n  private _resolver: Resolver;\n  private _lookups: Dict<any>;\n  private _factoryDefinitionLookups: Dict<FactoryDefinition<any>>;\n\n  constructor(registry: RegistryReader, resolver: Resolver = null) {\n    this._registry = registry;\n    this._resolver = resolver;\n    this._lookups = {};\n    this._factoryDefinitionLookups = {};\n  }\n\n  factoryFor(specifier: string): Factory<any> {\n    let factoryDefinition: FactoryDefinition<any> = this._factoryDefinitionLookups[specifier];\n\n    if (!factoryDefinition) {\n      if (this._resolver) {\n        factoryDefinition = this._resolver.retrieve(specifier);\n      }\n\n      if (!factoryDefinition) {\n        factoryDefinition = this._registry.registration(specifier);\n      }\n\n      if (factoryDefinition) {\n        this._factoryDefinitionLookups[specifier] = factoryDefinition;\n      }\n    }\n\n    if (!factoryDefinition) {\n      return;\n    }\n\n    return this.buildFactory(specifier, factoryDefinition);\n  }\n\n  lookup(specifier: string): any {\n    let singleton = (this._registry.registeredOption(specifier, 'singleton') !== false);\n\n    if (singleton && this._lookups[specifier]) {\n      return this._lookups[specifier];\n    }\n\n    let factory = this.factoryFor(specifier);\n    if (!factory) { return; }\n\n    if (this._registry.registeredOption(specifier, 'instantiate') === false) {\n      return factory.class;\n    }\n\n    let object = factory.create();\n\n    if (singleton && object) {\n      this._lookups[specifier] = object;\n    }\n\n    return object;\n  }\n\n  defaultInjections(specifier: string): Object {\n    return {};\n  }\n\n  private buildInjections(specifier: string): Object {\n    let hash = this.defaultInjections(specifier);\n    let injections: Injection[] = this._registry.registeredInjections(specifier);\n    let injection: Injection;\n\n    for (let i = 0; i < injections.length; i++) {\n      injection = injections[i];\n      hash[injection.property] = this.lookup(injection.source);\n    }\n\n    return hash;\n  }\n\n  private buildFactory(specifier: string, factoryDefinition: FactoryDefinition<any>): Factory<any> {\n    let injections = this.buildInjections(specifier);\n\n    return {\n      class: factoryDefinition,\n      create(options) {\n        let mergedOptions = Object.assign({}, injections, options);\n\n        return factoryDefinition.create(mergedOptions);\n      }\n    }\n  }\n}\n","import { Dict } from './dict';\nimport { Factory, FactoryDefinition } from './factory';\n\nexport interface RegistrationOptions {\n  singleton?: boolean;\n  instantiate?: boolean;\n}\n\nexport interface Injection {\n  property: string,\n  source: string\n}\n\nexport interface RegistryWriter {\n  register(specifier: string, factory: any, options?: RegistrationOptions): void;\n  unregister(specifier: string): void;\n  registerOption(specifier: string, option: string, value: any): void;\n  unregisterOption(specifier: string, option: string): void;\n  registerInjection(specifier: string, property: string, source: string): void;\n}\n\nexport interface RegistryReader {\n  registration(specifier: string): any;\n  registeredOption(specifier: string, option: string): any;\n  registeredOptions(specifier: string): any;\n  registeredInjections(specifier: string): Injection[];\n}\n\nexport interface RegistryOptions {\n  fallback?: RegistryReader;\n}\n\nexport interface RegistryAccessor extends RegistryReader, RegistryWriter {}\n\nexport default class Registry implements RegistryAccessor {\n  private _registrations: Dict<FactoryDefinition<any>>;\n  private _registeredOptions: Dict<any>;\n  private _registeredInjections: Dict<Injection[]>;\n  private _fallback: RegistryReader;\n\n  constructor(options?: RegistryOptions) {\n    this._registrations = {};\n    this._registeredOptions = {};\n    this._registeredInjections = {};\n    if (options && options.fallback) {\n      this._fallback = options.fallback;\n    }\n  }\n\n  register(specifier: string, factoryDefinition: FactoryDefinition<any>, options?: RegistrationOptions): void {\n    this._registrations[specifier] = factoryDefinition;\n    if (options) {\n      this._registeredOptions[specifier] = options;\n    }\n  }\n\n  registration(specifier: string): FactoryDefinition<any> {\n    let registration = this._registrations[specifier];\n    if (registration === undefined && this._fallback) {\n      registration = this._fallback.registration(specifier);\n    }\n    return registration;\n  }\n\n  unregister(specifier: string): void {\n    delete this._registrations[specifier];\n    delete this._registeredOptions[specifier];\n    delete this._registeredInjections[specifier];\n  }\n\n  registerOption(specifier: string, option: string, value: any): void {\n    let options = this._registeredOptions[specifier];\n\n    if (!options) {\n      options = {};\n      this._registeredOptions[specifier] = options;\n    }\n\n    options[option] = value;\n  }\n\n  registeredOption(specifier: string, option: string): any {\n    let result: Boolean;\n    let options = this.registeredOptions(specifier);\n\n    if (options) {\n      result = options[option];\n    }\n\n    if (result === undefined && this._fallback !== undefined) {\n      result = this._fallback.registeredOption(specifier, option);\n    }\n\n    return result;\n  }\n\n  registeredOptions(specifier: string): any {\n    let options = this._registeredOptions[specifier];\n    if (options === undefined) {\n      let [type] = specifier.split(':');\n      options = this._registeredOptions[type];\n    }\n    return options;\n  }\n\n  unregisterOption(specifier: string, option: string): void {\n    let options = this._registeredOptions[specifier];\n\n    if (options) {\n      delete options[option];\n    }\n  }\n\n  registerInjection(specifier: string, property: string, source: string): void {\n    let injections = this._registeredInjections[specifier];\n    if (injections === undefined) {\n      this._registeredInjections[specifier] = injections = [];\n    }\n    injections.push({\n      property,\n      source\n    });\n  }\n\n  registeredInjections(specifier: string): Injection[] {\n    let [type] = specifier.split(':');\n    let injections: Injection[] = this._fallback ? this._fallback.registeredInjections(specifier) : [];\n    Array.prototype.push.apply(injections, this._registeredInjections[type]);\n    Array.prototype.push.apply(injections, this._registeredInjections[specifier]);\n    return injections;\n  }\n}\n","import { RegistrationOptions } from './registry';\nimport { Factory } from './factory';\n\n// TODO - use symbol\nexport const OWNER = '__owner__';\n\nexport function getOwner(object: Object): Owner {\n  return object[OWNER];\n}\n\nexport function setOwner(object: Object, owner: Owner): void {\n  object[OWNER] = owner;\n}\n\nexport interface Owner {\n  identify(specifier: string, referrer?: string): string;\n\n  factoryFor(specifier: string, referrer?: string): Factory<any>;\n  \n  lookup(specifier: string, referrer?: string): any;\n}\n","// There is a small whitelist of namespaced attributes specially\n// enumerated in\n// https://www.w3.org/TR/html/syntax.html#attributes-0\n//\n// > When a foreign element has one of the namespaced attributes given by\n// > the local name and namespace of the first and second cells of a row\n// > from the following table, it must be written using the name given by\n// > the third cell from the same row.\n//\n// In all other cases, colons are interpreted as a regular character\n// with no special meaning:\n//\n// > No other namespaced attribute can be expressed in the HTML syntax.\n\nconst XLINK = 'http://www.w3.org/1999/xlink';\nconst XML = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\nconst WHITELIST = {\n  'xlink:actuate': XLINK,\n  'xlink:arcrole': XLINK,\n  'xlink:href': XLINK,\n  'xlink:role': XLINK,\n  'xlink:show': XLINK,\n  'xlink:title': XLINK,\n  'xlink:type': XLINK,\n  'xml:base': XML,\n  'xml:lang': XML,\n  'xml:space': XML,\n  'xmlns': XMLNS,\n  'xmlns:xlink': XMLNS\n};\n\nexport function getAttrNamespace(attrName: string) {\n  return WHITELIST[attrName] || null;\n}","const { keys: objKeys } = Object;\n\nexport function assign<T, U>(obj: T, assignments: U): T & U;\nexport function assign<T, U, V>(obj: T, a: U, b: V): T & U & V;\nexport function assign<T, U, V, W>(obj: T, a: U, b: V, c: W): T & U & V & W;\nexport function assign<T, U, V, W, X>(obj: T, a: U, b: V, c: W, d: X): T & U & V & W & X;\nexport function assign<T, U, V, W, X, Y>(obj: T, a: U, b: V, c: W, d: X, e: Y): T & U & V & W & X & Y;\nexport function assign<T, U, V, W, X, Y, Z>(obj: T, a: U, b: V, c: W, d: X, e: Y, f: Z): T & U & V & W & X & Y & Z;\nexport function assign(target: any, ...args: any[]): any;\nexport function assign(obj: any) {\n  for (let i = 1; i < arguments.length; i++) {\n    let assignment = arguments[i];\n    if (assignment === null || typeof assignment !== 'object') continue;\n    let keys = objKeys(assignment);\n    for (let j = 0; j < keys.length; j++) {\n      let key = keys[j];\n      obj[key] = assignment[key];\n    }\n  }\n  return obj;\n}\n\nexport function fillNulls<T>(count: number): T[] {\n  let arr = new Array(count);\n\n  for (let i=0; i<count; i++) {\n    arr[i] = null;\n  }\n\n  return arr;\n}","let GUID = 0;\n\nexport interface HasGuid {\n  _guid: number;\n}\n\nexport function initializeGuid(object: HasGuid): number {\n  return (object._guid = ++GUID);\n}\n\nexport function ensureGuid(object: HasGuid): number {\n  return object._guid || initializeGuid(object);\n}","import { HasGuid, ensureGuid } from './guid';\nimport { Option } from './platform-utils';\n\nexport interface Dict<T> {\n  [index: string]: T;\n}\n\nexport interface Set<T> {\n  add(value: T): Set<T>;\n  delete(value: T): void;\n  forEach(callback: (item: T) => void): void;\n}\n\nlet proto = Object.create(null, {\n  // without this, we will always still end up with (new\n  // EmptyObject()).constructor === Object\n  constructor: {\n    value: undefined,\n    enumerable: false,\n    writable: true\n  }\n});\n\nfunction EmptyObject() {}\nEmptyObject.prototype = proto;\n\nexport function dict<T>(): Dict<T> {\n  // let d = Object.create(null);\n  // d.x = 1;\n  // delete d.x;\n  // return d;\n  return new (EmptyObject as any)();\n}\n\nexport type SetMember = HasGuid | string;\n\nexport class DictSet<T extends SetMember> implements Set<T> {\n  private dict: Dict<T>;\n\n  constructor() {\n    this.dict = dict<T>();\n  }\n\n  add(obj: T): Set<T> {\n    if (typeof obj === 'string') this.dict[<any>obj] = obj;\n    else this.dict[ensureGuid(<any>obj)] = obj;\n    return this;\n  }\n\n  delete(obj: T) {\n    if (typeof obj === 'string') delete this.dict[<any>obj];\n    else if ((obj as any)._guid) delete this.dict[(obj as any)._guid];\n  }\n\n  forEach(callback: (item: T) => void) {\n    let { dict } = this;\n    Object.keys(dict).forEach(key => callback(dict[key]));\n  }\n\n  toArray(): string[] {\n    return Object.keys(this.dict);\n  }\n}\n\nexport class Stack<T> {\n  private stack: T[] = [];\n  public current: Option<T> = null;\n\n  toArray(): T[] {\n    return this.stack;\n  }\n\n  push(item: T) {\n    this.current = item;\n    this.stack.push(item);\n  }\n\n  pop(): Option<T> {\n    let item = this.stack.pop();\n    let len = this.stack.length;\n    this.current = len === 0 ? null : this.stack[len - 1];\n\n    return item === undefined ? null : item;\n  }\n\n  isEmpty(): boolean {\n    return this.stack.length === 0;\n  }\n}\n","import { Option } from './platform-utils';\n\nexport interface Destroyable {\n  destroy(): void;\n}\n\nexport interface LinkedListNode {\n  next: Option<LinkedListNode>;\n  prev: Option<LinkedListNode>;\n}\n\nexport class ListNode<T> implements LinkedListNode {\n  public next: Option<ListNode<T>> = null;\n  public prev: Option<ListNode<T>> = null;\n  public value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n}\n\n// we are unable to express the constraint that T's .prev and .next are\n// themselves T. However, it will always be true, so trust us.\ntype trust = any;\n\nexport class LinkedList<T extends LinkedListNode> implements Slice<T> {\n  static fromSlice<U extends CloneableListNode>(slice: Slice<U>): LinkedList<U> {\n    let list = new LinkedList<U>();\n    slice.forEachNode(n => list.append(n.clone()));\n    return list;\n  }\n\n  private _head: Option<T>;\n  private _tail: Option<T>;\n\n  constructor() {\n    this.clear();\n  }\n\n  head(): Option<T> {\n    return this._head;\n  }\n\n  tail(): Option<T> {\n    return this._tail;\n  }\n\n  clear() {\n    this._head = this._tail = null;\n  }\n\n  isEmpty(): boolean {\n    return this._head === null;\n  }\n\n  toArray(): T[] {\n    let out: T[] = [];\n    this.forEachNode(n => out.push(n));\n    return out;\n  }\n\n  splice(start: T, end: T, reference: T) {\n    let before: Option<T>;\n\n    if (reference === null) {\n      before = this._tail;\n      this._tail = end;\n    } else {\n      before = <T>reference.prev;\n      end.next = reference;\n      reference.prev = end;\n    }\n\n    if (before) {\n      before.next = start;\n      start.prev = before;\n    }\n  }\n\n  nextNode(node: T): T {\n    return <trust>node.next;\n  }\n\n  prevNode(node: T): T {\n    return <trust>node.prev;\n  }\n\n  forEachNode(callback: (node: T) => void) {\n    let node = this._head;\n\n    while (node !== null) {\n      callback(<trust>node);\n      node = <trust>node.next;\n    }\n  }\n\n  contains(needle: T): boolean {\n    let node = this._head;\n\n    while (node !== null) {\n      if (node === needle) return true;\n      node = <trust>node.next;\n    }\n\n    return false;\n  }\n\n  insertBefore(node: T, reference: Option<T> = null): T {\n    if (reference === null) return this.append(node);\n\n    if (reference.prev) reference.prev.next = node;\n    else this._head = node;\n\n    node.prev = reference.prev;\n    node.next = reference;\n    reference.prev = node;\n\n    return node;\n  }\n\n  append(node: T): T {\n    let tail = this._tail;\n\n    if (tail) {\n      tail.next = node;\n      node.prev = tail;\n      node.next = null;\n    } else {\n      this._head = node;\n    }\n\n    return (this._tail = node);\n  }\n\n  pop(): Option<T> {\n    if (this._tail) return this.remove(this._tail);\n    return null;\n  }\n\n  prepend(node: T): T {\n    if (this._head) return this.insertBefore(node, this._head);\n    return (this._head = this._tail = node);\n  }\n\n  remove(node: T): T {\n    if (node.prev) node.prev.next = node.next;\n    else this._head = <trust>node.next;\n\n    if (node.next) node.next.prev = node.prev;\n    else this._tail = <trust>node.prev;\n\n    return node;\n  }\n}\n\nexport interface Slice<T extends LinkedListNode> {\n  head(): Option<T>;\n  tail(): Option<T>;\n  nextNode(node: T): Option<T>;\n  prevNode(node: T): Option<T>;\n  forEachNode(callback: (node: T) => void): void;\n  toArray(): T[];\n  isEmpty(): boolean;\n  contains(needle: T): boolean;\n}\n\nexport interface CloneableListNode extends LinkedListNode {\n  clone(): this;\n}\n\nexport class ListSlice<T extends LinkedListNode> implements Slice<T> {\n  static toList<U extends CloneableListNode>(slice: Slice<U>): LinkedList<U> {\n    let list = new LinkedList<U>();\n    slice.forEachNode(n => list.append(n.clone()));\n    return list;\n  }\n\n  private _head: Option<T>;\n  private _tail: Option<T>;\n\n  constructor(head: Option<T>, tail: Option<T>) {\n    this._head = head;\n    this._tail = tail;\n  }\n\n  forEachNode(callback: (node: T) => void) {\n    let node = this._head;\n\n    while (node !== null) {\n      callback(node);\n      node = this.nextNode(node);\n    }\n  }\n\n  contains(needle: T): boolean {\n    let node = this._head;\n\n    while (node !== null) {\n      if (node === needle) return true;\n      node = <trust>node.next;\n    }\n\n    return false;\n  }\n\n  head(): Option<T> {\n    return this._head;\n  }\n\n  tail(): Option<T> {\n    return this._tail;\n  }\n\n  toArray(): T[] {\n    let out: T[] = [];\n    this.forEachNode(n => out.push(n));\n    return out;\n  }\n\n  nextNode(node: T): Option<T> {\n    if (node === this._tail) return null;\n    return node.next as T;\n  }\n\n  prevNode(node: T): Option<T> {\n    if (node === this._head) return null;\n    return node.prev as T;\n  }\n\n  isEmpty() {\n    return false;\n  }\n}\n\nexport const EMPTY_SLICE = new ListSlice(null, null);\n","export const HAS_NATIVE_WEAKMAP = (function() {\n  // detect if `WeakMap` is even present\n  let hasWeakMap = typeof WeakMap === 'function';\n  if (!hasWeakMap) { return false; }\n\n  let instance = new WeakMap();\n  // use `Object`'s `.toString` directly to prevent us from detecting\n  // polyfills as native weakmaps\n  return Object.prototype.toString.call(instance) === '[object WeakMap]';\n})();\n","import { HAS_NATIVE_WEAKMAP } from './weakmap';\n\nconst HAS_TYPED_ARRAYS = typeof Uint32Array !== 'undefined';\n\nlet A;\n\nif (HAS_TYPED_ARRAYS) {\n  A = Uint32Array;\n} else {\n  A = Array;\n}\n\nexport default A;\n\nexport const EMPTY_ARRAY: any[] = (HAS_NATIVE_WEAKMAP ? Object.freeze([]) : []) as any;","import { Opaque, Option, Dict, Slice as ListSlice, initializeGuid, fillNulls, unreachable } from '@glimmer/util';\nimport { Tag } from '@glimmer/reference';\nimport { VM, UpdatingVM } from './vm';\nimport { Opcode, Environment } from './environment';\nimport { Constants } from './environment/constants';\n\nexport interface OpcodeJSON {\n  type: number | string;\n  guid?: Option<number>;\n  deopted?: boolean;\n  args?: string[];\n  details?: Dict<Option<string>>;\n  children?: OpcodeJSON[];\n}\n\n/**\n * Registers\n *\n * For the most part, these follows MIPS naming conventions, however the\n * register numbers are different.\n */\n\nexport enum Register {\n  // $0 or $pc (program counter): pointer into `program` for the next insturction; -1 means exit\n  'pc',\n\n  // $1 or $ra (return address): pointer into `program` for the return\n  'ra',\n\n  // $2 or $fp (frame pointer): pointer into the `evalStack` for the base of the stack\n  'fp',\n\n  // $3 or $sp (stack pointer): pointer into the `evalStack` for the top of the stack\n  'sp',\n\n  // $4-$5 or $s0-$s1 (saved): callee saved general-purpose registers\n  's0',\n  's1',\n\n  // $6-$7 or $t0-$t1 (temporaries): caller saved general-purpose registers\n  't0',\n  't1'\n}\n\nexport const enum Op {\n  /*\n    Documentation TODO:\n\n    Document the local variable layout in the stack\n    diagram before-and-after.\n\n    Document updating opcodes emitting from unreachable\n    append opcode.\n\n    Document the element stack, block stack and List\n    block stack.\n   */\n\n  /**\n   * This opcode should never be reached.\n   */\n  Bug,\n\n  /// EXPRESSIONS\n\n  /**\n   * Operation: Evaluate a Helper.\n   * Format:\n   *   (Helper helper:#Function)\n   * Operand Stack:\n   *   ..., Arguments →\n   *   ..., VersionedPathReference\n   **/\n  Helper,\n\n  /**\n   * Operation: Push function onto the stack.\n   * Format:\n   *   (Function function:#Function)\n   * Operand Stack:\n   *   ... →\n   *   ..., #Function\n   */\n  Function,\n\n  /**\n   * Operation:\n   *   Bind a variable represented by a symbol from\n   *   a caller supplied argument.\n   * Format:\n   *   (SetVariable symbol:u32 offsetFromBase:u32)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  BindVariable,\n\n  /**\n   * Operation:\n   *   Bind the variable represented by a symbol from\n   *   the value at the top of the stack.\n   * Format:\n   *   (SetVariable symbol:u32)\n   * Operand Stack:\n   *   ..., VersionedPathReference →\n   *   ...\n   */\n  SetVariable,\n\n  /**\n   * Operation:\n   *   Push the contents of the variable represented by\n   *   a symbol (a positional or named argument) onto\n   *   the stack.\n   * Format:\n   *   (PushSymbol symbol:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., VersionedPathReference\n   */\n  GetVariable,\n\n  /**\n   * Operation:\n   *   Pop a VersionedPathReference from the top of the\n   *   stack, and push a VersionedPathReference constructed\n   *   by `.get(property)`.\n   * Format:\n   *   (GetProperty property:#string)\n   * Operand Stack:\n   *   ..., VersionedPathReference →\n   *   ..., VersionedPathReference\n   */\n  GetProperty,\n\n  /**\n   * Operation: Push the specified constant block onto the stack.\n   * Format:\n   *   (PushBlock block:Option<#InlineBlock>)\n   * Operand Stack:\n   *   ... →\n   *   ..., Option<InlineBlock>\n   */\n  PushBlock,\n\n  /**\n   * Operation: Push the specified bound block onto the stack.\n   * Format:\n   *   (GetBlock block:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., InlineBlock\n   */\n  GetBlock,\n\n  /**\n   * Operation:\n   *   Push TRUE onto the stack if the specified block\n   *   is bound and FALSE if it is not.\n   * Format:\n   *   (HasBlock block:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., boolean\n   */\n  HasBlock,\n\n  /**\n   * Operation:\n   *   Push TRUE onto the stack if the specified block\n   *   is bound *and* has at least one specified formal\n   *   parameter, and FALSE otherwise.\n   * Format:\n   *   (HasBlockParams block:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., VersionedPathReference (boolean)\n   */\n  HasBlockParams,\n\n  /**\n   * Operation:\n   *   Pop count `VersionedPathReference`s off the stack and\n   *   construct a new ConcatReference from them (in reverse\n   *   order).\n   * Format:\n   *   (Concat count:u32)\n   * Operand Stack:\n   *   ..., VersionedPathReference, [VersionedPathReference ...] →\n   *   ..., ConcatReference\n   */\n  Concat,\n\n  /**\n   * Operation:\n   *   Push a number onto the stack.\n   * Format:\n   *   (Immediate number:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., number\n   */\n  Immediate,\n\n  /**\n   * Operation:\n   *   Push an Object constant onto the stack that is not\n   *   a JavaScript primitive.\n   * Format:\n   *   (PushConstant constant:#Object)\n   * Operand Stack:\n   *   ... →\n   *   ..., Opaque\n   */\n  Constant,\n\n  /**\n   * Operation:\n   *   Wrap a JavaScript primitive in a reference and push it\n   *   onto the stack.\n   * Format:\n   *   (PushPrimitive constant:#Primitive)\n   * Operand Stack:\n   *   ... →\n   *   ..., Primitive\n   * Description:\n   *   The two high bits of the constant reference describe\n   *   the kind of primitive:\n   *\n   *   00: number\n   *   01: string\n   *   10: true | false | null | undefined\n   */\n  PrimitiveReference,\n\n  /**\n   * Operation: Duplicate and push item from an offset in the stack.\n   * Format:\n   *   (Dup register:u32, offset:u32)\n   * Operand Stack:\n   *   ..., Opaque →\n   *   ..., Opaque, Opaque\n   */\n  Dup,\n\n  /**\n   * Operation: Pop N items off the stack and throw away the value.\n   * Format:\n   *   (Pop)\n   * Operand Stack:\n   *   ..., Opaque, ..., Opaque →\n   *   ...\n   */\n  Pop,\n\n  /**\n   * Operation: Load a value into a register\n   * Format:\n   *   (Load register:u32)\n   * Operand Stack:\n   *   ..., Opaque →\n   *   ...\n   */\n  Load,\n\n  /**\n   * Operation: Fetch a value from a register\n   * Format:\n   *   (Fetch register:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., Opaque\n   */\n  Fetch,\n\n  /// PRELUDE & EXIT\n\n  /**\n   * Operation: Push a new root scope onto the scope stack.\n   *\n   * Format:\n   *   (RootScope symbols:u32 bindCallerScope:bool)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   * Description:\n   *   A root scope has no parent scope, and therefore inherits no lexical\n   *   variables. If `bindCallerScope` is `true`, the current scope remembers\n   *   the caller scope (for yielding blocks).\n   */\n  RootScope,\n\n  /**\n   * Operation: Push a new child scope onto the scope stack.\n   *\n   * Format:\n   *   (ChildScope)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   * Description:\n   *   A child scope inherits from the current parent scope, and therefore\n   *   shares its lexical variables.\n   */\n  ChildScope,\n\n  /**\n   * Operation: Pop the current scope from the scope stack.\n   * Format:\n   *   (PopScope)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  PopScope,\n\n  /**\n   * Operation: Return to the previous frame.\n   * Format:\n   *   (Return)\n   * Operand Stack:\n   *   ..., address:number →\n   *   ...\n   */\n  Return,\n\n  /// HTML\n\n  /**\n   * Operation: Append a Text node with value `contents`\n   * Format:\n   *   (Text contents:#string)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  Text,\n\n  /**\n   * Operation: Append a Comment node with value `contents`\n   * Format:\n   *   (Comment contents:#string)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  Comment,\n\n  /**\n   * Operation: Append a Dynamic node based on .\n   * Format:\n   *   (DynamicContent contents:#DynamicContent)\n   * Operand Stack:\n   *   ..., VersionedPathReference →\n   *   ...\n   * Description:\n   *   Dynamic content can produce any kind of Node or an\n   *   fragment of HTML. If the VersionedPathReference\n   *   changes to a different kind of content, the original\n   *   node(s) are cleared and replaced with the value of\n   *   the new content.\n   *\n   *   The dynamic content can also produce a component\n   *   definition, which requires more fancy footwork.\n   */\n  DynamicContent,\n\n  /**\n   * Operation: Open a new Element named `tag`.\n   * Format:\n   *   (OpenElement tag:#string)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  OpenElement,\n\n  /**\n   * Operation:\n   *   Open a new Element named `tag` with special operations provided\n   *   on the stack.\n   * Format:\n   *   (OpenElementWithOperations tag:#string)\n   * Operand Stack:\n   *   ..., ElementOperations →\n   *   ...\n   */\n  OpenElementWithOperations,\n\n  /**\n   * Operation:\n   *   Open a new Element with a name on the stack and with special\n   *   operations provided on the stack.\n   * Format:\n   *   (OpenDynamicElement)\n   * Operand Stack:\n   *   ..., string, ElementOperations →\n   *   ...\n   */\n  OpenDynamicElement,\n\n  /**\n   * Operation: Add an attribute to the current Element.\n   * Format:\n   *   (StaticAttr name:#string value:#string namespace:Option<#string>)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  StaticAttr,\n\n  /**\n   * Operation:\n   *   Add an attribute to the current element using the value\n   *   at the top of the stack.\n   *\n   * Format:\n   *   (DynamicAttr name:#string trusting:boolean)\n   * Operand Stack:\n   *   ..., VersionedPathReference →\n   *   ...\n   * Description:\n   *   If `trusting` is false, the host may sanitize the attribute\n   *   based upon known risks.\n   */\n  DynamicAttr,\n\n  /**\n   * Operation:\n   *   Add an attribute to the current element using the value\n   *   at the top of the stack.\n   *\n   * Format:\n   *   (DynamicAttrNS name:#string namespace:#string trusting:boolean)\n   * Operand Stack:\n   *   ..., VersionedPathReference →\n   *   ...\n   * Description:\n   *   If `trusting` is false, the host may sanitize the attribute\n   *   based upon known risks.\n   */\n  DynamicAttrNS,\n\n  /**\n   * Operation: Finish setting attributes on the current element.\n   *\n   * Format:\n   *   (FlushElement)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  FlushElement,\n\n  /**\n   * Operation: Close the current element.\n   *\n   * Format:\n   *   (CloseElement)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  CloseElement,\n\n  /// MODIFIER\n  Modifier,                  // (ConstantString, ConstantOther<ModifierManager>, ConstantExpression)\n\n  /// WORMHOLE\n  PushRemoteElement,         // ()\n  PopRemoteElement,          // ()\n\n  /// DYNAMIC SCOPE\n\n  /**\n   * Operation: Bind stack values as dynamic variables.\n   * Format:\n   *   (BindDynamicScope names:#Array<#string>)\n   * Operand Stack:\n   *   ..., VersionedPathReference, [VersionedPathReference ...] →\n   *   ...\n   * Description:\n   *   This is used to expose `-with-dynamic-vars`, and is a\n   *   niche feature.\n   */\n  BindDynamicScope,\n\n  PushDynamicScope,          // ()\n  PopDynamicScope,           // ()\n\n  /// VM\n\n  /**\n   * Operation: Compile the InlineBlock at the top of the stack.\n   * Format:\n   *   (CompileDynamicBlock)\n   * Operand Stack:\n   *   ..., InlineBlock →\n   *   ..., CompiledDynamicBlock\n   */\n  CompileDynamicBlock,\n\n  /**\n   * Operation: Evaluate the specified block.\n   * Format:\n   *   (InvokeStatic block:#InlineBlock)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  InvokeStatic,\n\n  /**\n   * Operation: Evaluate the block at the top of the stack.\n   * Format:\n   *   (InvokeDynamic invoker:#FunctionInvoker)\n   * Operand Stack:\n   *   ..., InlineBlock, [ VersionedPathReference... ], VersionedPathReference →\n   *   ...\n   */\n  InvokeDynamic,\n\n  /**\n   * Operation: Jump to the specified offset.\n   *\n   * Format:\n   *   (Jump to:u32)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  Jump,\n\n  /**\n   * Operation:\n   *   Jump to the specified offset if the value at\n   *   the top of the stack is true.\n   *\n   * Format:\n   *   (JumpIf to:u32)\n   * Operand Stack:\n   *   ..., VersionedPathReference →\n   *   ...\n   */\n  JumpIf,\n\n  /**\n   * Operation:\n   *   Jump to the specified offset if the value at\n   *   the top of the stack is false.\n   *\n   * Format:\n   *   (JumpUnless to:u32)\n   * Operand Stack:\n   *   ..., VersionedPathReference →\n   *   ...\n   */\n  JumpUnless,\n\n  /**\n   * Operation: Push a stack frame\n   *\n   * Format:\n   *   (PushFrame)\n   * Operand Stack:\n   *   ... →\n   *   $ra, $fp\n   */\n  PushFrame,\n\n  /**\n   * Operation: Pop a stack frame\n   *\n   * Format:\n   *   (PushFrame)\n   * Operand Stack:\n   *   $ra, $fp →\n   *   ...\n   */\n  PopFrame,\n\n  /**\n   * Operation:\n   *   Start tracking a new output block that could change\n   *   if one of its inputs changes.\n   *\n   * Format:\n   *   (Enter args:u32)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   * Description:\n   *   Soon after this opcode, one of Jump, JumpIf,\n   *   or JumpUnless will produce an updating assertion.\n   *   If that assertion fails, the appending VM will\n   *   be re-entered, and the instructions from `from`\n   *   to `to` will be executed.\n   *\n   *   TODO: Save and restore.\n   */\n  Enter,\n\n  /**\n   * Operation:\n   *   Finish tracking the current block.\n   *\n   * Format:\n   *   (Exit)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   * Description:\n   *   This finalizes the validators that the updating\n   *   block must check to determine whether it's safe to\n   *   skip running the contents.\n   */\n  Exit,\n\n  /**\n   * Operation: Convert the top of the stack into a boolean reference.\n   *\n   * Format:\n   *   (Test test:#function)\n   * Operand Stack:\n   *   ..., VersionedPathReference<Opaque> →\n   *   ..., VersionedPathReference<bool>\n   * Description:\n   *   TODO: ToBoolean should be global in the env\n   */\n  Test,\n\n  /// LISTS\n\n  /**\n   * Operation: Enter a list.\n   *\n   * Format:\n   *   (EnterList address:u32)\n   * Operand Stack:\n   *   ..., Iterator →\n   *   ...\n   */\n  EnterList,\n\n  /**\n   * Operation: Exit the current list.\n   *\n   * Format:\n   *   (ExitList)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  ExitList,\n\n  /**\n   * Operation:\n   *   Convert an operand and key into an iterator and\n   *   presence reference.\n   *\n   * Format:\n   *   (PutIterator)\n   * Operand Stack:\n   *   ..., key:string, list:VersionedPathReference →\n   *   ..., iterator:ReferenceIterator, present:PresenceReference\n   */\n  PutIterator,\n\n  /**\n   * Operation:\n   *   Set up the stack for iterating for a given key,\n   *   or jump to `end` if there is nothing left to\n   *   iterate.\n   *\n   * Format:\n   *   (Iterate end:u32)\n   * Operand Stack:\n   *   Form 1: (something to iterate)\n   *   ... →\n   *   ..., VersionedPathReference, VersionedPathReference, string\n   *   Form 2: (nothing left to iterate)\n   *   ... →\n   *   ...\n   * Description:\n   *   In Form 1, the stack will have (in reverse order):\n   *\n   *   - the key, as a string\n   *   - the current iterated value\n   *   - the memoized iterated value\n   */\n  Iterate,\n\n  /// COMPONENTS\n\n  /**\n   * Operation: Push an appropriate component manager onto the stack.\n   *\n   * Format:\n   *   (PushComponentManager #ComponentDefinition)\n   * Operand Stack:\n   *   ... →\n   *   ..., ComponentDefinition, ComponentManager\n   */\n  PushComponentManager,\n\n  /**\n   * Operation:\n   *   Push an appropriate component manager onto the stack from\n   *   a runtime-resolved component definition.\n   *\n   * Format:\n   *   (PushDynamicComponentManager)\n   * Operand Stack:\n   *   ... Reference<ComponentDefinition> →\n   *   ..., ComponentDefinition, ComponentManager\n   */\n  PushDynamicComponentManager,\n\n  /**\n   * Operation: push component metadata onto the stack.\n   *\n   * Format:\n   *   (InitializeComponentState)\n   * Operand Stack:\n   *   ..., ComponentDefinition<T>, ComponentManager<T> →\n   *   ..., ComponentState\n   */\n  InitializeComponentState,\n\n  /**\n   * Operation: Push a user representation of args onto the stack.\n   *\n   * Format:\n   *   (PushArgs positional:u32 synthetic:boolean)\n   *\n   * Operand Stack:\n   *   ..., [VersionedPathReference ...], #Array<string> →\n   *   ..., [VersionedPathReference ...], #Array<string>, Arguments\n   *\n   * Description:\n   *   This arguments object is only necessary when calling into\n   *   user-specified hooks. It is meant to be implemented as a\n   *   transient proxy that reads into the stack as needed.\n   *   Holding onto the Arguments after the call has completed is\n   *   illegal.\n   */\n  PushArgs,\n\n  /**\n   * Operation: ...\n   * Format:\n   *   (PrepareArgs state:u32)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  PrepareArgs,\n\n  /**\n   * Operation: Create the component and push it onto the stack.\n   * Format:\n   *   (CreateComponent flags:u32 state:u32)\n   *   ... →\n   *   ...\n   * Description:\n   * Operand Stack:\n   *   Flags:\n   *\n   *   * 0b001: Has a default block\n   *   * 0b010: Has an inverse block\n   */\n  CreateComponent,\n\n  /**\n   * Operation: Register a destructor for the current component\n   *\n   * Format:\n   *   (RegisterComponentDestructor state:u32)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  RegisterComponentDestructor,\n\n  /**\n   * Operation: Push a new ElementOperations for the current component.\n   *\n   * Format:\n   *   (PushComponentOperations)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  PushComponentOperations,\n\n  /**\n   * Operation: Push the component's `self` onto the stack.\n   *\n   * Format:\n   *   (GetComponentSelf state:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., VersionedPathReference\n   */\n  GetComponentSelf,\n\n  /**\n   * Operation: Get a slice of opcodes to invoke.\n   *\n   * Format:\n   *   (GetComponentLayout state:u32)\n   * Operand Stack:\n   *   ... →\n   *   ..., Layout\n   */\n  GetComponentLayout,\n\n  /**\n   * Operation: Begin a new cache group\n   *\n   * Format:\n   *   (BeginComponentTransaction)\n   * Operand Stack:\n   *   ..., ComponentManager<T>, T →\n   *   ..., ComponentManager<T>, T\n   */\n  BeginComponentTransaction,\n\n  /**\n   * Operation: Commit the current cache group\n   *\n   * Format:\n   *   (CommitComponentTransaction)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  CommitComponentTransaction,\n\n  /**\n   * Operation: Invoke didCreateElement on the current component manager\n   *\n   * Format:\n   *   (DidCreateElement state:u32)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  DidCreateElement,\n\n  /**\n   * Operation: Invoke didRenderLayout on the current component manager\n   *\n   * Format:\n   *   (DidRenderLayout state:u32)\n   * Operand Stack:\n   *   ..., →\n   *   ...\n   */\n  DidRenderLayout,\n\n  /// PARTIALS\n\n  /**\n   * Operation: Extract the template from a partial definition\n   *\n   * Format:\n   *   (GetPartialTemplate)\n   * Operand Stack:\n   *   ..., PartialDefinition →\n   *   ..., Program\n   */\n  GetPartialTemplate,\n\n  /**\n   * Operation:\n   *   Resolve {{foo}} inside a partial, which could be either a self-lookup\n   *   or a local variable that is in-scope for the caller.\n   *\n   * Format:\n   *   (ResolveMaybeLocal local:#string)\n   * Operand Stack:\n   *   ... →\n   *   ..., VersionedPathReference\n   */\n  ResolveMaybeLocal,\n\n  /// DEBUGGER\n\n  /**\n   * Operation: Activate the debugger\n   *\n   * Format:\n   *   (Debugger symbols:#Array<string> evalInfo:#Array<number>)\n   * Operand Stack:\n   *   ... →\n   *   ...\n   */\n  Debugger,\n\n  /** The size of the opcode list */\n  Size\n}\n\nexport type Operand1 = number;\nexport type Operand2 = number;\nexport type Operand3 = number;\n\nexport type EvaluateOpcode = (vm: VM, opcode: Opcode) => void;\n\nexport class AppendOpcodes {\n  private evaluateOpcode: EvaluateOpcode[] = fillNulls<EvaluateOpcode>(Op.Size).slice();\n\n  add<Name extends Op>(name: Name, evaluate: EvaluateOpcode): void {\n    this.evaluateOpcode[name as number] = evaluate;\n  }\n\n  evaluate(vm: VM, opcode: Opcode, type: number) {\n    let func = this.evaluateOpcode[type];\n    // console.log(...debug(vm.constants, type, opcode.op1, opcode.op2, opcode.op3));\n    func(vm, opcode);\n  }\n}\n\nexport const APPEND_OPCODES = new AppendOpcodes();\n\nexport abstract class AbstractOpcode {\n  public type: string;\n  public _guid: number;\n\n  constructor() {\n    initializeGuid(this);\n  }\n}\n\nexport abstract class UpdatingOpcode extends AbstractOpcode {\n  public tag: Tag;\n\n  next: Option<UpdatingOpcode> = null;\n  prev: Option<UpdatingOpcode> = null;\n\n  abstract evaluate(vm: UpdatingVM): void;\n}\n\nexport type UpdatingOpSeq = ListSlice<UpdatingOpcode>;\n","import Reference, { PathReference } from './reference';\nimport { Opaque, Option, Slice, LinkedListNode } from '@glimmer/util';\n\n//////////\n\nexport interface EntityTag<T> extends Reference<T> {\n  value(): T;\n  validate(snapshot: T): boolean;\n}\n\nexport interface EntityTagged<T> {\n  tag: EntityTag<T>;\n}\n\nexport interface Tagged {\n  tag: Tag;\n}\n\n//////////\n\nexport type Revision = number;\n\nexport const CONSTANT: Revision = 0;\nexport const INITIAL:  Revision = 1;\nexport const VOLATILE: Revision = NaN;\n\nexport abstract class RevisionTag implements EntityTag<Revision> {\n  static id = 0;\n\n  abstract value(): Revision;\n\n  validate(snapshot: Revision): boolean {\n    return this.value() === snapshot;\n  }\n}\n\nconst VALUE: ((tag: Option<RevisionTag>) => Revision)[] = [];\nconst VALIDATE: ((tag: Option<RevisionTag>, snapshot: Revision) => boolean)[] = [];\n\nexport class TagWrapper<T extends RevisionTag | null> {\n  constructor(private type: number, public inner: T) {}\n\n  value(): Revision {\n    let func = VALUE[this.type];\n    return func(this.inner);\n  }\n\n  validate(snapshot: Revision): boolean {\n    let func = VALIDATE[this.type];\n    return func(this.inner, snapshot);\n  }\n}\n\nexport type Tag = TagWrapper<RevisionTag | null>;\n\nfunction register(Type: { create(...args: any[]): Tag, id: number }) {\n  let type = VALUE.length;\n  VALUE.push((tag: RevisionTag) => tag.value());\n  VALIDATE.push((tag: RevisionTag, snapshot: Revision) => tag.validate(snapshot));\n  Type.id = type;\n}\n\n///\n\n// CONSTANT: 0\nVALUE.push(() => CONSTANT);\nVALIDATE.push((_tag, snapshot) => snapshot === CONSTANT);\nexport const CONSTANT_TAG = new TagWrapper(0, null);\n\n// VOLATILE: 1\nVALUE.push(() => VOLATILE);\nVALIDATE.push((_tag, snapshot) => snapshot === VOLATILE);\nexport const VOLATILE_TAG = new TagWrapper(1, null);\n\n// CURRENT: 2\nVALUE.push(() => $REVISION);\nVALIDATE.push((_tag, snapshot) => snapshot === $REVISION);\nexport const CURRENT_TAG = new TagWrapper(2, null);\n\n///\n\nlet $REVISION = INITIAL;\n\nexport class DirtyableTag extends RevisionTag {\n  static create(revision = $REVISION) {\n    return new TagWrapper(this.id, new DirtyableTag(revision));\n  }\n\n  private revision: Revision;\n\n  constructor(revision = $REVISION) {\n    super();\n    this.revision = revision;\n  }\n\n  value(): Revision {\n    return this.revision;\n  }\n\n  dirty() {\n    this.revision = ++$REVISION;\n  }\n}\n\nregister(DirtyableTag);\n\nexport function combineTagged(tagged: ReadonlyArray<{ tag: Tag }>): Tag {\n  let optimized: Tag[] = [];\n\n  for (let i=0, l=tagged.length; i<l; i++) {\n    let tag = tagged[i].tag;\n    if (tag === VOLATILE_TAG) return VOLATILE_TAG;\n    if (tag === CONSTANT_TAG) continue;\n    optimized.push(tag);\n  }\n\n  return _combine(optimized);\n}\n\nexport function combineSlice(slice: Slice<{ tag: Tag } & LinkedListNode>): Tag {\n  let optimized: Tag[] = [];\n\n  let node = slice.head();\n\n  while(node !== null) {\n    let tag = node.tag;\n\n    if (tag === VOLATILE_TAG) return VOLATILE_TAG;\n    if (tag !== CONSTANT_TAG) optimized.push(tag);\n\n    node = slice.nextNode(node);\n  }\n\n  return _combine(optimized);\n}\n\nexport function combine(tags: Tag[]): Tag {\n  let optimized: Tag[] = [];\n\n  for (let i=0, l=tags.length; i<l; i++) {\n    let tag = tags[i];\n    if (tag === VOLATILE_TAG) return VOLATILE_TAG;\n    if (tag === CONSTANT_TAG) continue;\n    optimized.push(tag);\n  }\n\n  return _combine(optimized);\n}\n\nfunction _combine(tags: Tag[]): Tag {\n  switch (tags.length) {\n    case 0:\n      return CONSTANT_TAG;\n    case 1:\n      return tags[0];\n    case 2:\n      return TagsPair.create(tags[0], tags[1]);\n    default:\n      return TagsCombinator.create(tags);\n  };\n}\n\nexport abstract class CachedTag extends RevisionTag {\n  private lastChecked: Option<Revision> = null;\n  private lastValue: Option<Revision> = null;\n\n  value(): Revision {\n    let { lastChecked, lastValue } = this;\n\n    if (lastChecked !== $REVISION) {\n      this.lastChecked = $REVISION;\n      this.lastValue = lastValue = this.compute();\n    }\n\n    return this.lastValue as Revision;\n  }\n\n  protected invalidate() {\n    this.lastChecked = null;\n  }\n\n  protected abstract compute(): Revision;\n}\n\nclass TagsPair extends CachedTag {\n  static create(first: Tag, second: Tag) {\n    return new TagWrapper(this.id, new TagsPair(first, second));\n  }\n\n  private first: Tag;\n  private second: Tag;\n\n  private constructor(first: Tag, second: Tag) {\n    super();\n    this.first = first;\n    this.second = second;\n  }\n\n  protected compute(): Revision {\n    return Math.max(this.first.value(), this.second.value());\n  }\n}\n\nregister(TagsPair);\n\nclass TagsCombinator extends CachedTag {\n  static create(tags: Tag[]) {\n    return new TagWrapper(this.id, new TagsCombinator(tags));\n  }\n\n  private tags: Tag[];\n\n  private constructor(tags: Tag[]) {\n    super();\n    this.tags = tags;\n  }\n\n  protected compute(): Revision {\n    let { tags } = this;\n\n    let max = -1;\n\n    for (let i=0; i<tags.length; i++) {\n      let value = tags[i].value();\n      max = Math.max(value, max);\n    }\n\n    return max;\n  }\n}\n\nregister(TagsCombinator);\n\nexport class UpdatableTag extends CachedTag {\n  static create(tag: Tag): TagWrapper<UpdatableTag> {\n    return new TagWrapper(this.id, new UpdatableTag(tag));\n  }\n\n  private tag: Tag;\n  private lastUpdated: number;\n\n  private constructor(tag: Tag) {\n    super();\n    this.tag = tag;\n    this.lastUpdated = INITIAL;\n  }\n\n  protected compute(): Revision {\n    return Math.max(this.lastUpdated, this.tag.value());\n  }\n\n  update(tag: Tag) {\n    if (tag !== this.tag) {\n      this.tag = tag;\n      this.lastUpdated = $REVISION;\n      this.invalidate();\n    }\n  }\n}\n\nregister(UpdatableTag);\n\n//////////\n\nexport interface VersionedReference<T> extends Reference<T>, Tagged {}\n\nexport interface VersionedPathReference<T> extends PathReference<T>, Tagged {\n  get(property: string): VersionedPathReference<Opaque>;\n}\n\nexport abstract class CachedReference<T> implements VersionedReference<T> {\n  public abstract tag: Tag;\n\n  private lastRevision: Option<Revision> = null;\n  private lastValue: Option<T> = null;\n\n  value(): T {\n    let { tag, lastRevision, lastValue } = this;\n\n    if (!lastRevision || !tag.validate(lastRevision)) {\n      lastValue = this.lastValue = this.compute();\n      this.lastRevision = tag.value();\n    }\n\n    return lastValue as T;\n  }\n\n  protected abstract compute(): T;\n\n  protected invalidate() {\n    this.lastRevision = null;\n  }\n}\n\n//////////\n\nexport type Mapper<T, U> = (value: T) => U;\n\nclass MapperReference<T, U> extends CachedReference<U> {\n  public tag: Tag;\n\n  private reference: VersionedReference<T>;\n  private mapper: Mapper<T, U>;\n\n  constructor(reference: VersionedReference<T>, mapper: Mapper<T, U>) {\n    super();\n    this.tag = reference.tag;\n    this.reference = reference;\n    this.mapper = mapper;\n  }\n\n  protected compute(): U {\n    let { reference, mapper } = this;\n    return mapper(reference.value());\n  }\n}\n\nexport function map<T, U>(reference: VersionedReference<T>, mapper: Mapper<T, U>): VersionedReference<U> {\n  return new MapperReference<T, U>(reference, mapper);\n}\n\n//////////\n\nexport class ReferenceCache<T> implements Tagged {\n  public tag: Tag;\n\n  private reference: VersionedReference<T>;\n  private lastValue: Option<T> = null;\n  private lastRevision: Option<Revision> = null;\n  private initialized = false;\n\n  constructor(reference: VersionedReference<T>) {\n    this.tag = reference.tag;\n    this.reference = reference;\n  }\n\n  peek(): T {\n    if (!this.initialized) {\n      return this.initialize();\n    }\n\n    return this.lastValue as T;\n  }\n\n  revalidate(): Validation<T> {\n    if (!this.initialized) {\n      return this.initialize();\n    }\n\n    let { reference, lastRevision } = this;\n    let tag = reference.tag;\n\n    if (tag.validate(lastRevision as number)) return NOT_MODIFIED;\n    this.lastRevision = tag.value();\n\n    let { lastValue } = this;\n    let value = reference.value();\n    if (value === lastValue) return NOT_MODIFIED;\n    this.lastValue = value;\n\n    return value;\n  }\n\n  private initialize(): T {\n    let { reference } = this;\n\n    let value = this.lastValue = reference.value();\n    this.lastRevision = reference.tag.value();\n    this.initialized = true;\n\n    return value;\n  }\n}\n\nexport type Validation<T> = T | NotModified;\n\nexport type NotModified = \"adb3b78e-3d22-4e4b-877a-6317c2c5c145\";\n\nconst NOT_MODIFIED: NotModified = \"adb3b78e-3d22-4e4b-877a-6317c2c5c145\";\n\nexport function isModified<T>(value: Validation<T>): value is T {\n  return value !== NOT_MODIFIED;\n}\n","import { CONSTANT_TAG, VersionedReference, Tag } from './validators';\n\nexport class ConstReference<T> implements VersionedReference<T> {\n  public tag: Tag = CONSTANT_TAG;\n\n  constructor(protected inner: T) { }\n\n  value(): T { return this.inner; }\n}\n\nexport function isConst(reference: { tag: Tag }): boolean {\n  return reference.tag === CONSTANT_TAG;\n}\n","import { LinkedList, ListNode, Opaque, Option, dict } from '@glimmer/util';\nimport { VersionedPathReference as PathReference, Tag } from './validators';\n\nexport interface IterationItem<T, U> {\n  key: string;\n  value: T;\n  memo: U;\n}\n\nexport interface AbstractIterator<T, U, V extends IterationItem<T, U>> {\n  isEmpty(): boolean;\n  next(): Option<V>;\n}\n\nexport interface AbstractIterable<T, U, ItemType extends IterationItem<T, U>, ValueReferenceType extends PathReference<T>, MemoReferenceType extends PathReference<U>> {\n  tag: Tag;\n  iterate(): AbstractIterator<T, U, ItemType>;\n\n  valueReferenceFor(item: ItemType): ValueReferenceType;\n  updateValueReference(reference: ValueReferenceType, item: ItemType): void;\n\n  memoReferenceFor(item: ItemType): MemoReferenceType;\n  updateMemoReference(reference: MemoReferenceType, item: ItemType): void;\n}\n\nexport type Iterator<T, U> = AbstractIterator<T, U, IterationItem<T, U>>;\nexport type Iterable<T, U> = AbstractIterable<T, U, IterationItem<T, U>, PathReference<T>, PathReference<U>>;\n\nexport type OpaqueIterationItem = IterationItem<Opaque, Opaque>;\nexport type OpaqueIterator = AbstractIterator<Opaque, Opaque, OpaqueIterationItem>;\nexport type OpaquePathReference = PathReference<Opaque>;\nexport type OpaqueIterable = AbstractIterable<Opaque, Opaque, OpaqueIterationItem, OpaquePathReference, OpaquePathReference>;\nexport type OpaquePathReferenceIterationItem = IterationItem<OpaquePathReference, OpaquePathReference>;\n\nexport class ListItem extends ListNode<OpaquePathReference> implements OpaqueIterationItem {\n  public key: string;\n  public memo: OpaquePathReference;\n  public retained = false;\n  public seen = false;\n  private iterable: OpaqueIterable;\n\n  constructor(iterable: OpaqueIterable, result: OpaqueIterationItem) {\n    super(iterable.valueReferenceFor(result));\n    this.key = result.key;\n    this.iterable = iterable;\n    this.memo = iterable.memoReferenceFor(result);\n  }\n\n  update(item: OpaqueIterationItem) {\n    this.retained = true;\n    this.iterable.updateValueReference(this.value, item);\n    this.iterable.updateMemoReference(this.memo, item);\n  }\n\n  shouldRemove(): boolean {\n    return !this.retained;\n  }\n\n  reset() {\n    this.retained = false;\n    this.seen = false;\n  }\n}\n\nexport class IterationArtifacts {\n  public tag: Tag;\n\n  private iterable: OpaqueIterable;\n  private iterator: Option<OpaqueIterator>;\n  private map = dict<ListItem>();\n  private list = new LinkedList<ListItem>();\n\n  constructor(iterable: OpaqueIterable) {\n    this.tag = iterable.tag;\n    this.iterable = iterable;\n  }\n\n  isEmpty(): boolean {\n    let iterator = this.iterator = this.iterable.iterate();\n    return iterator.isEmpty();\n  }\n\n  iterate(): OpaqueIterator {\n    let iterator = this.iterator || this.iterable.iterate();\n    this.iterator = null;\n\n    return iterator;\n  }\n\n  has(key: string): boolean {\n    return !!this.map[key];\n  }\n\n  get(key: string): ListItem {\n    return this.map[key];\n  }\n\n  wasSeen(key: string): boolean {\n    let node = this.map[key];\n    return node && node.seen;\n  }\n\n  append(item: OpaqueIterationItem): ListItem {\n    let { map, list, iterable } = this;\n    let node = map[item.key] = new ListItem(iterable, item);\n\n    list.append(node);\n    return node;\n  }\n\n  insertBefore(item: OpaqueIterationItem, reference: Option<ListItem>): ListItem {\n    let { map, list, iterable } = this;\n\n    let node = map[item.key] = new ListItem(iterable, item);\n    node.retained = true;\n    list.insertBefore(node, reference);\n    return node;\n  }\n\n  move(item: ListItem, reference: Option<ListItem>): void {\n    let { list } = this;\n\n    item.retained = true;\n    list.remove(item);\n    list.insertBefore(item, reference);\n  }\n\n  remove(item: ListItem): void {\n    let { list } = this;\n\n    list.remove(item);\n    delete this.map[item.key];\n  }\n\n  nextNode(item: ListItem): ListItem {\n    return this.list.nextNode(item);\n  }\n\n  head(): Option<ListItem> {\n    return this.list.head();\n  }\n}\n\nexport class ReferenceIterator {\n  public artifacts: IterationArtifacts;\n  private iterator: Option<OpaqueIterator> = null;\n\n  // if anyone needs to construct this object with something other than\n  // an iterable, let @wycats know.\n  constructor(iterable: OpaqueIterable) {\n    let artifacts = new IterationArtifacts(iterable);\n    this.artifacts = artifacts;\n  }\n\n  next(): Option<ListItem> {\n    let { artifacts } = this;\n\n    let iterator = (this.iterator = this.iterator || artifacts.iterate());\n\n    let item = iterator.next();\n\n    if (!item) return null;\n\n    return artifacts.append(item);\n  }\n}\n\nexport interface IteratorSynchronizerDelegate {\n  retain(key: string, item: PathReference<Opaque>, memo: PathReference<Opaque>): void;\n  insert(key: string, item: PathReference<Opaque>, memo: PathReference<Opaque>, before: Option<string>): void;\n  move(key: string, item: PathReference<Opaque>, memo: PathReference<Opaque>, before: Option<string>): void;\n  delete(key: string): void;\n  done(): void;\n}\n\nexport interface IteratorSynchronizerOptions {\n  target: IteratorSynchronizerDelegate;\n  artifacts: IterationArtifacts;\n}\n\nenum Phase {\n  Append,\n  Prune,\n  Done\n}\n\nexport class IteratorSynchronizer {\n  private target: IteratorSynchronizerDelegate;\n  private iterator: OpaqueIterator;\n  private current: Option<ListItem>;\n  private artifacts: IterationArtifacts;\n\n  constructor({ target, artifacts }: IteratorSynchronizerOptions) {\n    this.target = target;\n    this.artifacts = artifacts;\n    this.iterator = artifacts.iterate();\n    this.current = artifacts.head();\n  }\n\n  sync() {\n    let phase: Phase = Phase.Append;\n\n    while (true) {\n      switch (phase) {\n        case Phase.Append: phase = this.nextAppend(); break;\n        case Phase.Prune: phase = this.nextPrune(); break;\n        case Phase.Done: this.nextDone(); return;\n      }\n    }\n  }\n\n  private advanceToKey(key: string) {\n    let { current, artifacts } = this;\n\n    let seek = current;\n\n    while (seek && seek.key !== key) {\n      seek.seen = true;\n      seek = artifacts.nextNode(seek);\n    }\n\n    this.current = seek && artifacts.nextNode(seek);\n  }\n\n  private nextAppend(): Phase {\n    let { iterator, current, artifacts } = this;\n\n    let item = iterator.next();\n\n    if (item === null) {\n      return this.startPrune();\n    }\n\n    let { key } = item;\n\n    if (current && current.key === key) {\n      this.nextRetain(item);\n    } else if (artifacts.has(key)) {\n      this.nextMove(item);\n    } else {\n      this.nextInsert(item);\n    }\n\n    return Phase.Append;\n  }\n\n  private nextRetain(item: OpaqueIterationItem) {\n    let { artifacts, current } = this;\n\n    current.update(item);\n    this.current = artifacts.nextNode(current);\n    this.target.retain(item.key, current.value, current.memo);\n  }\n\n  private nextMove(item: OpaqueIterationItem) {\n    let { current, artifacts, target } = this;\n    let { key } = item;\n\n    let found = artifacts.get(item.key);\n    found.update(item);\n\n    if (artifacts.wasSeen(item.key)) {\n      artifacts.move(found, current);\n      target.move(found.key, found.value, found.memo, current ? current.key : null);\n    } else {\n      this.advanceToKey(key);\n    }\n  }\n\n  private nextInsert(item: OpaqueIterationItem) {\n    let { artifacts, target, current } = this;\n\n    let node = artifacts.insertBefore(item, current);\n    target.insert(node.key, node.value, node.memo, current ? current.key : null);\n  }\n\n  private startPrune(): Phase {\n    this.current = this.artifacts.head();\n    return Phase.Prune;\n  }\n\n  private nextPrune(): Phase {\n    let { artifacts, target, current } = this;\n\n    if (current === null) {\n      return Phase.Done;\n    }\n\n    let node = current;\n    this.current = artifacts.nextNode(node);\n\n    if (node.shouldRemove()) {\n      artifacts.remove(node);\n      target.delete(node.key);\n    } else {\n      node.reset();\n    }\n\n    return Phase.Prune;\n  }\n\n  private nextDone() {\n    this.target.done();\n  }\n}\n","import { FIXME } from '@glimmer/util';\nimport { PathReference, CachedReference, Tag, combineTagged } from '@glimmer/reference';\nimport { Option, Opaque } from '@glimmer/interfaces';\n\nexport class ConcatReference extends CachedReference<Option<string>> {\n  public tag: Tag;\n\n  constructor(private parts: PathReference<Opaque>[]) {\n    super();\n    this.tag = combineTagged(parts);\n  }\n\n  protected compute(): Option<string> {\n    let parts = new Array<string>();\n\n    for (let i = 0; i < this.parts.length; i++) {\n      let value = this.parts[i].value();\n\n      if (value !== null && value !== undefined) {\n        parts[i] = castToString(value as FIXME<any, 'This works with strict null checks'>) as FIXME<string, 'Coerce falsy values to strings'>;\n      }\n    }\n\n    if (parts.length > 0) {\n      return parts.join('');\n    }\n\n    return null;\n  }\n}\n\nfunction castToString(value: Object) {\n  if (typeof value['toString'] !== 'function') {\n    return '';\n  }\n\n  return String(value);\n}\n","import { Tag, ConstReference, PathReference, Reference } from '@glimmer/reference';\nimport { Option, Opaque } from '@glimmer/util';\n\nexport type Primitive = undefined | null | boolean | number | string;\n\nexport class PrimitiveReference<T extends Primitive> extends ConstReference<T> implements PathReference<T> {\n  static create<T extends Primitive>(value: T): PrimitiveReference<T> {\n    if (value === undefined) {\n      return UNDEFINED_REFERENCE as PrimitiveReference<T>;\n    } else if (value === null) {\n      return NULL_REFERENCE as PrimitiveReference<T>;\n    } else if (value === true) {\n      return TRUE_REFERENCE as PrimitiveReference<T>;\n    } else if (value === false) {\n      return FALSE_REFERENCE as PrimitiveReference<T>;\n    } else if (typeof value === 'number') {\n      return new ValueReference(value as number) as PrimitiveReference<T>;\n    } else {\n      return new StringReference(value as string) as any as PrimitiveReference<T>;\n    }\n  }\n\n  protected constructor(value: T) {\n    super(value);\n  }\n\n  get(_key: string): PrimitiveReference<Primitive> {\n    return UNDEFINED_REFERENCE;\n  }\n}\n\nclass StringReference extends PrimitiveReference<string> {\n  private lengthReference: Option<PrimitiveReference<number>> = null;\n\n  get(key: string): PrimitiveReference<Primitive> {\n    if (key === 'length') {\n      let { lengthReference } = this;\n\n      if (lengthReference === null) {\n        lengthReference = this.lengthReference = new ValueReference(this.inner.length);\n      }\n\n      return lengthReference;\n    } else {\n      return super.get(key);\n    }\n  }\n}\n\ntype Value = undefined | null | number | boolean;\n\nclass ValueReference<T extends Value> extends PrimitiveReference<T> {\n  constructor(value: T) {\n    super(value);\n  }\n}\n\nexport const UNDEFINED_REFERENCE: PrimitiveReference<undefined> = new ValueReference(undefined);\nexport const NULL_REFERENCE: PrimitiveReference<null> = new ValueReference(null);\nexport const TRUE_REFERENCE: PrimitiveReference<boolean> = new ValueReference(true);\nexport const FALSE_REFERENCE: PrimitiveReference<boolean> = new ValueReference(false);\n\nexport class ConditionalReference implements Reference<boolean> {\n  public tag: Tag;\n\n  constructor(private inner: Reference<Opaque>) {\n    this.tag = inner.tag;\n  }\n\n  value(): boolean {\n    return this.toBool(this.inner.value());\n  }\n\n  protected toBool(value: Opaque): boolean {\n    return !!value;\n  }\n}\n","import { APPEND_OPCODES, Op } from '../../opcodes';\nimport { ConcatReference } from '../expressions/concat';\nimport { Helper } from '../../environment';\nimport { TRUE_REFERENCE, FALSE_REFERENCE } from '../../references';\nimport { VersionedPathReference } from '@glimmer/reference';\nimport { Opaque } from '@glimmer/util';\nimport { PublicVM } from \"../../vm\";\nimport { Arguments } from \"../../vm/arguments\";\n\nexport type FunctionExpression<T> = (vm: PublicVM) => VersionedPathReference<T>;\n\nAPPEND_OPCODES.add(Op.Helper, (vm, { op1: _helper }) => {\n  let stack = vm.stack;\n  let helper = vm.constants.getFunction<Helper>(_helper);\n  let args = stack.pop<Arguments>();\n  let value = helper(vm, args);\n\n  args.clear();\n\n  vm.stack.push(value);\n});\n\nAPPEND_OPCODES.add(Op.Function, (vm, { op1: _function }) => {\n  let func = vm.constants.getFunction<FunctionExpression<Opaque>>(_function);\n  vm.stack.push(func(vm));\n});\n\nAPPEND_OPCODES.add(Op.GetVariable, (vm, { op1: symbol }) => {\n  let expr = vm.referenceForSymbol(symbol);\n  vm.stack.push(expr);\n});\n\nAPPEND_OPCODES.add(Op.SetVariable, (vm, { op1: symbol }) => {\n  let expr = vm.stack.pop<VersionedPathReference<Opaque>>();\n  vm.scope().bindSymbol(symbol, expr);\n});\n\nAPPEND_OPCODES.add(Op.ResolveMaybeLocal, (vm, { op1: _name }) => {\n  let name = vm.constants.getString(_name);\n  let locals = vm.scope().getPartialMap()!;\n\n  let ref = locals[name];\n  if (ref === undefined) {\n    ref = vm.getSelf().get(name);\n  }\n\n  vm.stack.push(ref);\n});\n\nAPPEND_OPCODES.add(Op.RootScope, (vm, { op1: symbols, op2: bindCallerScope }) => {\n  vm.pushRootScope(symbols, !!bindCallerScope);\n});\n\nAPPEND_OPCODES.add(Op.GetProperty, (vm, { op1: _key }) => {\n  let key = vm.constants.getString(_key);\n  let expr = vm.stack.pop<VersionedPathReference<Opaque>>();\n  vm.stack.push(expr.get(key));\n});\n\nAPPEND_OPCODES.add(Op.PushBlock, (vm, { op1: _block }) => {\n  let block = _block ? vm.constants.getBlock(_block) : null;\n  vm.stack.push(block);\n});\n\nAPPEND_OPCODES.add(Op.GetBlock, (vm, { op1: _block }) => {\n  vm.stack.push(vm.scope().getBlock(_block));\n});\n\nAPPEND_OPCODES.add(Op.HasBlock, (vm, { op1: _block }) => {\n  let hasBlock = !!vm.scope().getBlock(_block);\n  vm.stack.push(hasBlock ? TRUE_REFERENCE : FALSE_REFERENCE);\n});\n\nAPPEND_OPCODES.add(Op.HasBlockParams, (vm, { op1: _block }) => {\n  let block = vm.scope().getBlock(_block);\n  let hasBlockParams = block && block.symbolTable.parameters.length;\n  vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);\n});\n\nAPPEND_OPCODES.add(Op.Concat, (vm, { op1: count }) => {\n  let out: VersionedPathReference<Opaque>[] = [];\n\n  for (let i=count; i>0; i--) {\n    out.push(vm.stack.pop<VersionedPathReference<Opaque>>());\n  }\n\n  vm.stack.push(new ConcatReference(out.reverse()));\n});\n","import { CompiledDynamicTemplate } from '../blocks';\nimport { OpcodeJSON, UpdatingOpcode } from '../../opcodes';\nimport { UpdatingVM, VM } from '../../vm';\nimport { SymbolTable } from '@glimmer/interfaces';\nimport { Reference, ConstReference, VersionedPathReference } from '@glimmer/reference';\nimport { Option, Opaque, initializeGuid } from '@glimmer/util';\nimport { CONSTANT_TAG, ReferenceCache, Revision, Tag, isConst, isModified } from '@glimmer/reference';\nimport Environment from '../../environment';\nimport { APPEND_OPCODES, Op as Op } from '../../opcodes';\n\nimport {\n  Block\n} from '../../scanner';\n\nimport {\n  NULL_REFERENCE,\n  UNDEFINED_REFERENCE,\n  TRUE_REFERENCE,\n  FALSE_REFERENCE,\n  PrimitiveReference\n} from '../../references';\n\nAPPEND_OPCODES.add(Op.ChildScope, vm => vm.pushChildScope());\n\nAPPEND_OPCODES.add(Op.PopScope, vm => vm.popScope());\n\nAPPEND_OPCODES.add(Op.PushDynamicScope, vm => vm.pushDynamicScope());\n\nAPPEND_OPCODES.add(Op.PopDynamicScope, vm => vm.popDynamicScope());\n\nAPPEND_OPCODES.add(Op.Immediate, (vm, { op1: number }) => {\n  vm.stack.push(number);\n});\n\nAPPEND_OPCODES.add(Op.Constant, (vm, { op1: other }) => {\n  vm.stack.push(vm.constants.getOther(other));\n});\n\nAPPEND_OPCODES.add(Op.PrimitiveReference, (vm, { op1: primitive }) => {\n  let stack = vm.stack;\n  let flag = (primitive & (3 << 30)) >>> 30;\n  let value = primitive & ~(3 << 30);\n\n  switch (flag) {\n    case 0:\n      stack.push(PrimitiveReference.create(value));\n      break;\n    case 1:\n      stack.push(PrimitiveReference.create(vm.constants.getString(value)));\n      break;\n    case 2:\n      switch (value) {\n        case 0: stack.push(FALSE_REFERENCE); break;\n        case 1: stack.push(TRUE_REFERENCE); break;\n        case 2: stack.push(NULL_REFERENCE); break;\n        case 3: stack.push(UNDEFINED_REFERENCE); break;\n      }\n      break;\n  }\n});\n\nAPPEND_OPCODES.add(Op.Dup, (vm, { op1: register, op2: offset }) => {\n  let position = vm.fetchValue<number>(register) - offset;\n  vm.stack.dup(position);\n});\n\nAPPEND_OPCODES.add(Op.Pop, (vm, { op1: count }) => vm.stack.pop(count));\n\nAPPEND_OPCODES.add(Op.Load, (vm, { op1: register }) => vm.load(register));\n\nAPPEND_OPCODES.add(Op.Fetch, (vm, { op1: register }) => vm.fetch(register));\n\nAPPEND_OPCODES.add(Op.BindDynamicScope, (vm, { op1: _names }) => {\n  let names = vm.constants.getArray(_names);\n  vm.bindDynamicScope(names);\n});\n\nAPPEND_OPCODES.add(Op.PushFrame, vm => vm.pushFrame());\n\nAPPEND_OPCODES.add(Op.PopFrame, vm => vm.popFrame());\n\nAPPEND_OPCODES.add(Op.Enter, (vm, { op1: args }) => vm.enter(args));\n\nAPPEND_OPCODES.add(Op.Exit, (vm) => vm.exit());\n\nAPPEND_OPCODES.add(Op.CompileDynamicBlock, vm => {\n  let stack = vm.stack;\n  let block = stack.pop<Block>();\n  stack.push(block ? block.compileDynamic(vm.env) : null);\n});\n\nAPPEND_OPCODES.add(Op.InvokeStatic, (vm, { op1: _block }) => {\n  let block = vm.constants.getBlock(_block);\n  let compiled = block.compileStatic(vm.env);\n  vm.call(compiled.start);\n});\n\nexport interface DynamicInvoker<S extends SymbolTable> {\n  invoke(vm: VM, block: Option<CompiledDynamicTemplate<S>>): void;\n}\n\nAPPEND_OPCODES.add(Op.InvokeDynamic, (vm, { op1: _invoker }) => {\n  let invoker = vm.constants.getOther<DynamicInvoker<SymbolTable>>(_invoker);\n  let block = vm.stack.pop<Option<CompiledDynamicTemplate<SymbolTable>>>();\n  invoker.invoke(vm, block);\n});\n\nAPPEND_OPCODES.add(Op.Jump, (vm, { op1: target }) => vm.goto(target));\n\nAPPEND_OPCODES.add(Op.JumpIf, (vm, { op1: target }) => {\n  let reference = vm.stack.pop<VersionedPathReference<Opaque>>();\n\n  if (isConst(reference)) {\n    if (reference.value()) {\n      vm.goto(target);\n    }\n  } else {\n    let cache = new ReferenceCache(reference);\n\n    if (cache.peek()) {\n      vm.goto(target);\n    }\n\n    vm.updateWith(new Assert(cache));\n  }\n});\n\nAPPEND_OPCODES.add(Op.JumpUnless, (vm, { op1: target }) => {\n  let reference = vm.stack.pop<VersionedPathReference<Opaque>>();\n\n  if (isConst(reference)) {\n    if (!reference.value()) {\n      vm.goto(target);\n    }\n  } else {\n    let cache = new ReferenceCache(reference);\n\n    if (!cache.peek()) {\n      vm.goto(target);\n    }\n\n    vm.updateWith(new Assert(cache));\n  }\n});\n\nAPPEND_OPCODES.add(Op.Return, vm => vm.return());\n\nexport type TestFunction = (ref: Reference<Opaque>, env: Environment) => Reference<boolean>;\n\nexport const ConstTest: TestFunction = function(ref: Reference<Opaque>, _env: Environment): Reference<boolean> {\n  return new ConstReference(!!ref.value());\n};\n\nexport const SimpleTest: TestFunction = function(ref: Reference<Opaque>, _env: Environment): Reference<boolean> {\n  return ref as Reference<boolean>;\n};\n\nexport const EnvironmentTest: TestFunction = function(ref: Reference<Opaque>, env: Environment): Reference<boolean> {\n  return env.toConditionalReference(ref);\n};\n\nAPPEND_OPCODES.add(Op.Test, (vm, { op1: _func }) => {\n  let stack = vm.stack;\n  let operand = stack.pop();\n  let func = vm.constants.getFunction(_func);\n  stack.push(func(operand, vm.env));\n});\n\nexport class Assert extends UpdatingOpcode {\n  public type = \"assert\";\n\n  private cache: ReferenceCache<Opaque>;\n\n  constructor(cache: ReferenceCache<Opaque>) {\n    super();\n    this.tag = cache.tag;\n    this.cache = cache;\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { cache } = this;\n\n    if (isModified(cache.revalidate())) {\n      vm.throw();\n    }\n  }\n}\n\nexport class JumpIfNotModifiedOpcode extends UpdatingOpcode {\n  public type = \"jump-if-not-modified\";\n\n  private lastRevision: Revision;\n\n  constructor(tag: Tag, private target: LabelOpcode) {\n    super();\n    this.tag = tag;\n    this.lastRevision = tag.value();\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { tag, target, lastRevision } = this;\n\n    if (!vm.alwaysRevalidate && tag.validate(lastRevision)) {\n      vm.goto(target);\n    }\n  }\n\n  didModify() {\n    this.lastRevision = this.tag.value();\n  }\n}\n\nexport class DidModifyOpcode extends UpdatingOpcode {\n  public type = \"did-modify\";\n\n  constructor(private target: JumpIfNotModifiedOpcode) {\n    super();\n    this.tag = CONSTANT_TAG;\n  }\n\n  evaluate() {\n    this.target.didModify();\n  }\n}\n\nexport class LabelOpcode implements UpdatingOpcode {\n  public tag: Tag = CONSTANT_TAG;\n  public type = \"label\";\n  public label: Option<string> = null;\n  public _guid: number;\n\n  prev: any = null;\n  next: any = null;\n\n  constructor(label: string) {\n    initializeGuid(this);\n    if (label) this.label = label;\n  }\n\n  evaluate() {}\n\n  inspect(): string {\n    return `${this.label} [${this._guid}]`;\n  }\n}\n","import { EvaluationStack } from './append';\nimport { dict, EMPTY_ARRAY } from '@glimmer/util';\nimport { combineTagged } from '@glimmer/reference';\nimport { Dict, Opaque, Option, unsafe } from '@glimmer/interfaces';\nimport { Tag, VersionedPathReference } from '@glimmer/reference';\nimport { PrimitiveReference, UNDEFINED_REFERENCE } from '../references';\n\n/*\n  The calling convention is:\n\n  * 0-N positional arguments at the bottom (left-to-right)\n  * 0-N named arguments next\n  * an array of names on top\n*/\n\nexport interface IArguments {\n  tag: Tag;\n  length: number;\n  positional: IPositionalArguments;\n  named: INamedArguments;\n\n  at<T extends VersionedPathReference<Opaque>>(pos: number): T;\n  get<T extends VersionedPathReference<Opaque>>(name: string): T;\n  capture(): ICapturedArguments;\n}\n\nexport interface ICapturedArguments {\n  tag: Tag;\n  length: number;\n  positional: ICapturedPositionalArguments;\n  named: ICapturedNamedArguments;\n}\n\nexport interface IPositionalArguments {\n  tag: Tag;\n  length: number;\n  at<T extends VersionedPathReference<Opaque>>(position: number): T;\n  capture(): ICapturedPositionalArguments;\n}\n\nexport interface ICapturedPositionalArguments extends VersionedPathReference<Opaque[]> {\n  tag: Tag;\n  length: number;\n  references: VersionedPathReference<Opaque>[];\n  at<T extends VersionedPathReference<Opaque>>(position: number): T;\n  value(): Opaque[];\n}\n\nexport interface INamedArguments {\n  tag: Tag;\n  names: string[];\n  length: number;\n  has(name: string): boolean;\n  get<T extends VersionedPathReference<Opaque>>(name: string): T;\n  capture(): ICapturedNamedArguments;\n}\n\nexport interface ICapturedNamedArguments extends VersionedPathReference<Dict<Opaque>> {\n  tag: Tag;\n  map: Dict<VersionedPathReference<Opaque>>;\n  names: string[];\n  length: number;\n  references: VersionedPathReference<Opaque>[];\n  has(name: string): boolean;\n  get<T extends VersionedPathReference<Opaque>>(name: string): T;\n  value(): Dict<Opaque>;\n}\n\nexport class Arguments implements IArguments {\n  private stack: EvaluationStack = null as any;\n  public positional: IPositionalArguments = new PositionalArguments();\n  public named: INamedArguments = new NamedArguments();\n\n  empty() {\n    this.setup(null as any as EvaluationStack, 0, true);\n    return this;\n  }\n\n  setup(stack: EvaluationStack, positionalCount: number, synthetic: boolean) {\n    this.stack = stack;\n\n    let names = stack.fromTop<string[]>(0);\n    let namedCount = names.length;\n    let start = positionalCount + namedCount + 1;\n\n    let positional = this.positional as PositionalArguments;\n    positional.setup(stack, start, positionalCount);\n\n    let named = this.named as NamedArguments;\n    named.setup(stack, namedCount, names, synthetic);\n  }\n\n  get tag(): Tag {\n    return combineTagged([this.positional, this.named]);\n  }\n\n  get length(): number {\n    return this.positional.length + this.named.length;\n  }\n\n  at<T extends VersionedPathReference<Opaque>>(pos: number): T {\n    return this.positional.at<T>(pos);\n  }\n\n  get<T extends VersionedPathReference<Opaque>>(name: string): T {\n    return this.named.get<T>(name);\n  }\n\n  capture(): ICapturedArguments {\n    return {\n      tag: this.tag,\n      length: this.length,\n      positional: this.positional.capture(),\n      named: this.named.capture()\n    };\n  }\n\n  clear(): void {\n    let { stack, length } = this;\n    let pops = length + 1;\n\n    while (--pops >= 0) {\n      stack.pop();\n    }\n  }\n}\n\nclass PositionalArguments implements IPositionalArguments {\n  public length = 0;\n\n  private stack: EvaluationStack = null as any;\n  private start = 0;\n\n  private _tag: Option<Tag> = null;\n  private _references: Option<VersionedPathReference<Opaque>[]> = null;\n\n  setup(stack: EvaluationStack, start: number, length: number) {\n    this.stack = stack;\n    this.start = start;\n    this.length = length;\n\n    this._tag = null;\n    this._references = null;\n  }\n\n  get tag(): Tag {\n    let tag = this._tag;\n\n    if (!tag) {\n      tag = this._tag = combineTagged(this.references);\n    }\n\n    return tag;\n  }\n\n  at<T extends VersionedPathReference<Opaque>>(position: number): T {\n    let { start, length } = this;\n\n    if (position < 0 || position >= length) {\n      return UNDEFINED_REFERENCE as unsafe as T;\n    }\n\n    // stack: pos1, pos2, pos3, named1, named2\n    // start: 4 (top - 4)\n    //\n    // at(0) === pos1 === top - start\n    // at(1) === pos2 === top - (start - 1)\n    // at(2) === pos3 === top - (start - 2)\n    let fromTop = start - position - 1;\n    return this.stack.fromTop<T>(fromTop);\n  }\n\n  capture(): ICapturedPositionalArguments {\n    return new CapturedPositionalArguments(this.tag, this.references);\n  }\n\n  private get references() {\n    let references = this._references;\n\n    if (!references) {\n      let { length } = this;\n      references = this._references = new Array(length);\n\n      for (let i=0; i<length; i++) {\n        references[i] = this.at(i);\n      }\n    }\n\n    return references;\n  }\n}\n\nclass CapturedPositionalArguments implements ICapturedPositionalArguments {\n  constructor(\n    public tag: Tag,\n    public references: VersionedPathReference<Opaque>[],\n    public length = references.length\n  ) {}\n\n  at<T extends VersionedPathReference<Opaque>>(position: number): T {\n    return this.references[position] as T;\n  }\n\n  value(): Opaque[] {\n    return this.references.map(this.valueOf);\n  }\n\n  get(name: string): VersionedPathReference<Opaque> {\n    let { references, length } = this;\n\n    if (name === 'length') {\n      return PrimitiveReference.create(length);\n    } else {\n      let idx = parseInt(name, 10);\n\n      if (idx < 0 || idx >= length) {\n        return UNDEFINED_REFERENCE;\n      } else {\n        return references[idx];\n      }\n    }\n  }\n\n  private valueOf(this: void, reference: VersionedPathReference<Opaque>): Opaque {\n    return reference.value();\n  }\n}\n\nclass NamedArguments implements INamedArguments {\n  public length = 0;\n\n  private stack: EvaluationStack;\n\n  private _tag: Option<Tag> = null;\n  private _references: Option<VersionedPathReference<Opaque>[]> = null;\n\n  private _names: Option<string[]> = null;\n  private _realNames: string[] = EMPTY_ARRAY;\n\n  setup(stack: EvaluationStack, length: number, names: string[], synthetic: boolean) {\n    this.stack = stack;\n    this.length = length;\n\n    this._tag = null;\n    this._references = null;\n\n    if (synthetic) {\n      this._names = names;\n      this._realNames = EMPTY_ARRAY;\n    } else {\n      this._names = null;\n      this._realNames = names;\n    }\n  }\n\n  get tag(): Tag {\n    return combineTagged(this.references);\n  }\n\n  get names() {\n    let names = this._names;\n\n    if (!names) {\n      names = this._names = this._realNames.map(this.sliceName);\n    }\n\n    return names;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get<T extends VersionedPathReference<Opaque>>(name: string): T {\n    let { names, length } = this;\n\n    let idx = names.indexOf(name);\n\n    if (idx === -1) {\n      return UNDEFINED_REFERENCE as unsafe as T;\n    }\n\n    // stack: pos1, pos2, pos3, named1, named2\n    // start: 4 (top - 4)\n    // namedDict: { named1: 1, named2: 0 };\n    //\n    // get('named1') === named1 === top - (start - 1)\n    // get('named2') === named2 === top - start\n    let fromTop = length - idx;\n    return this.stack.fromTop<T>(fromTop);\n  }\n\n  capture(): ICapturedNamedArguments {\n    return new CapturedNamedArguments(this.tag, this.names, this.references);\n  }\n\n  private get references() {\n    let references = this._references;\n\n    if (!references) {\n      let { names, length } = this;\n      references = this._references = [];\n\n      for (let i=0; i<length; i++) {\n        references[i] = this.get(names[i]);\n      }\n    }\n\n    return references;\n  }\n\n  private sliceName(this: void, name: string) {\n    return name.slice(1);\n  }\n}\n\nclass CapturedNamedArguments implements ICapturedNamedArguments {\n  public length: number;\n  private _map: Option<Dict<VersionedPathReference<Opaque>>>;\n\n  constructor(\n    public tag: Tag,\n    public names: string[],\n    public references: VersionedPathReference<Opaque>[]\n  ) {\n    this.length = names.length;\n    this._map = null;\n  }\n\n  get map() {\n    let map = this._map;\n\n    if (!map) {\n      let { names, references } = this;\n      map = this._map = dict<VersionedPathReference<Opaque>>();\n      names.forEach((name, i) => map![name] = references[i]);\n    }\n\n    return map;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get<T extends VersionedPathReference<Opaque>>(name: string): T {\n    let { names, references } = this;\n    let idx = names.indexOf(name);\n\n    if (idx === -1) {\n      return UNDEFINED_REFERENCE as unsafe as T;\n    } else {\n      return references[idx] as T;\n    }\n  }\n\n  value(): Dict<Opaque> {\n    let { names, references } = this;\n    let out = dict<Opaque>();\n\n    names.forEach((name, i) => out[name] = references[i].value());\n\n    return out;\n  }\n}\n\nexport default new Arguments();\n","import { UpdatingOpcode } from '../../opcodes';\nimport { VM, UpdatingVM } from '../../vm';\nimport { Arguments } from '../../vm/arguments';\nimport * as Simple from '../../dom/interfaces';\nimport { FIX_REIFICATION } from '../../dom/interfaces';\nimport { Environment } from '../../environment';\nimport { FIXME, Option, Opaque } from '@glimmer/util';\nimport {\n  CachedReference,\n  Reference,\n  VersionedReference,\n  ReferenceCache,\n  Tag,\n  Revision,\n  PathReference,\n  combineTagged,\n  isConst as isConstReference,\n  isModified\n} from '@glimmer/reference';\nimport { ModifierManager } from '../../modifier/interfaces';\nimport { NULL_REFERENCE, PrimitiveReference } from '../../references';\nimport { AttributeManager } from '../../dom/attribute-managers';\nimport { ElementOperations } from '../../builder';\nimport { Assert } from './vm';\nimport { APPEND_OPCODES, Op as Op } from '../../opcodes';\n\nAPPEND_OPCODES.add(Op.Text, (vm, { op1: text }) => {\n  vm.elements().appendText(vm.constants.getString(text));\n});\n\nAPPEND_OPCODES.add(Op.Comment, (vm, { op1: text }) => {\n  vm.elements().appendComment(vm.constants.getString(text));\n});\n\nAPPEND_OPCODES.add(Op.OpenElement, (vm, { op1: tag }) => {\n  vm.elements().openElement(vm.constants.getString(tag));\n});\n\nAPPEND_OPCODES.add(Op.OpenElementWithOperations, (vm, { op1: tag }) => {\n  let tagName = vm.constants.getString(tag);\n  let operations = vm.stack.pop<ElementOperations>();\n  vm.elements().openElement(tagName, operations);\n});\n\nAPPEND_OPCODES.add(Op.OpenDynamicElement, vm => {\n  let operations = vm.stack.pop<ElementOperations>();\n  let tagName = vm.stack.pop<Reference<string>>().value();\n  vm.elements().openElement(tagName, operations);\n});\n\nAPPEND_OPCODES.add(Op.PushRemoteElement, vm => {\n  let elementRef = vm.stack.pop<Reference<Simple.Element>>();\n  let nextSiblingRef = vm.stack.pop<Reference<Option<Simple.Node>>>();\n\n  let element: Simple.Element;\n  let nextSibling: Option<Simple.Node>;\n\n  if (isConstReference(elementRef)) {\n    element = elementRef.value();\n  } else {\n    let cache = new ReferenceCache(elementRef);\n    element = cache.peek();\n    vm.updateWith(new Assert(cache));\n  }\n\n  if (isConstReference(nextSiblingRef)) {\n    nextSibling = nextSiblingRef.value();\n  } else {\n    let cache = new ReferenceCache(nextSiblingRef);\n    nextSibling = cache.peek();\n    vm.updateWith(new Assert(cache));\n  }\n\n  vm.elements().pushRemoteElement(element, nextSibling);\n});\n\nAPPEND_OPCODES.add(Op.PopRemoteElement, vm => vm.elements().popRemoteElement());\n\nclass ClassList {\n  private list: Option<Reference<string>[]> = null;\n  private isConst = true;\n\n  append(reference: Reference<string>) {\n    let { list, isConst } = this;\n\n    if (list === null) list = this.list = [];\n\n    list.push(reference);\n    this.isConst = isConst && isConstReference(reference);\n  }\n\n  toReference(): Reference<Option<string>> {\n    let { list, isConst } = this;\n\n    if (!list) return NULL_REFERENCE;\n\n    if (isConst) return PrimitiveReference.create(toClassName(list));\n\n    return new ClassListReference(list);\n  }\n\n}\n\nclass ClassListReference extends CachedReference<Option<string>> {\n  public tag: Tag;\n  private list: Reference<string>[] = [];\n\n  constructor(list: Reference<string>[]) {\n    super();\n    this.tag = combineTagged(list);\n    this.list = list;\n  }\n\n  protected compute(): Option<string> {\n    return toClassName(this.list);\n  }\n}\n\nfunction toClassName(list: Reference<string>[]): Option<string> {\n  let ret: Opaque[] = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let value: FIXME<Opaque, 'use Opaque and normalize'> = list[i].value();\n    if (value !== false && value !== null && value !== undefined) ret.push(value);\n  }\n\n  return (ret.length === 0) ? null : ret.join(' ');\n}\n\nexport class SimpleElementOperations implements ElementOperations {\n  private opcodes: Option<UpdatingOpcode[]> = null;\n  private classList: Option<ClassList> = null;\n\n  constructor(private env: Environment) {\n  }\n\n  addStaticAttribute(element: Simple.Element, name: string, value: string) {\n    if (name === 'class') {\n      this.addClass(PrimitiveReference.create(value));\n    } else {\n      this.env.getAppendOperations().setAttribute(element, name, value);\n    }\n  }\n\n  addStaticAttributeNS(element: Simple.Element, namespace: string, name: string, value: string) {\n    this.env.getAppendOperations().setAttribute(element, name, value, namespace);\n  }\n\n  addDynamicAttribute(element: Simple.Element, name: string, reference: Reference<string>, isTrusting: boolean) {\n    if (name === 'class') {\n      this.addClass(reference);\n    } else {\n      let attributeManager = this.env.attributeFor(element, name, isTrusting);\n      let attribute = new DynamicAttribute(element, attributeManager, name, reference);\n\n      this.addAttribute(attribute);\n    }\n  }\n\n  addDynamicAttributeNS(element: Simple.Element, namespace: Simple.Namespace, name: string, reference: PathReference<string>, isTrusting: boolean) {\n    let attributeManager = this.env.attributeFor(element, name, isTrusting, namespace);\n    let nsAttribute = new DynamicAttribute(element, attributeManager, name, reference, namespace);\n\n    this.addAttribute(nsAttribute);\n  }\n\n  flush(element: Simple.Element, vm: VM) {\n    let { env } = vm;\n    let { opcodes, classList } = this;\n\n    for (let i = 0; opcodes && i < opcodes.length; i++) {\n      vm.updateWith(opcodes[i]);\n    }\n\n    if (classList) {\n      let attributeManager = env.attributeFor(element, 'class', false);\n      let attribute = new DynamicAttribute(element, attributeManager, 'class', classList.toReference());\n      let opcode = attribute.flush(env);\n\n      if (opcode) {\n        vm.updateWith(opcode);\n      }\n    }\n\n    this.opcodes = null;\n    this.classList = null;\n  }\n\n  private addClass(reference: Reference<string>) {\n    let { classList } = this;\n\n    if (!classList) {\n      classList = this.classList = new ClassList();\n    }\n\n    classList.append(reference);\n  }\n\n  private addAttribute(attribute: Attribute) {\n    let opcode = attribute.flush(this.env);\n\n    if (opcode) {\n      let { opcodes } = this;\n\n      if (!opcodes) {\n        opcodes = this.opcodes = [];\n      }\n\n      opcodes.push(opcode);\n    }\n  }\n}\n\nexport class ComponentElementOperations implements ElementOperations {\n  private attributeNames: Option<string[]> = null;\n  private attributes: Option<Attribute[]> = null;\n  private classList: Option<ClassList> = null;\n\n  constructor(private env: Environment) {\n  }\n\n  addStaticAttribute(element: Simple.Element, name: string, value: string) {\n    if (name === 'class') {\n      this.addClass(PrimitiveReference.create(value));\n    } else if (this.shouldAddAttribute(name)) {\n      this.addAttribute(name, new StaticAttribute(element, name, value));\n    }\n  }\n\n  addStaticAttributeNS(element: Simple.Element, namespace: string, name: string, value: string) {\n    if (this.shouldAddAttribute(name)) {\n      this.addAttribute(name, new StaticAttribute(element, name, value, namespace));\n    }\n  }\n\n  addDynamicAttribute(element: Simple.Element, name: string, reference: PathReference<string>, isTrusting: boolean) {\n    if (name === 'class') {\n      this.addClass(reference);\n    } else if (this.shouldAddAttribute(name)) {\n      let attributeManager = this.env.attributeFor(element, name, isTrusting);\n      let attribute = new DynamicAttribute(element, attributeManager, name, reference);\n\n      this.addAttribute(name, attribute);\n    }\n  }\n\n  addDynamicAttributeNS(element: Simple.Element, namespace: Simple.Namespace, name: string, reference: PathReference<string>, isTrusting: boolean) {\n    if (this.shouldAddAttribute(name)) {\n      let attributeManager = this.env.attributeFor(element, name, isTrusting, namespace);\n      let nsAttribute = new DynamicAttribute(element, attributeManager, name, reference, namespace);\n\n      this.addAttribute(name, nsAttribute);\n    }\n  }\n\n  flush(element: Simple.Element, vm: VM) {\n    let { env } = this;\n    let { attributes, classList } = this;\n\n    for (let i = 0; attributes && i < attributes.length; i++) {\n      let opcode = attributes[i].flush(env);\n\n      if (opcode) {\n        vm.updateWith(opcode);\n      }\n    }\n\n    if (classList) {\n      let attributeManager = env.attributeFor(element, 'class', false);\n      let attribute = new DynamicAttribute(element, attributeManager, 'class', classList.toReference());\n      let opcode = attribute.flush(env);\n\n      if (opcode) {\n        vm.updateWith(opcode);\n      }\n    }\n  }\n\n  private shouldAddAttribute(name: string): boolean {\n    return !this.attributeNames || this.attributeNames.indexOf(name) === -1;\n  }\n\n  private addClass(reference: PathReference<string>) {\n    let { classList } = this;\n\n    if (!classList) {\n      classList = this.classList = new ClassList();\n    }\n\n    classList.append(reference);\n  }\n\n  private addAttribute(name: string, attribute: Attribute) {\n    let { attributeNames, attributes } = this;\n\n    if (!attributeNames) {\n      attributeNames = this.attributeNames = [];\n      attributes = this.attributes = [];\n    }\n\n    attributeNames.push(name);\n    attributes.push(attribute);\n  }\n}\n\nAPPEND_OPCODES.add(Op.FlushElement, vm => {\n  let stack = vm.elements();\n\n  let action = 'FlushElementOpcode#evaluate';\n  stack.expectOperations(action).flush(stack.expectConstructing(action), vm);\n  stack.flushElement();\n});\n\nAPPEND_OPCODES.add(Op.CloseElement, vm => vm.elements().closeElement());\n\nAPPEND_OPCODES.add(Op.StaticAttr, (vm, { op1: _name, op2: _value, op3: _namespace }) => {\n  let name = vm.constants.getString(_name);\n  let value = vm.constants.getString(_value);\n\n  if (_namespace) {\n    let namespace = vm.constants.getString(_namespace);\n    vm.elements().setStaticAttributeNS(namespace, name, value);\n  } else {\n    vm.elements().setStaticAttribute(name, value);\n  }\n});\n\nAPPEND_OPCODES.add(Op.Modifier, (vm, { op1: _manager }) => {\n  let manager = vm.constants.getOther<ModifierManager<Opaque>>(_manager);\n  let stack = vm.stack;\n  let args = stack.pop<Arguments>();\n  let tag = args.tag;\n  let { constructing: element, updateOperations } = vm.elements();\n  let dynamicScope = vm.dynamicScope();\n  let modifier = manager.create(element as FIX_REIFICATION<Element>, args, dynamicScope, updateOperations);\n\n  args.clear();\n\n  vm.env.scheduleInstallModifier(modifier, manager);\n  let destructor = manager.getDestructor(modifier);\n\n  if (destructor) {\n    vm.newDestroyable(destructor);\n  }\n\n  vm.updateWith(new UpdateModifierOpcode(\n    tag,\n    manager,\n    modifier\n  ));\n});\n\nexport class UpdateModifierOpcode extends UpdatingOpcode {\n  public type = \"update-modifier\";\n  private lastUpdated: Revision;\n\n  constructor(\n    public tag: Tag,\n    private manager: ModifierManager<Opaque>,\n    private modifier: Opaque\n  ) {\n    super();\n    this.lastUpdated = tag.value();\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { manager, modifier, tag, lastUpdated } = this;\n\n    if (!tag.validate(lastUpdated)) {\n      vm.env.scheduleUpdateModifier(modifier, manager);\n      this.lastUpdated = tag.value();\n    }\n  }\n}\n\nexport interface Attribute {\n  name: string;\n  flush(env: Environment): Option<UpdatingOpcode>;\n}\n\nexport class StaticAttribute implements Attribute {\n  constructor(\n    private element: Simple.Element,\n    public name: string,\n    private value: string,\n    private namespace?: string\n  ) {}\n\n  flush(env: Environment): Option<UpdatingOpcode> {\n    env.getAppendOperations().setAttribute(this.element, this.name, this.value, this.namespace);\n    return null;\n  }\n}\n\nexport class DynamicAttribute implements Attribute  {\n  private cache: Option<ReferenceCache<Opaque>> = null;\n\n  public tag: Tag;\n\n  constructor(\n    private element: Simple.Element,\n    private attributeManager: AttributeManager,\n    public name: string,\n    private reference: Reference<Opaque>,\n    private namespace?: Simple.Namespace\n  ) {\n    this.tag = reference.tag;\n  }\n\n  patch(env: Environment) {\n    let { element, cache } = this;\n\n    let value = cache.revalidate();\n\n    if (isModified(value)) {\n      this.attributeManager.updateAttribute(env, element as FIXME<Element, 'needs to be reified properly'>, value, this.namespace);\n    }\n  }\n\n  flush(env: Environment): Option<UpdatingOpcode> {\n    let { reference, element } = this;\n\n    if (isConstReference(reference)) {\n      let value = reference.value();\n      this.attributeManager.setAttribute(env, element, value, this.namespace);\n      return null;\n    } else {\n      let cache = this.cache = new ReferenceCache(reference);\n      let value = cache.peek();\n      this.attributeManager.setAttribute(env, element, value, this.namespace);\n      return new PatchElementOpcode(this);\n    }\n  }\n}\n\nfunction formatElement(element: Simple.Element): string {\n  return JSON.stringify(`<${element.tagName.toLowerCase()} />`);\n}\n\nAPPEND_OPCODES.add(Op.DynamicAttrNS, (vm, { op1: _name, op2: _namespace, op3: trusting }) => {\n  let name = vm.constants.getString(_name);\n  let namespace = vm.constants.getString(_namespace);\n  let reference = vm.stack.pop<VersionedReference<string>>();\n  vm.elements().setDynamicAttributeNS(namespace, name, reference, !!trusting);\n});\n\nAPPEND_OPCODES.add(Op.DynamicAttr, (vm, { op1: _name, op2: trusting }) => {\n  let name = vm.constants.getString(_name);\n  let reference = vm.stack.pop<VersionedReference<string>>();\n  vm.elements().setDynamicAttribute(name, reference, !!trusting);\n});\n\nexport class PatchElementOpcode extends UpdatingOpcode {\n  public type = \"patch-element\";\n\n  private operation: DynamicAttribute;\n\n  constructor(operation: DynamicAttribute) {\n    super();\n    this.tag = operation.tag;\n    this.operation = operation;\n  }\n\n  evaluate(vm: UpdatingVM) {\n    this.operation.patch(vm.env);\n  }\n}\n","import { APPEND_OPCODES, Op, OpcodeJSON, UpdatingOpcode } from '../../opcodes';\nimport { Assert } from './vm';\nimport { UpdatingVM } from '../../vm';\nimport ARGS, { Arguments, IArguments } from '../../vm/arguments';\nimport { Component, ComponentManager, ComponentDefinition } from '../../component/interfaces';\nimport { DynamicScope } from '../../environment';\nimport Bounds from '../../bounds';\nimport { ComponentElementOperations } from './dom';\nimport { Opaque } from '@glimmer/util';\nimport {\n  CONSTANT_TAG,\n  ReferenceCache,\n  VersionedPathReference,\n  Tag,\n  combine,\n  isConst\n} from '@glimmer/reference';\n\nAPPEND_OPCODES.add(Op.PushComponentManager, (vm, { op1: _definition }) => {\n  let definition = vm.constants.getOther<ComponentDefinition<Opaque>>(_definition);\n  let stack = vm.stack;\n\n  stack.push(definition);\n  stack.push(definition.manager);\n});\n\nAPPEND_OPCODES.add(Op.PushDynamicComponentManager, vm => {\n  let stack = vm.stack;\n  let reference = stack.pop<VersionedPathReference<ComponentDefinition<Opaque>>>();\n  let cache = isConst(reference) ? undefined : new ReferenceCache<ComponentDefinition<Opaque>>(reference);\n  let definition = cache ? cache.peek() : reference.value();\n\n  stack.push(definition);\n  stack.push(definition.manager);\n\n  if (cache) {\n    vm.updateWith(new Assert(cache));\n  }\n});\n\ninterface InitialComponentState<T> {\n  definition: ComponentDefinition<T>;\n  manager: ComponentManager<T>;\n  component: null;\n}\n\nexport interface ComponentState<T> {\n  definition: ComponentDefinition<T>;\n  manager: ComponentManager<T>;\n  component: T;\n}\n\nAPPEND_OPCODES.add(Op.InitializeComponentState, vm => {\n  let stack = vm.stack;\n\n  let manager = stack.pop();\n  let definition = stack.pop();\n\n  stack.push({ definition, manager, component: null });\n});\n\nAPPEND_OPCODES.add(Op.PushArgs, (vm, { op1: positional, op2: synthetic }) => {\n  let stack = vm.stack;\n  ARGS.setup(stack, positional, !!synthetic);\n  stack.push(ARGS);\n});\n\nAPPEND_OPCODES.add(Op.PrepareArgs, (vm, { op1: _state }) => {\n  let stack = vm.stack;\n  let { definition, manager } = vm.fetchValue<InitialComponentState<Opaque>>(_state);\n  let args = stack.pop<Arguments>();\n\n  let preparedArgs = manager.prepareArgs(definition, args);\n\n  if (preparedArgs) {\n    args.clear();\n\n    let { positional, named } = preparedArgs;\n\n    let positionalCount = positional.length;\n\n    for (let i=0; i<positionalCount; i++) {\n      stack.push(positional[i]);\n    }\n\n    let names = Object.keys(named);\n    let namedCount = names.length;\n\n    for (let i=0; i<namedCount; i++) {\n      stack.push(named[names[i]]);\n    }\n\n    stack.push(names);\n    args.setup(stack, positionalCount, true);\n  }\n\n  stack.push(args);\n});\n\nAPPEND_OPCODES.add(Op.CreateComponent, (vm, { op1: flags, op2: _state }) => {\n  let definition, manager;\n  let args = vm.stack.pop<IArguments>();\n  let dynamicScope = vm.dynamicScope();\n  let state = { definition, manager } = vm.fetchValue<InitialComponentState<Opaque>>(_state);\n\n  let hasDefaultBlock = flags & 0b01;\n\n  let component = manager.create(vm.env, definition, args, dynamicScope, vm.getSelf(), !!hasDefaultBlock);\n  (state as ComponentState<typeof component>).component = component;\n\n  vm.updateWith(new UpdateComponentOpcode(args.tag, definition.name, component, manager, dynamicScope));\n});\n\nAPPEND_OPCODES.add(Op.RegisterComponentDestructor, (vm, { op1: _state }) => {\n  let { manager, component } = vm.fetchValue<ComponentState<Opaque>>(_state);\n\n  let destructor = manager.getDestructor(component);\n  if (destructor) vm.newDestroyable(destructor);\n});\n\nAPPEND_OPCODES.add(Op.BeginComponentTransaction, vm => {\n  vm.beginCacheGroup();\n  vm.elements().pushSimpleBlock();\n});\n\nAPPEND_OPCODES.add(Op.PushComponentOperations, vm => {\n  vm.stack.push(new ComponentElementOperations(vm.env));\n});\n\nAPPEND_OPCODES.add(Op.DidCreateElement, (vm, { op1: _state }) => {\n  let { manager, component } = vm.fetchValue<ComponentState<Opaque>>(_state);\n\n  let action = 'DidCreateElementOpcode#evaluate';\n  manager.didCreateElement(component, vm.elements().expectConstructing(action), vm.elements().expectOperations(action));\n});\n\nAPPEND_OPCODES.add(Op.GetComponentSelf, (vm, { op1: _state }) => {\n  let state = vm.fetchValue<ComponentState<Opaque>>(_state);\n  vm.stack.push(state.manager.getSelf(state.component));\n});\n\nAPPEND_OPCODES.add(Op.GetComponentLayout, (vm, { op1: _state }) => {\n  let { manager, definition, component } = vm.fetchValue<ComponentState<Opaque>>(_state);\n  vm.stack.push(manager.layoutFor(definition, component, vm.env));\n});\n\nAPPEND_OPCODES.add(Op.DidRenderLayout, (vm, { op1: _state }) => {\n  let { manager, component } = vm.fetchValue<ComponentState<Opaque>>(_state);\n  let bounds = vm.elements().popBlock();\n\n  manager.didRenderLayout(component, bounds);\n\n  vm.env.didCreate(component, manager);\n\n  vm.updateWith(new DidUpdateLayoutOpcode(manager, component, bounds));\n});\n\nAPPEND_OPCODES.add(Op.CommitComponentTransaction, vm => vm.commitCacheGroup());\n\nexport class UpdateComponentOpcode extends UpdatingOpcode {\n  public type = \"update-component\";\n\n  constructor(\n    tag: Tag,\n    private name: string,\n    private component: Component,\n    private manager: ComponentManager<Component>,\n    private dynamicScope: DynamicScope,\n  ) {\n    super();\n\n    let componentTag = manager.getTag(component);\n\n    if (componentTag) {\n      this.tag = combine([tag, componentTag]);\n    } else {\n      this.tag = tag;\n    }\n  }\n\n  evaluate(_vm: UpdatingVM) {\n    let { component, manager, dynamicScope } = this;\n\n    manager.update(component, dynamicScope);\n  }\n}\n\nexport class DidUpdateLayoutOpcode extends UpdatingOpcode {\n  public type = \"did-update-layout\";\n  public tag: Tag = CONSTANT_TAG;\n\n  constructor(\n    private manager: ComponentManager<Component>,\n    private component: Component,\n    private bounds: Bounds\n  ) {\n    super();\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { manager, component, bounds } = this;\n\n    manager.didUpdateLayout(component, bounds);\n\n    vm.env.didUpdate(component, manager);\n  }\n}\n","import * as Simple from './dom/interfaces';\nimport { Option, Destroyable } from '@glimmer/util';\n\nexport interface Bounds {\n  // a method to future-proof for wormholing; may not be needed ultimately\n  parentElement(): Simple.Element;\n  firstNode(): Option<Simple.Node>;\n  lastNode(): Option<Simple.Node>;\n}\n\nexport class Cursor {\n  constructor(public element: Simple.Element, public nextSibling: Option<Simple.Node>) {}\n}\n\nexport default Bounds;\n\nexport interface DestroyableBounds extends Bounds, Destroyable {}\n\nexport class RealDOMBounds implements Bounds {\n  constructor(private bounds: Bounds) {}\n\n  parentElement() { return this.bounds.parentElement() as Element; }\n  firstNode() { return this.bounds.firstNode() as Node; }\n  lastNode() { return this.bounds.lastNode() as Node; }\n}\n\nexport class ConcreteBounds implements Bounds {\n  constructor(public parentNode: Simple.Element, private first: Option<Simple.Node>, private last: Option<Simple.Node>) {}\n\n  parentElement() { return this.parentNode; }\n  firstNode() { return this.first; }\n  lastNode() { return this.last; }\n}\n\nexport class SingleNodeBounds implements Bounds {\n  private parentNode: Element;\n  private node: Node;\n\n  constructor(parentNode: Simple.Element, node: Simple.Node) {\n    this.parentNode = parentNode as Element;\n    this.node = node as Node;\n  }\n\n  parentElement() { return this.parentNode; }\n  firstNode() { return this.node; }\n  lastNode() { return this.node; }\n}\n\nexport function bounds(parent: Simple.Element, first: Simple.Node, last: Simple.Node): Bounds {\n  return new ConcreteBounds(parent, first, last);\n}\n\nexport function single(parent: Simple.Element, node: Simple.Node): Bounds {\n  return new SingleNodeBounds(parent, node);\n}\n\nexport function move(bounds: Bounds, reference: Option<Simple.Node>) {\n  let parent = bounds.parentElement();\n  let first = bounds.firstNode();\n  let last = bounds.lastNode();\n\n  let node: Option<Simple.Node> = first;\n\n  while (node) {\n    let next = node.nextSibling;\n    parent.insertBefore(node, reference);\n    if (node === last) return next;\n    node = next;\n  }\n\n  return null;\n}\n\nexport function clear(bounds: Bounds): Option<Simple.Node> {\n  let parent = bounds.parentElement();\n  let first = bounds.firstNode();\n  let last = bounds.lastNode();\n\n  let node: Option<Simple.Node> = first;\n\n  while (node) {\n    let next = node.nextSibling;\n    parent.removeChild(node);\n    if (node === last) return next;\n    node = next;\n  }\n\n  return null;\n}\n","import { Opaque } from '@glimmer/util';\nimport { DOMChanges, DOMTreeConstruction } from './dom/helper';\nimport * as Simple from './dom/interfaces';\nimport { FIX_REIFICATION } from './dom/interfaces';\nimport { Bounds, Cursor, SingleNodeBounds, single, clear } from './bounds';\n\nexport interface SafeString {\n  toHTML(): string;\n}\n\nexport function isSafeString(value: Opaque): value is SafeString {\n  return !!value && typeof value['toHTML'] === 'function';\n}\n\nexport function isNode(value: Opaque): value is Node {\n  return value !== null && typeof value === 'object' && typeof value['nodeType'] === 'number';\n}\n\nexport function isString(value: Opaque): value is string {\n  return typeof value === 'string';\n}\n\nexport type Insertion = CautiousInsertion | TrustingInsertion;\nexport type CautiousInsertion = string | SafeString | Node;\nexport type TrustingInsertion = string | Node;\n\nabstract class Upsert {\n  constructor(public bounds: Bounds) {\n  }\n\n  abstract update(dom: DOMChanges, value: Insertion): boolean;\n}\n\nexport default Upsert;\n\nexport function cautiousInsert(dom: DOMTreeConstruction, cursor: Cursor, value: CautiousInsertion): Upsert {\n  if (isString(value)) {\n    return TextUpsert.insert(dom, cursor, value);\n  }\n  if (isSafeString(value)) {\n    return SafeStringUpsert.insert(dom, cursor, value);\n  }\n  if (isNode(value)) {\n    return NodeUpsert.insert(dom, cursor, value);\n  }\n\n}\n\nexport function trustingInsert(dom: DOMTreeConstruction, cursor: Cursor, value: TrustingInsertion): Upsert {\n  if (isString(value)) {\n    return HTMLUpsert.insert(dom, cursor, value);\n  }\n  if (isNode(value)) {\n    return NodeUpsert.insert(dom, cursor, value);\n  }\n\n}\n\nclass TextUpsert extends Upsert {\n  static insert(dom: DOMTreeConstruction, cursor: Cursor, value: string): Upsert {\n    let textNode = dom.createTextNode(value);\n    dom.insertBefore(cursor.element, textNode, cursor.nextSibling);\n    let bounds = new SingleNodeBounds(cursor.element, textNode);\n    return new TextUpsert(bounds, textNode);\n  }\n\n  private textNode: Text;\n\n  constructor(bounds: Bounds, textNode: Simple.Text) {\n    super(bounds);\n    this.textNode = textNode as Text;\n  }\n\n  update(_dom: DOMChanges, value: Insertion): boolean {\n    if (isString(value)) {\n      let { textNode } = this;\n      textNode.nodeValue = value;\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nclass HTMLUpsert extends Upsert {\n  static insert(dom: DOMTreeConstruction, cursor: Cursor, value: string): Upsert {\n    let bounds = dom.insertHTMLBefore(cursor.element, value, cursor.nextSibling);\n    return new HTMLUpsert(bounds);\n  }\n\n  update(dom: DOMChanges, value: Insertion): boolean {\n    if (isString(value)) {\n      let { bounds } = this;\n\n      let parentElement = bounds.parentElement();\n      let nextSibling = clear(bounds);\n\n      this.bounds = dom.insertHTMLBefore(parentElement as FIX_REIFICATION<Element>, nextSibling as FIX_REIFICATION<Node>, value);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nclass SafeStringUpsert extends Upsert {\n  static insert(dom: DOMTreeConstruction, cursor: Cursor, value: SafeString): Upsert {\n    let stringValue = value.toHTML();\n    let bounds = dom.insertHTMLBefore(cursor.element, stringValue, cursor.nextSibling);\n    return new SafeStringUpsert(bounds, stringValue);\n  }\n\n  constructor(bounds: Bounds, private lastStringValue: string) {\n    super(bounds);\n  }\n\n  update(dom: DOMChanges, value: Insertion): boolean {\n    if (isSafeString(value)) {\n      let stringValue = value.toHTML();\n\n      if (stringValue !== this.lastStringValue) {\n        let { bounds } = this;\n\n        let parentElement = bounds.parentElement();\n        let nextSibling = clear(bounds);\n\n        this.bounds = dom.insertHTMLBefore(parentElement as FIX_REIFICATION<Element>, nextSibling as FIX_REIFICATION<Node>, stringValue);\n        this.lastStringValue = stringValue;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nclass NodeUpsert extends Upsert {\n  static insert(dom: DOMTreeConstruction, cursor: Cursor, node: Simple.Node): Upsert {\n    dom.insertBefore(cursor.element, node, cursor.nextSibling);\n    return new NodeUpsert(single(cursor.element, node));\n  }\n\n  update(dom: DOMChanges, value: Insertion): boolean {\n    if (isNode(value)) {\n      let { bounds } = this;\n\n      let parentElement = bounds.parentElement();\n      let nextSibling = clear(bounds);\n\n      this.bounds = dom.insertNodeBefore(parentElement as FIX_REIFICATION<Element>, value, nextSibling as FIX_REIFICATION<Node>);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","import Bounds, { Cursor, DestroyableBounds, clear } from './bounds';\n\nimport { DOMChanges, DOMTreeConstruction } from './dom/helper';\n\nimport { Option, Destroyable, Stack, LinkedList, LinkedListNode, } from '@glimmer/util';\n\nimport { Environment } from './environment';\n\nimport { VM } from './vm';\n\nimport { VersionedReference } from '@glimmer/reference';\n\nimport {\n  SimpleElementOperations\n} from './compiled/opcodes/dom';\n\nimport * as Simple from './dom/interfaces';\n\nexport interface FirstNode {\n  firstNode(): Option<Simple.Node>;\n}\n\nexport interface LastNode {\n  lastNode(): Option<Simple.Node>;\n}\n\nclass First {\n  constructor(private node: Node) { }\n\n  firstNode(): Node {\n    return this.node;\n  }\n}\n\nclass Last {\n  constructor(private node: Node) { }\n\n  lastNode(): Node {\n    return this.node;\n  }\n}\n\nexport interface ElementOperations {\n  addStaticAttribute(element: Simple.Element, name: string, value: string): void;\n  addStaticAttributeNS(element: Simple.Element, namespace: string, name: string, value: string): void;\n  addDynamicAttribute(element: Simple.Element, name: string, value: VersionedReference<string>, isTrusting: boolean): void;\n  addDynamicAttributeNS(element: Simple.Element, namespace: string, name: string, value: VersionedReference<string>, isTrusting: boolean): void;\n  flush(element: Simple.Element, vm: VM): void;\n}\n\nexport class Fragment implements Bounds {\n  private bounds: Bounds;\n\n  constructor(bounds: Bounds) {\n    this.bounds = bounds;\n  }\n\n  parentElement(): Simple.Element {\n    return this.bounds.parentElement();\n  }\n\n  firstNode(): Option<Simple.Node> {\n    return this.bounds.firstNode();\n  }\n\n  lastNode(): Option<Simple.Node> {\n    return this.bounds.lastNode();\n  }\n\n  update(bounds: Bounds) {\n    this.bounds = bounds;\n  }\n}\n\nexport class ElementStack implements Cursor {\n  public nextSibling: Option<Simple.Node>;\n  public dom: DOMTreeConstruction;\n  public updateOperations: DOMChanges;\n  public constructing: Option<Simple.Element> = null;\n  public operations: Option<ElementOperations> = null;\n  public element: Simple.Element;\n  public env: Environment;\n\n  private elementStack = new Stack<Simple.Element>();\n  private nextSiblingStack = new Stack<Option<Simple.Node>>();\n  private blockStack = new Stack<Tracker>();\n\n  private defaultOperations: ElementOperations;\n\n  static forInitialRender(env: Environment, parentNode: Simple.Element, nextSibling: Option<Simple.Node>) {\n    return new ElementStack(env, parentNode, nextSibling);\n  }\n\n  static resume(env: Environment, tracker: Tracker, nextSibling: Option<Simple.Node>) {\n    let parentNode = tracker.parentElement();\n\n    let stack = new ElementStack(env, parentNode, nextSibling);\n    stack.pushBlockTracker(tracker);\n\n    return stack;\n  }\n\n  constructor(env: Environment, parentNode: Simple.Element, nextSibling: Option<Simple.Node>) {\n    this.env = env;\n    this.dom = env.getAppendOperations();\n    this.updateOperations = env.getDOM();\n    this.element = parentNode;\n    this.nextSibling = nextSibling;\n\n    this.defaultOperations = new SimpleElementOperations(env);\n\n    this.pushSimpleBlock();\n    this.elementStack.push(this.element);\n    this.nextSiblingStack.push(this.nextSibling);\n  }\n\n  expectConstructing(method: string): Simple.Element {\n    return this.constructing;\n  }\n\n  expectOperations(method: string): ElementOperations {\n    return this.operations;\n  }\n\n  block(): Tracker {\n    return this.blockStack.current;\n  }\n\n  popElement() {\n    let { elementStack, nextSiblingStack }  = this;\n\n    let topElement = elementStack.pop();\n    nextSiblingStack.pop();\n    // LOGGER.debug(`-> element stack ${this.elementStack.toArray().map(e => e.tagName).join(', ')}`);\n\n    this.element = elementStack.current;\n    this.nextSibling = nextSiblingStack.current;\n\n    return topElement;\n  }\n\n  pushSimpleBlock(): Tracker {\n    let tracker = new SimpleBlockTracker(this.element);\n    this.pushBlockTracker(tracker);\n    return tracker;\n  }\n\n  pushUpdatableBlock(): UpdatableTracker {\n    let tracker = new UpdatableBlockTracker(this.element);\n    this.pushBlockTracker(tracker);\n    return tracker;\n  }\n\n  private pushBlockTracker(tracker: Tracker, isRemote = false) {\n    let current = this.blockStack.current;\n\n    if (current !== null) {\n      current.newDestroyable(tracker);\n\n      if (!isRemote) {\n        current.newBounds(tracker);\n      }\n    }\n\n    this.blockStack.push(tracker);\n    return tracker;\n  }\n\n  pushBlockList(list: LinkedList<LinkedListNode & Bounds & Destroyable>): Tracker {\n    let tracker = new BlockListTracker(this.element, list);\n    let current = this.blockStack.current;\n\n    if (current !== null) {\n      current.newDestroyable(tracker);\n      current.newBounds(tracker);\n    }\n\n    this.blockStack.push(tracker);\n    return tracker;\n  }\n\n  popBlock(): Tracker {\n    this.block().finalize(this);\n\n    return this.blockStack.pop();\n  }\n\n  openElement(tag: string, operations = this.defaultOperations): Simple.Element {\n    let element = this.dom.createElement(tag, this.element);\n\n    this.constructing = element;\n    this.operations = operations;\n\n    return element;\n  }\n\n  flushElement() {\n    let parent  = this.element;\n    let element = this.constructing;\n\n    this.dom.insertBefore(parent, element, this.nextSibling);\n\n    this.constructing = null;\n    this.operations = null;\n\n    this.pushElement(element);\n    this.block().openElement(element);\n  }\n\n  pushRemoteElement(element: Simple.Element, nextSibling: Option<Simple.Node> = null) {\n    this.pushElement(element, nextSibling);\n\n    let tracker = new RemoteBlockTracker(element);\n    this.pushBlockTracker(tracker, true);\n  }\n\n  popRemoteElement() {\n    this.popBlock();\n    this.popElement();\n  }\n\n  private pushElement(element: Simple.Element, nextSibling: Option<Simple.Node> = null) {\n    this.element = element;\n    this.elementStack.push(element);\n    // LOGGER.debug(`-> element stack ${this.elementStack.toArray().map(e => e.tagName).join(', ')}`);\n\n    this.nextSibling = nextSibling;\n    this.nextSiblingStack.push(nextSibling);\n  }\n\n  newDestroyable(d: Destroyable) {\n    this.block().newDestroyable(d);\n  }\n\n  newBounds(bounds: Bounds) {\n    this.block().newBounds(bounds);\n  }\n\n  appendText(string: string): Simple.Text {\n    let { dom } = this;\n    let text = dom.createTextNode(string);\n    dom.insertBefore(this.element, text, this.nextSibling);\n    this.block().newNode(text);\n    return text;\n  }\n\n  appendComment(string: string): Simple.Comment {\n    let { dom } = this;\n    let comment = dom.createComment(string);\n    dom.insertBefore(this.element, comment, this.nextSibling);\n    this.block().newNode(comment);\n    return comment;\n  }\n\n  setStaticAttribute(name: string, value: string) {\n    this.expectOperations('setStaticAttribute').addStaticAttribute(this.expectConstructing('setStaticAttribute'), name, value);\n  }\n\n  setStaticAttributeNS(namespace: string, name: string, value: string) {\n    this.expectOperations('setStaticAttributeNS').addStaticAttributeNS(this.expectConstructing('setStaticAttributeNS'), namespace, name, value);\n  }\n\n  setDynamicAttribute(name: string, reference: VersionedReference<string>, isTrusting: boolean) {\n    this.expectOperations('setDynamicAttribute').addDynamicAttribute(this.expectConstructing('setDynamicAttribute'), name, reference, isTrusting);\n  }\n\n  setDynamicAttributeNS(namespace: string, name: string, reference: VersionedReference<string>, isTrusting: boolean) {\n    this.expectOperations('setDynamicAttributeNS').addDynamicAttributeNS(this.expectConstructing('setDynamicAttributeNS'), namespace, name, reference, isTrusting);\n  }\n\n  closeElement() {\n    this.block().closeElement();\n    this.popElement();\n  }\n}\n\nexport interface Tracker extends DestroyableBounds {\n  openElement(element: Simple.Element): void;\n  closeElement(): void;\n  newNode(node: Simple.Node): void;\n  newBounds(bounds: Bounds): void;\n  newDestroyable(d: Destroyable): void;\n  finalize(stack: ElementStack): void;\n}\n\nexport class SimpleBlockTracker implements Tracker {\n  protected first: Option<FirstNode> = null;\n  protected last: Option<LastNode> = null;\n  protected destroyables: Option<Destroyable[]> = null;\n  protected nesting = 0;\n\n  constructor(private parent: Simple.Element){}\n\n  destroy() {\n    let { destroyables } = this;\n\n    if (destroyables && destroyables.length) {\n      for (let i=0; i<destroyables.length; i++) {\n        destroyables[i].destroy();\n      }\n    }\n  }\n\n  parentElement() {\n    return this.parent;\n  }\n\n  firstNode(): Option<Simple.Node> {\n    return this.first && this.first.firstNode();\n  }\n\n  lastNode(): Option<Simple.Node> {\n    return this.last && this.last.lastNode();\n  }\n\n  openElement(element: Element) {\n    this.newNode(element);\n    this.nesting++;\n  }\n\n  closeElement() {\n    this.nesting--;\n  }\n\n  newNode(node: Node) {\n    if (this.nesting !== 0) return;\n\n    if (!this.first) {\n      this.first = new First(node);\n    }\n\n    this.last = new Last(node);\n  }\n\n  newBounds(bounds: Bounds) {\n    if (this.nesting !== 0) return;\n\n    if (!this.first) {\n      this.first = bounds;\n    }\n\n    this.last = bounds;\n  }\n\n  newDestroyable(d: Destroyable) {\n    this.destroyables = this.destroyables || [];\n    this.destroyables.push(d);\n  }\n\n  finalize(stack: ElementStack) {\n    if (!this.first) {\n      stack.appendComment('');\n    }\n  }\n}\n\nclass RemoteBlockTracker extends SimpleBlockTracker {\n  destroy() {\n    super.destroy();\n\n    clear(this);\n  }\n}\n\nexport interface UpdatableTracker extends Tracker {\n  reset(env: Environment): Option<Simple.Node>;\n}\n\nexport class UpdatableBlockTracker extends SimpleBlockTracker implements UpdatableTracker {\n  reset(env: Environment): Option<Simple.Node> {\n    let { destroyables } = this;\n\n    if (destroyables && destroyables.length) {\n      for (let i=0; i<destroyables.length; i++) {\n        env.didDestroy(destroyables[i]);\n      }\n    }\n\n    let nextSibling = clear(this);\n\n    this.first = null;\n    this.last = null;\n    this.destroyables = null;\n    this.nesting = 0;\n\n    return nextSibling;\n  }\n}\n\nclass BlockListTracker implements Tracker {\n  constructor(private parent: Simple.Element, private boundList: LinkedList<LinkedListNode & Bounds & Destroyable>) {\n    this.parent = parent;\n    this.boundList = boundList;\n  }\n\n  destroy() {\n    this.boundList.forEachNode(node => node.destroy());\n  }\n\n  parentElement() {\n    return this.parent;\n  }\n\n  firstNode(): Option<Simple.Node> {\n    let head = this.boundList.head();\n    return head && head.firstNode();\n  }\n\n  lastNode(): Option<Simple.Node> {\n    let tail = this.boundList.tail();\n    return tail && tail.lastNode();\n  }\n\n  openElement(_element: Element) {\n  }\n\n  closeElement() {\n  }\n\n  newNode(_node: Node) {\n  }\n\n  newBounds(_bounds: Bounds) {\n  }\n\n  newDestroyable(_d: Destroyable) {\n  }\n\n  finalize(_stack: ElementStack) {\n  }\n}\n","import Upsert, {\n  Insertion,\n  CautiousInsertion,\n  TrustingInsertion,\n\n  isSafeString,\n  isNode,\n  isString,\n\n  cautiousInsert,\n  trustingInsert\n} from '../../upsert';\nimport { isComponentDefinition } from '../../component/interfaces';\nimport { DOMTreeConstruction } from '../../dom/helper';\nimport { OpcodeJSON, UpdatingOpcode } from '../../opcodes';\nimport { VM, UpdatingVM } from '../../vm';\nimport { TryOpcode } from '../../vm/update';\nimport { Reference, VersionedPathReference, ReferenceCache, UpdatableTag, TagWrapper, isModified, isConst, map } from '@glimmer/reference';\nimport { Option, Opaque } from '@glimmer/util';\nimport { Cursor, clear } from '../../bounds';\nimport { Fragment } from '../../builder';\nimport { ConditionalReference } from '../../references';\nimport { Environment } from '../../environment';\nimport { APPEND_OPCODES, Op } from '../../opcodes';\n\nAPPEND_OPCODES.add(Op.DynamicContent, (vm, { op1: append }) => {\n  let opcode = vm.constants.getOther(append) as AppendDynamicOpcode<Insertion>;\n  opcode.evaluate(vm);\n});\n\nfunction isEmpty(value: Opaque): boolean {\n  return value === null || value === undefined || typeof value['toString'] !== 'function';\n}\n\nexport function normalizeTextValue(value: Opaque): string {\n  if (isEmpty(value)) {\n    return '';\n  }\n  return String(value);\n}\n\nfunction normalizeTrustedValue(value: Opaque): TrustingInsertion {\n  if (isEmpty(value)) {\n    return '';\n  }\n  if (isString(value)) {\n    return value;\n  }\n  if (isSafeString(value)) {\n    return value.toHTML();\n  }\n  if (isNode(value)) {\n    return value;\n  }\n  return String(value);\n}\n\nfunction normalizeValue(value: Opaque): CautiousInsertion {\n  if (isEmpty(value)) {\n    return '';\n  }\n  if (isString(value)) {\n    return value;\n  }\n  if (isSafeString(value) || isNode(value)) {\n    return value;\n  }\n  return String(value);\n}\n\nexport type AppendDynamicOpcodeConstructor =  typeof OptimizedCautiousAppendOpcode | typeof OptimizedTrustingAppendOpcode;\n\nexport abstract class AppendDynamicOpcode<T extends Insertion> {\n  protected abstract normalize(reference: Reference<Opaque>): Reference<T>;\n  protected abstract insert(dom: DOMTreeConstruction, cursor: Cursor, value: T): Upsert;\n  protected abstract updateWith(vm: VM, reference: Reference<Opaque>, cache: ReferenceCache<T>, bounds: Fragment, upsert: Upsert): UpdatingOpcode;\n\n  evaluate(vm: VM) {\n    let reference = vm.stack.pop<VersionedPathReference<Opaque>>();\n    let normalized = this.normalize(reference);\n\n    let value, cache;\n\n    if (isConst(reference)) {\n      value = normalized.value();\n    } else {\n      cache = new ReferenceCache(normalized);\n      value = cache.peek();\n    }\n\n    let stack = vm.elements();\n    let upsert = this.insert(vm.env.getAppendOperations(), stack, value);\n    let bounds = new Fragment(upsert.bounds);\n\n    stack.newBounds(bounds);\n\n    if (cache /* i.e. !isConst(reference) */) {\n      vm.updateWith(this.updateWith(vm, reference, cache, bounds, upsert));\n    }\n  }\n}\n\nexport abstract class GuardedAppendOpcode<T extends Insertion> extends AppendDynamicOpcode<T> {\n  protected abstract AppendOpcode: typeof OptimizedCautiousAppendOpcode | typeof OptimizedTrustingAppendOpcode;\n  private start = -1;\n\n  constructor() {\n    super();\n  }\n\n  get deopted(): boolean {\n    return this.start === -1;\n  }\n\n  evaluate(vm: VM) {\n    if (this.deopted) {\n      vm.goto(this.start);\n    } else {\n      let value = vm.stack.pop();\n\n      if(isComponentDefinition(value)) {\n        this.deopt(vm.env);\n        vm.goto(this.start);\n      } else {\n        vm.stack.push(value);\n        super.evaluate(vm);\n      }\n    }\n  }\n\n  public deopt(_env: Environment): number { // Public because it's used in the lazy deopt\n    // At compile time, we determined that this append callsite might refer\n    // to a local variable/property lookup that resolves to a component\n    // definition at runtime.\n    //\n    // We could have eagerly compiled this callsite into something like this:\n    //\n    //   {{#if (is-component-definition foo)}}\n    //     {{component foo}}\n    //   {{else}}\n    //     {{foo}}\n    //   {{/if}}\n    //\n    // However, in practice, there might be a large amout of these callsites\n    // and most of them would resolve to a simple value lookup. Therefore, we\n    // tried to be optimistic and assumed that the callsite will resolve to\n    // appending a simple value.\n    //\n    // However, we have reached here because at runtime, the guard conditional\n    // have detected that this callsite is indeed referring to a component\n    // definition object. Since this is likely going to be true for other\n    // instances of the same callsite, it is now appropiate to deopt into the\n    // expanded version that handles both cases. The compilation would look\n    // like this:\n    //\n    //               PutValue(expression)\n    //               Test(is-component-definition)\n    //               Enter(BEGIN, END)\n    //   BEGIN:      Noop\n    //               JumpUnless(VALUE)\n    //               PutDynamicComponentDefinitionOpcode\n    //               OpenComponent\n    //               CloseComponent\n    //               Jump(END)\n    //   VALUE:      Noop\n    //               OptimizedAppend\n    //   END:        Noop\n    //               Exit\n    //\n    // Keep in mind that even if we *don't* reach here at initial render time,\n    // it is still possible (although quite rare) that the simple value we\n    // encounter during initial render could later change into a component\n    // definition object at update time. That is handled by the \"lazy deopt\"\n    // code on the update side (scroll down for the next big block of comment).\n\n    return null as any;\n  }\n}\n\nclass IsComponentDefinitionReference extends ConditionalReference {\n  static create(inner: Reference<Opaque>): IsComponentDefinitionReference {\n    return new IsComponentDefinitionReference(inner);\n  }\n\n  toBool(value: Opaque): boolean {\n    return isComponentDefinition(value);\n  }\n}\n\nabstract class UpdateOpcode<T extends Insertion> extends UpdatingOpcode {\n  constructor(\n    protected cache: ReferenceCache<T>,\n    protected bounds: Fragment,\n    protected upsert: Upsert\n  ) {\n    super();\n    this.tag = cache.tag;\n  }\n\n  protected abstract insert(dom: DOMTreeConstruction, cursor: Cursor, value: T): Upsert;\n\n  evaluate(vm: UpdatingVM) {\n    let value = this.cache.revalidate();\n\n    if (isModified(value)) {\n      let { bounds, upsert } = this;\n      let { dom } = vm;\n\n      if(!this.upsert.update(dom, value)) {\n        let cursor = new Cursor(bounds.parentElement(), clear(bounds));\n        upsert = this.upsert = this.insert(vm.env.getAppendOperations(), cursor, value as T);\n      }\n\n      bounds.update(upsert.bounds);\n    }\n  }\n}\n\nabstract class GuardedUpdateOpcode<T extends Insertion> extends UpdateOpcode<T> {\n  private _tag: TagWrapper<UpdatableTag>;\n  private deopted: Option<TryOpcode> = null;\n\n  constructor(\n    private reference: Reference<Opaque>,\n    cache: ReferenceCache<T>,\n    bounds: Fragment,\n    upsert: Upsert\n  ) {\n    super(cache, bounds, upsert);\n    this.tag = this._tag = UpdatableTag.create(this.tag);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    if (this.deopted) {\n      vm.evaluateOpcode(this.deopted);\n    } else {\n      if (isComponentDefinition(this.reference.value())) {\n        this.lazyDeopt(vm);\n      } else {\n        super.evaluate(vm);\n      }\n    }\n  }\n\n  private lazyDeopt(_vm: UpdatingVM) {\n    // Durign initial render, we know that the reference does not contain a\n    // component definition, so we optimistically assumed that this append\n    // is just a normal append. However, at update time, we discovered that\n    // the reference has switched into containing a component definition, so\n    // we need to do a \"lazy deopt\", simulating what would have happened if\n    // we had decided to perform the deopt in the first place during initial\n    // render.\n    //\n    // More concretely, we would have expanded the curly into a if/else, and\n    // based on whether the value is a component definition or not, we would\n    // have entered either the dynamic component branch or the simple value\n    // branch.\n    //\n    // Since we rendered a simple value during initial render (and all the\n    // updates up until this point), we need to pretend that the result is\n    // produced by the \"VALUE\" branch of the deopted append opcode:\n    //\n    //   Try(BEGIN, END)\n    //     Assert(IsComponentDefinition, expected=false)\n    //     OptimizedUpdate\n    //\n    // In this case, because the reference has switched from being a simple\n    // value into a component definition, what would have happened is that\n    // the assert would throw, causing the Try opcode to teardown the bounds\n    // and rerun the original append opcode.\n    //\n    // Since the Try opcode would have nuked the updating opcodes anyway, we\n    // wouldn't have to worry about simulating those. All we have to do is to\n    // execute the Try opcode and immediately throw.\n\n    return null as any;\n  }\n}\n\nexport class OptimizedCautiousAppendOpcode extends AppendDynamicOpcode<CautiousInsertion> {\n  type = 'optimized-cautious-append';\n\n  protected normalize(reference: Reference<Opaque>): Reference<CautiousInsertion> {\n    return map(reference, normalizeValue);\n  }\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: CautiousInsertion): Upsert {\n    return cautiousInsert(dom, cursor, value);\n  }\n\n  protected updateWith(_vm: VM, _reference: Reference<Opaque>, cache: ReferenceCache<CautiousInsertion>, bounds: Fragment, upsert: Upsert): UpdatingOpcode {\n    return new OptimizedCautiousUpdateOpcode(cache, bounds, upsert);\n  }\n}\n\nclass OptimizedCautiousUpdateOpcode extends UpdateOpcode<CautiousInsertion> {\n  type = 'optimized-cautious-update';\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: CautiousInsertion): Upsert {\n    return cautiousInsert(dom, cursor, value);\n  }\n}\n\nexport class GuardedCautiousAppendOpcode extends GuardedAppendOpcode<CautiousInsertion> {\n  type = 'guarded-cautious-append';\n\n  protected AppendOpcode = OptimizedCautiousAppendOpcode;\n\n  protected normalize(reference: Reference<Opaque>): Reference<CautiousInsertion> {\n    return map(reference, normalizeValue);\n  }\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: CautiousInsertion): Upsert {\n    return cautiousInsert(dom, cursor, value);\n  }\n\n  protected updateWith(_vm: VM, reference: Reference<Opaque>, cache: ReferenceCache<CautiousInsertion>, bounds: Fragment, upsert: Upsert): UpdatingOpcode {\n    return new GuardedCautiousUpdateOpcode(reference, cache, bounds, upsert);\n  }\n}\n\nclass GuardedCautiousUpdateOpcode extends GuardedUpdateOpcode<CautiousInsertion> {\n  type = 'guarded-cautious-update';\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: CautiousInsertion): Upsert {\n    return cautiousInsert(dom, cursor, value);\n  }\n}\n\nexport class OptimizedTrustingAppendOpcode extends AppendDynamicOpcode<TrustingInsertion> {\n  type = 'optimized-trusting-append';\n\n  protected normalize(reference: Reference<Opaque>): Reference<TrustingInsertion> {\n    return map(reference, normalizeTrustedValue);\n  }\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: TrustingInsertion): Upsert {\n    return trustingInsert(dom, cursor, value);\n  }\n\n  protected updateWith(_vm: VM, _reference: Reference<Opaque>, cache: ReferenceCache<TrustingInsertion>, bounds: Fragment, upsert: Upsert): UpdatingOpcode {\n    return new OptimizedTrustingUpdateOpcode(cache, bounds, upsert);\n  }\n}\n\nclass OptimizedTrustingUpdateOpcode extends UpdateOpcode<TrustingInsertion> {\n  type = 'optimized-trusting-update';\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: TrustingInsertion): Upsert {\n    return trustingInsert(dom, cursor, value);\n  }\n}\n\nexport class GuardedTrustingAppendOpcode extends GuardedAppendOpcode<TrustingInsertion> {\n  type = 'guarded-trusting-append';\n\n  protected AppendOpcode = OptimizedTrustingAppendOpcode;\n\n  protected normalize(reference: Reference<Opaque>): Reference<TrustingInsertion> {\n    return map(reference, normalizeTrustedValue);\n  }\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: TrustingInsertion): Upsert {\n    return trustingInsert(dom, cursor, value);\n  }\n\n  protected updateWith(_vm: VM, reference: Reference<Opaque>, cache: ReferenceCache<TrustingInsertion>, bounds: Fragment, upsert: Upsert): UpdatingOpcode {\n    return new GuardedTrustingUpdateOpcode(reference, cache, bounds, upsert);\n  }\n}\n\nclass GuardedTrustingUpdateOpcode extends GuardedUpdateOpcode<TrustingInsertion> {\n  type = 'trusting-update';\n\n  protected insert(dom: DOMTreeConstruction, cursor: Cursor, value: TrustingInsertion): Upsert {\n    return trustingInsert(dom, cursor, value);\n  }\n}\n","import { Scope } from '../../environment';\nimport { VersionedPathReference } from '@glimmer/reference';\nimport { APPEND_OPCODES, Op } from '../../opcodes';\nimport { Opaque } from '@glimmer/interfaces';\nimport { dict } from '@glimmer/util';\n\nexport type DebugGet = ((path: string) => Opaque);\n\nexport type DebugCallback = ((context: Opaque, get: DebugGet) => void);\n\n/* tslint:disable */\nfunction debugCallback(context: Opaque, get: DebugGet): void {\n  console.info('Use `context`, and `get(<path>)` to debug this template.');\n\n  // for example...\n  context === get('this');\n\n  debugger;\n}\n/* tslint:enable */\n\nlet callback = debugCallback;\n\n// For testing purposes\nexport function setDebuggerCallback(cb: DebugCallback) {\n  callback = cb;\n}\n\nexport function resetDebuggerCallback() {\n  callback = debugCallback;\n}\n\nclass ScopeInspector {\n  private locals = dict<VersionedPathReference<Opaque>>();\n\n  constructor(private scope: Scope, symbols: string[], evalInfo: number[]) {\n    evalInfo.forEach(slot => {\n      let name = symbols[slot - 1];\n      let ref  = scope.getSymbol(slot);\n      this.locals[name] = ref;\n    });\n  }\n\n  get(path: string): VersionedPathReference<Opaque> {\n    let { scope, locals } = this;\n    let parts = path.split('.');\n    let [head, ...tail] = path.split('.');\n\n    let evalScope = scope.getEvalScope()!;\n    let ref: VersionedPathReference<Opaque>;\n\n    if (head === 'this') {\n      ref = scope.getSelf();\n    } else if (locals[head]) {\n      ref = locals[head];\n    } else if (head.indexOf('@') === 0 && evalScope[head]) {\n      ref = evalScope[head] as VersionedPathReference<Opaque>;\n    } else {\n      ref = this.scope.getSelf();\n      tail = parts;\n    }\n\n    return tail.reduce((ref, part) => ref.get(part), ref);\n  }\n}\n\nAPPEND_OPCODES.add(Op.Debugger, (vm, { op1: _symbols, op2: _evalInfo }) => {\n  let symbols = vm.constants.getOther<string[]>(_symbols);\n  let evalInfo = vm.constants.getArray(_evalInfo);\n  let inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);\n  callback(vm.getSelf().value(), path => inspector.get(path).value());\n});\n","import { TemplateMeta } from '@glimmer/wire-format';\nimport { VersionedPathReference } from '@glimmer/reference';\nimport { APPEND_OPCODES, Op } from '../../opcodes';\nimport { PartialDefinition } from '../../partial';\n\nAPPEND_OPCODES.add(Op.GetPartialTemplate, vm => {\n  let stack = vm.stack;\n  let definition = stack.pop<VersionedPathReference<PartialDefinition<TemplateMeta>>>();\n  stack.push(definition.value().template.asPartial());\n});\n","import { Opaque } from '@glimmer/util';\nimport { Tag, Reference, ReferenceIterator, IterationArtifacts, VersionedPathReference } from '@glimmer/reference';\nimport { APPEND_OPCODES, Op } from '../../opcodes';\n\nclass IterablePresenceReference implements Reference<boolean> {\n  public tag: Tag;\n  private artifacts: IterationArtifacts;\n\n  constructor(artifacts: IterationArtifacts) {\n    this.tag = artifacts.tag;\n    this.artifacts = artifacts;\n  }\n\n  value(): boolean {\n    return !this.artifacts.isEmpty();\n  }\n}\n\nAPPEND_OPCODES.add(Op.PutIterator, vm => {\n  let stack = vm.stack;\n  let listRef = stack.pop<VersionedPathReference<Opaque>>();\n  let key = stack.pop<VersionedPathReference<string>>();\n  let iterable = vm.env.iterableFor(listRef, key.value());\n  let iterator = new ReferenceIterator(iterable);\n\n  stack.push(iterator);\n  stack.push(new IterablePresenceReference(iterator.artifacts));\n});\n\nAPPEND_OPCODES.add(Op.EnterList, (vm, { op1: start }) => {\n  vm.enterList(start);\n});\n\nAPPEND_OPCODES.add(Op.ExitList, vm => vm.exitList());\n\nAPPEND_OPCODES.add(Op.Iterate, (vm, { op1: breaks }) => {\n  let stack = vm.stack;\n  let item = stack.peek<ReferenceIterator>().next();\n\n  if (item) {\n    let tryOpcode = vm.iterate(item.memo, item.value);\n    vm.enterItem(item.key, tryOpcode);\n  } else {\n    vm.goto(breaks);\n  }\n});\n","export enum Opcodes {\n  // Statements\n  Text,\n  Append,\n  Comment,\n  Modifier,\n  Block,\n  Component,\n  OpenElement,\n  FlushElement,\n  CloseElement,\n  StaticAttr,\n  DynamicAttr,\n  Yield,\n  Partial,\n\n  DynamicArg,\n  StaticArg,\n  TrustingAttr,\n  Debugger,\n  ClientSideStatement,\n\n  // Expressions\n\n  Unknown,\n  Get,\n  MaybeLocal,\n  FixThisBeforeWeMerge,\n  HasBlock,\n  HasBlockParams,\n  Undefined,\n  Helper,\n  Concat,\n  ClientSideExpression\n}\n","import * as content from './content';\nimport * as vm from './vm';\n\nimport { Insertion } from '../../upsert';\nimport { Register } from '../../opcodes';\nimport * as WireFormat from '@glimmer/wire-format';\nimport { Option, Stack, Opaque, dict, fillNulls, EMPTY_ARRAY } from '@glimmer/util';\nimport {\n  Constants,\n  ConstantString,\n  ConstantArray,\n  ConstantOther,\n  ConstantBlock,\n  ConstantFunction,\n} from '../../environment/constants';\nimport { ModifierManager } from '../../modifier/interfaces';\nimport { ComponentDefinition } from '../../component/interfaces';\nimport Environment, { Program } from '../../environment';\nimport { SymbolTable, CompilationMeta } from '@glimmer/interfaces';\nimport { ComponentBuilder as IComponentBuilder } from '../../opcode-builder';\nimport { ComponentBuilder } from '../../compiler';\nimport { RawInlineBlock, ClientSide, Block } from '../../scanner';\nimport { InvokeDynamicLayout, expr } from '../../syntax/functions';\n\nimport { Op } from '../../opcodes';\n\nexport interface CompilesInto<E> {\n  compile(builder: OpcodeBuilder): E;\n}\n\nexport type Represents<E> = CompilesInto<E> | E;\n\nexport type Label = string;\n\ntype TargetOpcode = Op.Jump | Op.JumpIf | Op.JumpUnless | Op.EnterList | Op.Iterate | Op.Immediate;\n\nclass Labels {\n  labels = dict<number>();\n  targets: { at: number, Target: TargetOpcode, target: string }[] = [];\n\n  label(name: string, index: number) {\n    this.labels[name] = index;\n  }\n\n  target(at: number, Target: TargetOpcode, target: string) {\n    this.targets.push({ at, Target, target });\n  }\n\n  patch(opcodes: Program): void {\n    for (let { at, Target, target } of this.targets) {\n      opcodes.set(at, Target, this.labels[target]);\n    }\n  }\n}\n\nexport abstract class BasicOpcodeBuilder {\n  private labelsStack = new Stack<Labels>();\n  public constants: Constants;\n  public start: number;\n\n  constructor(public env: Environment, public meta: CompilationMeta, public program: Program) {\n    this.constants = env.constants;\n    this.start = program.next;\n  }\n\n  abstract compile<E>(expr: Represents<E>): E;\n\n  private get pos() {\n    return this.program.current;\n  }\n\n  private get nextPos() {\n    return this.program.next;\n  }\n\n  upvars<T extends [Opaque]>(count: number): T {\n    return fillNulls(count) as T;\n  }\n\n  reserve(name: Op) {\n    this.push(name, 0, 0, 0);\n  }\n\n  push(name: Op, op1 = 0, op2 = 0, op3 = 0) {\n    return this.program.push(name, op1, op2, op3);\n  }\n\n  finalize(): number {\n    return this.push(Op.Return);\n  }\n\n  // args\n\n  pushArgs(positional: number, synthetic: boolean) {\n    this.push(Op.PushArgs, positional, (synthetic as any)|0);\n  }\n\n  // helpers\n\n  private get labels(): Labels {\n    return this.labelsStack.current;\n  }\n\n  startLabels() {\n    this.labelsStack.push(new Labels());\n  }\n\n  stopLabels() {\n    let label = this.labelsStack.pop();\n    label.patch(this.program);\n  }\n\n  // components\n\n  pushComponentManager(definition: ComponentDefinition<Opaque>) {\n    this.push(Op.PushComponentManager, this.other(definition));\n  }\n\n  pushDynamicComponentManager() {\n    this.push(Op.PushDynamicComponentManager);\n  }\n\n  initializeComponentState() {\n    this.push(Op.InitializeComponentState);\n  }\n\n  prepareArgs(state: Register) {\n    this.push(Op.PrepareArgs, state);\n  }\n\n  createComponent(state: Register, hasDefault: boolean, hasInverse: boolean) {\n    let flag = (<any>hasDefault|0) | ((<any>hasInverse|0) << 1);\n    this.push(Op.CreateComponent, flag, state);\n  }\n\n  registerComponentDestructor(state: Register) {\n    this.push(Op.RegisterComponentDestructor, state);\n  }\n\n  beginComponentTransaction() {\n    this.push(Op.BeginComponentTransaction);\n  }\n\n  commitComponentTransaction() {\n    this.push(Op.CommitComponentTransaction);\n  }\n\n  pushComponentOperations() {\n    this.push(Op.PushComponentOperations);\n  }\n\n  getComponentSelf(state: Register) {\n    this.push(Op.GetComponentSelf, state);\n  }\n\n  getComponentLayout(state: Register ) {\n    this.push(Op.GetComponentLayout, state);\n  }\n\n  didCreateElement(state: Register) {\n    this.push(Op.DidCreateElement, state);\n  }\n\n  didRenderLayout(state: Register) {\n    this.push(Op.DidRenderLayout, state);\n  }\n\n  // partial\n\n  getPartialTemplate() {\n    this.push(Op.GetPartialTemplate);\n  }\n\n  resolveMaybeLocal(name: string) {\n    this.push(Op.ResolveMaybeLocal, this.string(name));\n  }\n\n  // debugger\n\n  debugger(symbols: string[], evalInfo: number[]) {\n    this.push(Op.Debugger, this.constants.other(symbols), this.constants.array(evalInfo));\n  }\n\n  // content\n\n  dynamicContent(Opcode: content.AppendDynamicOpcode<Insertion>) {\n    this.push(Op.DynamicContent, this.other(Opcode));\n  }\n\n  cautiousAppend() {\n    this.dynamicContent(new content.OptimizedCautiousAppendOpcode());\n  }\n\n  trustingAppend() {\n    this.dynamicContent(new content.OptimizedTrustingAppendOpcode());\n  }\n\n  // dom\n\n  text(text: string) {\n    this.push(Op.Text, this.constants.string(text));\n  }\n\n  openPrimitiveElement(tag: string) {\n    this.push(Op.OpenElement, this.constants.string(tag));\n  }\n\n  openElementWithOperations(tag: string) {\n    this.push(Op.OpenElementWithOperations, this.constants.string(tag));\n  }\n\n  openDynamicElement() {\n    this.push(Op.OpenDynamicElement);\n  }\n\n  flushElement() {\n    this.push(Op.FlushElement);\n  }\n\n  closeElement() {\n    this.push(Op.CloseElement);\n  }\n\n  staticAttr(_name: string, _namespace: Option<string>, _value: string) {\n    let name = this.constants.string(_name);\n    let namespace = _namespace ? this.constants.string(_namespace) : 0;\n    let value = this.constants.string(_value);\n\n    this.push(Op.StaticAttr, name, value, namespace);\n  }\n\n  dynamicAttrNS(_name: string, _namespace: string, trusting: boolean) {\n    let name = this.constants.string(_name);\n    let namespace = this.constants.string(_namespace);\n\n    this.push(Op.DynamicAttrNS, name, namespace, (trusting as any)|0);\n  }\n\n  dynamicAttr(_name: string, trusting: boolean) {\n    let name = this.constants.string(_name);\n    this.push(Op.DynamicAttr, name, (trusting as any)|0);\n  }\n\n  comment(_comment: string) {\n    let comment = this.constants.string(_comment);\n    this.push(Op.Comment, comment);\n  }\n\n  modifier(_definition: ModifierManager<Opaque>) {\n    this.push(Op.Modifier, this.other(_definition));\n  }\n\n  // lists\n\n  putIterator() {\n    this.push(Op.PutIterator);\n  }\n\n  enterList(start: string) {\n    this.reserve(Op.EnterList);\n    this.labels.target(this.pos, Op.EnterList, start);\n  }\n\n  exitList() {\n    this.push(Op.ExitList);\n  }\n\n  iterate(breaks: string) {\n    this.reserve(Op.Iterate);\n    this.labels.target(this.pos, Op.Iterate, breaks);\n  }\n\n  // expressions\n\n  setVariable(symbol: number) {\n    this.push(Op.SetVariable, symbol);\n  }\n\n  getVariable(symbol: number) {\n    this.push(Op.GetVariable, symbol);\n  }\n\n  getProperty(key: string) {\n    this.push(Op.GetProperty, this.string(key));\n  }\n\n  getBlock(symbol: number) {\n    this.push(Op.GetBlock, symbol);\n  }\n\n  hasBlock(symbol: number) {\n    this.push(Op.HasBlock, symbol);\n  }\n\n  hasBlockParams(symbol: number) {\n    this.push(Op.HasBlockParams, symbol);\n  }\n\n  concat(size: number) {\n    this.push(Op.Concat, size);\n  }\n\n  function(f: ClientSide.FunctionExpressionCallback<Opaque>) {\n    this.push(Op.Function, this.func(f));\n  }\n\n  load(register: Register) {\n    this.push(Op.Load, register);\n  }\n\n  fetch(register: Register) {\n    this.push(Op.Fetch, register);\n  }\n\n  dup(register = Register.sp, offset = 0) {\n    return this.push(Op.Dup, register, offset);\n  }\n\n  pop(count = 1) {\n    return this.push(Op.Pop, count);\n  }\n\n  // vm\n\n  pushRemoteElement() {\n    this.push(Op.PushRemoteElement);\n  }\n\n  popRemoteElement() {\n    this.push(Op.PopRemoteElement);\n  }\n\n  label(name: string) {\n    this.labels.label(name, this.nextPos);\n  }\n\n  pushRootScope(symbols: number, bindCallerScope: boolean) {\n    this.push(Op.RootScope, symbols, <any>bindCallerScope|0);\n  }\n\n  pushChildScope() {\n    this.push(Op.ChildScope);\n  }\n\n  popScope() {\n    this.push(Op.PopScope);\n  }\n\n  returnTo(label: string) {\n    this.reserve(Op.Immediate);\n    this.labels.target(this.pos, Op.Immediate, label);\n    this.load(Register.ra);\n  }\n\n  pushDynamicScope() {\n    this.push(Op.PushDynamicScope);\n  }\n\n  popDynamicScope() {\n    this.push(Op.PopDynamicScope);\n  }\n\n  pushImmediate<T>(value: T) {\n    this.push(Op.Constant, this.other(value));\n  }\n\n  primitive(_primitive: string | number | null | undefined | boolean) {\n    let flag: 0 | 1 | 2 = 0;\n    let primitive: number;\n    switch (typeof _primitive) {\n      case 'number':\n        primitive = _primitive as number;\n        break;\n      case 'string':\n        primitive = this.string(_primitive as string);\n        flag = 1;\n        break;\n      case 'boolean':\n        primitive = (_primitive as any) | 0;\n        flag = 2;\n        break;\n      case 'object':\n        // assume null\n        primitive = 2;\n        flag = 2;\n        break;\n      case 'undefined':\n        primitive = 3;\n        flag = 2;\n        break;\n      default:\n        throw new Error('Invalid primitive passed to pushPrimitive');\n    }\n\n    this.push(Op.PrimitiveReference, (flag << 30) | primitive);\n  }\n\n  helper(func: Function) {\n    this.push(Op.Helper, this.func(func));\n  }\n\n  pushBlock(block: Option<Block>) {\n    this.push(Op.PushBlock, this.block(block));\n  }\n\n  bindDynamicScope(_names: string[]) {\n    this.push(Op.BindDynamicScope, this.names(_names));\n  }\n\n  enter(args: number) {\n    this.push(Op.Enter, args);\n  }\n\n  exit() {\n    this.push(Op.Exit);\n  }\n\n  return() {\n    this.push(Op.Return);\n  }\n\n  pushFrame() {\n    this.push(Op.PushFrame);\n  }\n\n  popFrame() {\n    this.push(Op.PopFrame);\n  }\n\n  compileDynamicBlock(): void {\n    this.push(Op.CompileDynamicBlock);\n  }\n\n  invokeDynamic(invoker: vm.DynamicInvoker<SymbolTable>): void {\n    this.push(Op.InvokeDynamic, this.other(invoker));\n  }\n\n  invokeStatic(block: Block, callerCount = 0): void {\n    let { parameters } = block.symbolTable;\n    let calleeCount = parameters.length;\n    let count = Math.min(callerCount, calleeCount);\n\n    this.pushFrame();\n\n    if (count) {\n      this.pushChildScope();\n\n      for (let i=0; i<count; i++) {\n        this.dup(Register.fp, callerCount - i);\n        this.setVariable(parameters[i]);\n      }\n    }\n\n    let _block = this.constants.block(block);\n    this.push(Op.InvokeStatic, _block);\n\n    if (count) {\n      this.popScope();\n    }\n\n    this.popFrame();\n  }\n\n  test(testFunc: 'const' | 'simple' | 'environment' | vm.TestFunction) {\n    let _func: vm.TestFunction;\n\n    if (testFunc === 'const') {\n      _func = vm.ConstTest;\n    } else if (testFunc === 'simple') {\n      _func = vm.SimpleTest;\n    } else if (testFunc === 'environment') {\n      _func = vm.EnvironmentTest;\n    } else if (typeof testFunc === 'function') {\n      _func = testFunc;\n    } else {\n      throw new Error('unreachable');\n    }\n\n    let func = this.constants.function(_func);\n    this.push(Op.Test, func);\n  }\n\n  jump(target: string) {\n    this.reserve(Op.Jump);\n    this.labels.target(this.pos, Op.Jump, target);\n  }\n\n  jumpIf(target: string) {\n    this.reserve(Op.JumpIf);\n    this.labels.target(this.pos, Op.JumpIf, target);\n  }\n\n  jumpUnless(target: string) {\n    this.reserve(Op.JumpUnless);\n    this.labels.target(this.pos, Op.JumpUnless, target);\n  }\n\n  string(_string: string): ConstantString {\n    return this.constants.string(_string);\n  }\n\n  protected names(_names: string[]): ConstantArray {\n    let names = _names.map(n => this.constants.string(n));\n    return this.constants.array(names);\n  }\n\n  protected symbols(symbols: number[]): ConstantArray {\n    return this.constants.array(symbols);\n  }\n\n  protected other(value: Opaque): ConstantOther {\n    return this.constants.other(value);\n  }\n\n  protected block(block: Option<Block>): ConstantBlock {\n    return block ? this.constants.block(block) : 0;\n  }\n\n  protected func(func: Function): ConstantFunction {\n    return this.constants.function(func);\n  }\n}\n\nfunction isCompilableExpression<E>(expr: Represents<E>): expr is CompilesInto<E> {\n  return expr && typeof expr['compile'] === 'function';\n}\n\nexport default class OpcodeBuilder extends BasicOpcodeBuilder {\n  public component: IComponentBuilder;\n\n  constructor(env: Environment, meta: CompilationMeta, program: Program = env.program) {\n    super(env, meta, program);\n    this.component = new ComponentBuilder(this);\n  }\n\n  compileArgs(params: Option<WireFormat.Core.Params>, hash: Option<WireFormat.Core.Hash>, synthetic: boolean) {\n    let positional = 0;\n\n    if (params) {\n      params.forEach(p => expr(p, this));\n      positional = params.length;\n    }\n\n    let names = EMPTY_ARRAY;\n\n    if (hash) {\n      names = hash[0];\n      hash[1].forEach(v => expr(v, this));\n    }\n\n    this.pushImmediate(names);\n    this.pushArgs(positional, synthetic);\n  }\n\n  compile<E>(expr: Represents<E>): E {\n    if (isCompilableExpression(expr)) {\n      return expr.compile(this);\n    } else {\n      return expr;\n    }\n  }\n\n  guardedCautiousAppend(expression: WireFormat.Expression) {\n    expr(expression, this);\n    this.dynamicContent(new content.GuardedCautiousAppendOpcode());\n  }\n\n  guardedTrustingAppend(expression: WireFormat.Expression) {\n    expr(expression, this);\n    this.dynamicContent(new content.GuardedTrustingAppendOpcode());\n  }\n\n  invokeComponent(attrs: Option<RawInlineBlock>, params: Option<WireFormat.Core.Params>, hash: Option<WireFormat.Core.Hash>, block: Option<Block>, inverse: Option<Block> = null) {\n    this.initializeComponentState();\n\n    this.fetch(Register.s0);\n    this.dup(Register.sp, 1);\n    this.load(Register.s0);\n\n    this.pushBlock(block);\n    this.pushBlock(inverse);\n\n    this.compileArgs(params, hash, false);\n    this.prepareArgs(Register.s0);\n\n    this.beginComponentTransaction();\n    this.pushDynamicScope();\n    this.createComponent(Register.s0, true, inverse === null);\n    this.registerComponentDestructor(Register.s0);\n\n    this.getComponentSelf(Register.s0);\n    this.getComponentLayout(Register.s0);\n    this.invokeDynamic(new InvokeDynamicLayout(attrs && attrs.scan()));\n    this.popFrame();\n\n    this.popScope();\n    this.popDynamicScope();\n    this.commitComponentTransaction();\n\n    this.load(Register.s0);\n  }\n\n  template(block: Option<WireFormat.SerializedInlineBlock>): Option<RawInlineBlock> {\n    if (!block) return null;\n    return new RawInlineBlock(this.env, this.meta, block.statements, block.parameters);\n  }\n}\n\nexport type BlockCallback = (dsl: OpcodeBuilder, BEGIN: Label, END: Label) => void;\n","import { Opaque, CompilationMeta } from '@glimmer/interfaces';\nimport Environment from './environment';\nimport { CompiledDynamicProgram, CompiledDynamicTemplate } from './compiled/blocks';\nimport { Maybe, Option } from '@glimmer/util';\nimport { Ops, TemplateMeta } from '@glimmer/wire-format';\n\nimport { Template } from './template';\nimport { Register } from './opcodes';\n\nimport { ATTRS_BLOCK, ClientSide, compileStatement } from './scanner';\n\nimport {\n  ComponentArgs,\n  ComponentBuilder as IComponentBuilder,\n  DynamicComponentDefinition\n} from './opcode-builder';\n\nimport { expr } from './syntax/functions';\n\nimport OpcodeBuilderDSL from './compiled/opcodes/builder';\n\nimport * as Component from './component/interfaces';\n\nimport * as WireFormat from '@glimmer/wire-format';\n\nimport { PublicVM } from './vm/append';\nimport { IArguments } from './vm/arguments';\nimport { FunctionExpression } from \"./compiled/opcodes/expressions\";\n\nexport interface CompilableLayout {\n  compile(builder: Component.ComponentLayoutBuilder): void;\n}\n\nexport function compileLayout(compilable: CompilableLayout, env: Environment): CompiledDynamicProgram {\n  let builder = new ComponentLayoutBuilder(env);\n\n  compilable.compile(builder);\n\n  return builder.compile();\n}\n\ninterface InnerLayoutBuilder {\n  tag: Component.ComponentTagBuilder;\n  attrs: Component.ComponentAttrsBuilder;\n  compile(): CompiledDynamicProgram;\n}\n\nclass ComponentLayoutBuilder implements Component.ComponentLayoutBuilder {\n  private inner: InnerLayoutBuilder;\n\n  constructor(public env: Environment) {}\n\n  wrapLayout(layout: Template<TemplateMeta>) {\n    this.inner = new WrappedBuilder(this.env, layout);\n  }\n\n  fromLayout(layout: Template<TemplateMeta>) {\n    this.inner = new UnwrappedBuilder(this.env, layout);\n  }\n\n  compile(): CompiledDynamicProgram {\n    return this.inner.compile();\n  }\n\n  get tag(): Component.ComponentTagBuilder {\n    return this.inner.tag;\n  }\n\n  get attrs(): Component.ComponentAttrsBuilder {\n    return this.inner.attrs;\n  }\n}\n\nclass WrappedBuilder implements InnerLayoutBuilder {\n  public tag = new ComponentTagBuilder();\n  public attrs = new ComponentAttrsBuilder();\n\n  constructor(public env: Environment, private layout: Template<TemplateMeta>) {}\n\n  compile(): CompiledDynamicProgram {\n    //========DYNAMIC\n    //        PutValue(TagExpr)\n    //        Test\n    //        JumpUnless(BODY)\n    //        OpenDynamicPrimitiveElement\n    //        DidCreateElement\n    //        ...attr statements...\n    //        FlushElement\n    // BODY:  Noop\n    //        ...body statements...\n    //        PutValue(TagExpr)\n    //        Test\n    //        JumpUnless(END)\n    //        CloseElement\n    // END:   Noop\n    //        DidRenderLayout\n    //        Exit\n    //\n    //========STATIC\n    //        OpenPrimitiveElementOpcode\n    //        DidCreateElement\n    //        ...attr statements...\n    //        FlushElement\n    //        ...body statements...\n    //        CloseElement\n    //        DidRenderLayout\n    //        Exit\n\n    let { env, layout } = this;\n    let meta = { templateMeta: layout.meta, symbols: layout.symbols, asPartial: false };\n\n    let dynamicTag = this.tag.getDynamic();\n    let staticTag = this.tag.getStatic();\n\n    let b = builder(env, meta);\n\n    b.startLabels();\n\n    if (dynamicTag) {\n      b.fetch(Register.s1);\n\n      expr(dynamicTag, b);\n\n      b.dup();\n      b.load(Register.s1);\n\n      b.test('simple');\n\n      b.jumpUnless('BODY');\n\n      b.fetch(Register.s1);\n      b.pushComponentOperations();\n      b.openDynamicElement();\n    } else if (staticTag) {\n      b.pushComponentOperations();\n      b.openElementWithOperations(staticTag);\n    }\n\n    if (dynamicTag || staticTag) {\n      b.didCreateElement(Register.s0);\n\n      let attrs = this.attrs['buffer'];\n\n      for (let i=0; i<attrs.length; i++) {\n        compileStatement(attrs[i], b);\n      }\n\n      b.flushElement();\n    }\n\n    b.label('BODY');\n    b.invokeStatic(layout.asBlock());\n\n    if (dynamicTag) {\n      b.fetch(Register.s1);\n      b.test('simple');\n      b.jumpUnless('END');\n      b.closeElement();\n    } else if (staticTag) {\n      b.closeElement();\n    }\n\n    b.label('END');\n\n    b.didRenderLayout(Register.s0);\n\n    if (dynamicTag) {\n      b.load(Register.s1);\n    }\n\n    b.stopLabels();\n\n    let start = b.start;\n    let end = b.finalize();\n\n    return new CompiledDynamicTemplate(start, end, {\n      meta,\n      hasEval: layout.hasEval,\n      symbols: layout.symbols.concat([ATTRS_BLOCK])\n    });\n  }\n}\n\nclass UnwrappedBuilder implements InnerLayoutBuilder {\n  public attrs = new ComponentAttrsBuilder();\n\n  constructor(public env: Environment, private layout: Template<TemplateMeta>) {}\n\n  get tag(): Component.ComponentTagBuilder {\n    throw new Error('BUG: Cannot call `tag` on an UnwrappedBuilder');\n  }\n\n  compile(): CompiledDynamicProgram {\n    let { env, layout } = this;\n    return layout.asLayout(this.attrs['buffer']).compileDynamic(env);\n  }\n}\n\nclass ComponentTagBuilder implements Component.ComponentTagBuilder {\n  public isDynamic: Option<boolean> = null;\n  public isStatic: Option<boolean> = null;\n  public staticTagName: Option<string> = null;\n  public dynamicTagName: Option<WireFormat.Expression> = null;\n\n  getDynamic(): Maybe<WireFormat.Expression> {\n    if (this.isDynamic) {\n      return this.dynamicTagName;\n    }\n  }\n\n  getStatic(): Maybe<string> {\n    if (this.isStatic) {\n      return this.staticTagName;\n    }\n  }\n\n  static(tagName: string) {\n    this.isStatic = true;\n    this.staticTagName = tagName;\n  }\n\n  dynamic(tagName: FunctionExpression<string>) {\n    this.isDynamic = true;\n    this.dynamicTagName = [Ops.ClientSideExpression, ClientSide.Ops.FunctionExpression, tagName];\n  }\n}\n\nclass ComponentAttrsBuilder implements Component.ComponentAttrsBuilder {\n  private buffer: WireFormat.Statements.Attribute[] = [];\n\n  static(name: string, value: string) {\n    this.buffer.push([Ops.StaticAttr, name, value, null]);\n  }\n\n  dynamic(name: string, value: FunctionExpression<string>) {\n    this.buffer.push([Ops.DynamicAttr, name, [Ops.ClientSideExpression, ClientSide.Ops.FunctionExpression, value], null]);\n  }\n}\n\nexport class ComponentBuilder implements IComponentBuilder {\n  private env: Environment;\n\n  constructor(private builder: OpcodeBuilderDSL) {\n    this.env = builder.env;\n  }\n\n  static(definition: Component.ComponentDefinition<Opaque>, args: ComponentArgs) {\n    let [params, hash, _default, inverse] = args;\n    let { builder } = this;\n\n    builder.pushComponentManager(definition);\n    builder.invokeComponent(null, params, hash, _default, inverse);\n  }\n\n  dynamic(definitionArgs: ComponentArgs, getDefinition: DynamicComponentDefinition, args: ComponentArgs) {\n    let [params, hash, block, inverse] = args;\n    let { builder } = this;\n\n    if (!definitionArgs || definitionArgs.length === 0) {\n      throw new Error(\"Dynamic syntax without an argument\");\n    }\n\n    let meta = this.builder.meta.templateMeta;\n\n    function helper(vm: PublicVM, args: IArguments) {\n      return getDefinition(vm, args, meta);\n    }\n\n    builder.startLabels();\n\n    builder.pushFrame();\n\n    builder.returnTo('END');\n\n    builder.compileArgs(definitionArgs[0], definitionArgs[1], true);\n    builder.helper(helper);\n\n    builder.dup();\n    builder.test('simple');\n\n    builder.enter(2);\n\n    builder.jumpUnless('ELSE');\n\n    builder.pushDynamicComponentManager();\n    builder.invokeComponent(null, params, hash, block, inverse);\n\n    builder.label('ELSE');\n    builder.exit();\n    builder.return();\n\n    builder.label('END');\n    builder.popFrame();\n\n    builder.stopLabels();\n  }\n}\n\nexport function builder(env: Environment, meta: CompilationMeta) {\n  return new OpcodeBuilderDSL(env, meta);\n}\n","import { CompiledDynamicTemplate, CompiledStaticTemplate } from './compiled/blocks';\nimport { builder } from './compiler';\nimport OpcodeBuilder from './compiled/opcodes/builder';\nimport Environment from './environment';\nimport { Option, EMPTY_ARRAY } from '@glimmer/util';\nimport * as WireFormat from '@glimmer/wire-format';\nimport { Opaque, SymbolTable, ProgramSymbolTable, BlockSymbolTable } from '@glimmer/interfaces';\nimport { CompilationMeta } from '@glimmer/interfaces';\n\nimport {\n  STATEMENTS\n} from './syntax/functions';\n\nexport type DeserializedStatement = WireFormat.Statement | WireFormat.Statements.Attribute | WireFormat.Statements.Argument;\n\nexport function compileStatement(statement: WireFormat.Statement, builder: OpcodeBuilder) {\n  STATEMENTS.compile(statement, builder);\n}\n\nexport interface ScannedTemplate<S extends SymbolTable> {\n  compileStatic(env: Environment): CompiledStaticTemplate;\n  compileDynamic(env: Environment): CompiledDynamicTemplate<S>;\n}\n\nexport class CompilableTemplate<S extends SymbolTable> implements ScannedTemplate<S> {\n  private compiledStatic: Option<CompiledStaticTemplate> = null;\n  private compiledDynamic: Option<CompiledDynamicTemplate<S>> = null;\n\n  constructor(public statements: WireFormat.Statement[], public symbolTable: S) {}\n\n  compileStatic(env: Environment): CompiledStaticTemplate {\n    let { compiledStatic } = this;\n\n    if (!compiledStatic) {\n      let builder = compileStatements(this.statements, this.symbolTable.meta, env);\n\n      let start = builder.start;\n      let end = builder.finalize();\n\n      compiledStatic = this.compiledStatic = new CompiledStaticTemplate(start, end);\n    }\n\n    return compiledStatic;\n  }\n\n  compileDynamic(env: Environment): CompiledDynamicTemplate<S> {\n    let { compiledDynamic } = this;\n\n    if (!compiledDynamic) {\n      let staticBlock = this.compileStatic(env);\n      compiledDynamic = new CompiledDynamicTemplate(staticBlock.start, staticBlock.end, this.symbolTable);\n    }\n\n    return compiledDynamic;\n  }\n}\n\nexport type Template = CompilableTemplate<SymbolTable>;\nexport type Program = CompilableTemplate<ProgramSymbolTable>;\nexport type Block = CompilableTemplate<BlockSymbolTable>;\n\nexport type ScannedProgram = ScannedTemplate<ProgramSymbolTable>;\nexport type ScannedBlock = ScannedTemplate<BlockSymbolTable>;\n\nfunction compileStatements(statements: WireFormat.Statement[], meta: CompilationMeta, env: Environment) {\n  let b = builder(env, meta);\n\n  for (let statement of statements) {\n    compileStatement(statement, b);\n  }\n\n  return b;\n}\n\nexport const ATTRS_BLOCK = '&attrs';\n\nexport function layout(prelude: WireFormat.Statement[], head: WireFormat.Statement[], body: WireFormat.Statement[], symbolTable: ProgramSymbolTable) {\n  let [, tag] = prelude.pop() as WireFormat.Statements.OpenElement;\n  prelude.push([Ops.ClientSideStatement, ClientSide.Ops.OpenComponentElement, tag]);\n  prelude.push([Ops.ClientSideStatement, ClientSide.Ops.DidCreateElement]);\n\n  let attrsSymbol = symbolTable.symbols.length + 1;\n  symbolTable.symbols.push(ATTRS_BLOCK);\n\n  let statements = prelude\n    .concat([[Ops.Yield, attrsSymbol, EMPTY_ARRAY]])\n    .concat(head)\n    .concat(body)\n    .concat([[Ops.ClientSideStatement, ClientSide.Ops.DidRenderLayout]]);\n\n  return new CompilableTemplate(statements, symbolTable);\n}\n\nexport default class Scanner {\n  constructor(private block: WireFormat.SerializedTemplateBlock, private env: Environment) {\n  }\n\n  scanEntryPoint(meta: CompilationMeta): Program {\n    let { block, env } = this;\n\n    let statements;\n    if (block.prelude && block.head) {\n      statements = block.prelude.concat(block.head).concat(block.statements);\n    } else {\n      statements = block.statements;\n    }\n\n    return new RawProgram(env, meta, statements, block.symbols, block.hasEval).scan();\n  }\n\n  scanBlock(meta: CompilationMeta): Block {\n    let { block, env } = this;\n\n    let statements;\n    if (block.prelude && block.head) {\n      statements = block.prelude.concat(block.head).concat(block.statements);\n    } else {\n      statements = block.statements;\n    }\n\n    return new RawInlineBlock(env, meta, statements, EMPTY_ARRAY).scan();\n  }\n\n  scanLayout(meta: CompilationMeta, attrs: WireFormat.Statements.Attribute[]): Program {\n    let { block } = this;\n    let { symbols, hasEval } = block;\n\n    if (!block.prelude || !block.head) {\n      throw new Error(`A layout must have a top-level element`);\n    }\n\n    let symbolTable = { meta, hasEval, symbols };\n    let { statements: prelude } = scanBlock({ statements: block.prelude, parameters: EMPTY_ARRAY }, meta, this.env);\n    let { statements: head } = scanBlock({ statements: [...attrs, ...block.head], parameters: EMPTY_ARRAY }, meta, this.env);\n    let { statements: body } = scanBlock({ statements: block.statements, parameters: EMPTY_ARRAY }, meta, this.env);\n\n    return layout(prelude, head, body, symbolTable);\n  }\n}\n\nexport function scanBlock(block: WireFormat.SerializedInlineBlock, meta: CompilationMeta, env: Environment): Block {\n  return new RawInlineBlock(env, meta, block.statements, EMPTY_ARRAY).scan();\n}\n\nimport { PublicVM } from './vm';\nimport { VersionedPathReference } from '@glimmer/reference';\n\nexport namespace ClientSide {\n  export enum Ops {\n    OpenComponentElement,\n    DidCreateElement,\n    DidRenderLayout,\n    OptimizedAppend,\n    UnoptimizedAppend,\n    StaticPartial,\n    DynamicPartial,\n    NestedBlock,\n    ScannedBlock,\n\n    FunctionExpression\n  }\n\n  export function is<T extends any[]>(variant: Ops): (value: any[]) => value is T {\n    return function(value: any[]): value is T {\n      return value[0] === WireFormat.Ops.ClientSideExpression || value[0] === WireFormat.Ops.ClientSideStatement && value[1] === variant;\n    };\n  }\n\n  import ClientSideStatement = WireFormat.Ops.ClientSideStatement;\n  import ClientSideExpression = WireFormat.Ops.ClientSideExpression;\n\n  export type OpenComponentElement  = [ClientSideStatement, Ops.OpenComponentElement, string];\n  export type DidCreateElement      = [ClientSideStatement, Ops.DidCreateElement];\n  export type DidRenderLayout       = [ClientSideStatement, Ops.DidRenderLayout];\n  export type OptimizedAppend       = [ClientSideStatement, Ops.OptimizedAppend, WireFormat.Expression, boolean];\n  export type UnoptimizedAppend     = [ClientSideStatement, Ops.UnoptimizedAppend, WireFormat.Expression, boolean];\n  export type StaticPartial         = [ClientSideStatement, Ops.StaticPartial, string, WireFormat.Core.EvalInfo];\n  export type DynamicPartial        = [ClientSideStatement, Ops.DynamicPartial, WireFormat.Expression, WireFormat.Core.EvalInfo];\n\n  export type FunctionExpression    = [ClientSideExpression, Ops.FunctionExpression, FunctionExpressionCallback<Opaque>];\n\n  export type FunctionExpressionCallback<T> = (VM: PublicVM, symbolTable: SymbolTable) => VersionedPathReference<T>;\n\n  export type ClientSideStatement =\n    | OpenComponentElement\n    | DidCreateElement\n    | DidRenderLayout\n    | OptimizedAppend\n    | UnoptimizedAppend\n    | StaticPartial\n    | DynamicPartial\n    ;\n\n  export type ClientSideExpression =\n    | FunctionExpression\n    ;\n}\n\nconst { Ops } = WireFormat;\n\nexport abstract class RawBlock<S extends SymbolTable> {\n  constructor(protected env: Environment, protected meta: CompilationMeta, private statements: WireFormat.Statement[]) {}\n\n  scanStatements(): WireFormat.Statement[] {\n    let buffer: WireFormat.Statement[] = [];\n    let statements = this.statements;\n    for (let statement of statements) {\n      buffer.push(statement);\n    }\n\n    return buffer;\n  }\n\n  child(block: Option<WireFormat.SerializedInlineBlock>): Option<RawInlineBlock> {\n    if (!block) return null;\n    return new RawInlineBlock(this.env, this.meta, block.statements, block.parameters);\n  }\n\n  abstract scan(): CompilableTemplate<S>;\n}\n\nexport class RawInlineBlock extends RawBlock<BlockSymbolTable> {\n  constructor(env: Environment, meta: CompilationMeta, statements: WireFormat.Statement[], private parameters: number[]) {\n    super(env, meta, statements);\n  }\n\n  scan(): Block {\n    let statements = this.scanStatements();\n    return new CompilableTemplate(statements, { parameters: this.parameters, meta: this.meta });\n  }\n}\n\nexport class RawProgram extends RawBlock<ProgramSymbolTable> {\n  constructor(env: Environment, meta: CompilationMeta, statements: WireFormat.Statement[], private symbols: string[], private hasEval: boolean) {\n    super(env, meta, statements);\n  }\n\n  scan(): Program {\n    let statements = this.scanStatements();\n    return new CompilableTemplate(statements, { symbols: this.symbols, hasEval: this.hasEval, meta: this.meta });\n  }\n}\n","import { ScopeSlot } from '../environment';\nimport { CompiledDynamicBlock, CompiledDynamicProgram } from '../compiled/blocks';\nimport * as WireFormat from '@glimmer/wire-format';\nimport { BlockSymbolTable, ProgramSymbolTable } from '@glimmer/interfaces';\nimport OpcodeBuilder from '../compiled/opcodes/builder';\nimport { DynamicInvoker } from '../compiled/opcodes/vm';\nimport { VM, PublicVM } from '../vm';\nimport { IArguments } from '../vm/arguments';\nimport { Register } from '../opcodes';\nimport { ATTRS_BLOCK, Block, ClientSide, RawInlineBlock } from '../scanner';\n\nimport {\n  EMPTY_ARRAY,\n  Opaque,\n  Option,\n  Dict,\n  dict\n} from '@glimmer/util';\n\nimport {\n  VersionedPathReference,\n  map\n} from '@glimmer/reference';\n\nimport Ops = WireFormat.Ops;\n\nexport type SexpExpression = WireFormat.Expression;\nexport type Syntax = WireFormat.Statement | WireFormat.Expression;\nexport type CompilerFunction<T extends Syntax> = ((sexp: T, builder: OpcodeBuilder) => void);\n\nexport class Compilers<T extends Syntax> {\n  private names = dict<number>();\n  private funcs: CompilerFunction<T>[] = [];\n\n  constructor(private offset = 0) {}\n\n  add(name: number, func: CompilerFunction<T>): void {\n    this.funcs.push(func);\n    this.names[name] = this.funcs.length - 1;\n  }\n\n  compile(sexp: T, builder: OpcodeBuilder): void {\n    let name: number = sexp[this.offset];\n    let index = this.names[name];\n    let func = this.funcs[index];\n    func(sexp, builder);\n  }\n}\n\nimport S = WireFormat.Statements;\n\nexport const STATEMENTS = new Compilers<WireFormat.Statement>();\nexport const CLIENT_SIDE = new Compilers<ClientSide.ClientSideStatement>(1);\n\nSTATEMENTS.add(Ops.Text, (sexp: S.Text, builder: OpcodeBuilder) => {\n  builder.text(sexp[1]);\n});\n\nSTATEMENTS.add(Ops.Comment, (sexp: S.Comment, builder: OpcodeBuilder) => {\n  builder.comment(sexp[1]);\n});\n\nSTATEMENTS.add(Ops.CloseElement, (_sexp, builder: OpcodeBuilder) => {\n  builder.closeElement();\n});\n\nSTATEMENTS.add(Ops.FlushElement, (_sexp, builder: OpcodeBuilder) => {\n  builder.flushElement();\n});\n\nSTATEMENTS.add(Ops.Modifier, (sexp: S.Modifier, builder: OpcodeBuilder) => {\n  let { env, meta } = builder;\n  let [, name, params, hash] = sexp;\n\n  if (env.hasModifier(name, meta.templateMeta)) {\n    builder.compileArgs(params, hash, true);\n    builder.modifier(env.lookupModifier(name, meta.templateMeta));\n  } else {\n    throw new Error(`Compile Error ${name} is not a modifier: Helpers may not be used in the element form.`);\n  }\n});\n\nSTATEMENTS.add(Ops.StaticAttr, (sexp: S.StaticAttr, builder: OpcodeBuilder) => {\n  let [, name, value, namespace] = sexp;\n  builder.staticAttr(name, namespace, value as string);\n});\n\nSTATEMENTS.add(Ops.DynamicAttr, (sexp: S.DynamicAttr, builder) => {\n  dynamicAttr(sexp, false, builder);\n});\n\nSTATEMENTS.add(Ops.TrustingAttr, (sexp: S.DynamicAttr, builder) => {\n  dynamicAttr(sexp, true, builder);\n});\n\nfunction dynamicAttr(sexp: S.DynamicAttr | S.TrustingAttr, trusting: boolean, builder: OpcodeBuilder) {\n  let [, name, value, namespace] = sexp;\n\n  expr(value, builder);\n\n  if (namespace) {\n    builder.dynamicAttrNS(name, namespace, trusting);\n  } else {\n    builder.dynamicAttr(name, trusting);\n  }\n}\n\nSTATEMENTS.add(Ops.OpenElement, (sexp: S.OpenElement, builder: OpcodeBuilder) => {\n  builder.openPrimitiveElement(sexp[1]);\n});\n\nCLIENT_SIDE.add(ClientSide.Ops.OpenComponentElement, (sexp: ClientSide.OpenComponentElement, builder) => {\n  builder.pushComponentOperations();\n  builder.openElementWithOperations(sexp[2]);\n});\n\nCLIENT_SIDE.add(ClientSide.Ops.DidCreateElement, (_sexp: ClientSide.DidCreateElement, builder) => {\n  builder.didCreateElement(Register.s0);\n});\n\nCLIENT_SIDE.add(ClientSide.Ops.DidRenderLayout, (_sexp: ClientSide.DidRenderLayout, builder) => {\n  builder.didRenderLayout(Register.s0);\n});\n\nSTATEMENTS.add(Ops.Append, (sexp: S.Append, builder: OpcodeBuilder) => {\n  let [, value, trusting] = sexp;\n\n  let { inlines } = builder.env.macros();\n  let returned = inlines.compile(sexp, builder) || value;\n\n  if (returned === true) return;\n\n  expr(value, builder);\n\n  if (trusting) {\n    builder.trustingAppend();\n  } else {\n    builder.cautiousAppend();\n  }\n});\n\n// CLIENT_SIDE.add(ClientSide.Ops.UnoptimizedAppend, (sexp: ClientSide.UnoptimizedAppend, builder) => {\n//   let [,, value, trustingMorph] = sexp;\n\n//   let { inlines } = builder.env.macros();\n//   let returned = inlines.compile(sexp, builder) || value;\n\n//   if (returned === true) return;\n\n//   if (trustingMorph) {\n//     builder.guardedTrustingAppend(returned[1]);\n//   } else {\n//     builder.guardedCautiousAppend(returned[1]);\n//   }\n// });\n\nSTATEMENTS.add(Ops.Block, (sexp: S.Block, builder) => {\n  let [, name, params, hash, _template, _inverse] = sexp;\n  let template = builder.template(_template);\n  let inverse = builder.template(_inverse);\n\n  let templateBlock = template && template.scan();\n  let inverseBlock = inverse && inverse.scan();\n\n  let { blocks } = builder.env.macros();\n  blocks.compile(name, params, hash, templateBlock, inverseBlock, builder);\n});\n\nexport class InvokeDynamicLayout implements DynamicInvoker<ProgramSymbolTable> {\n  constructor(private attrs: Option<Block>) {}\n\n  invoke(vm: VM, layout: Option<CompiledDynamicProgram>) {\n    let { symbols, hasEval } = layout!.symbolTable as ProgramSymbolTable;\n    let stack = vm.stack;\n\n    let scope = vm.pushRootScope(symbols.length + 1, true);\n    scope.bindSelf(stack.pop<VersionedPathReference<Opaque>>());\n\n    scope.bindBlock(symbols.indexOf(ATTRS_BLOCK) + 1, this.attrs);\n\n    let lookup: Option<Dict<ScopeSlot>> = null;\n    let $eval: Option<number> = -1;\n\n    if (hasEval) {\n      $eval = symbols.indexOf('$eval') + 1;\n      lookup = dict<ScopeSlot>();\n    }\n\n    let callerNames = stack.pop<string[]>();\n\n    for (let i=callerNames.length - 1; i>=0; i--) {\n      let symbol = symbols.indexOf(callerNames[i]);\n      let value = stack.pop<VersionedPathReference<Opaque>>();\n\n      if (symbol !== -1) scope.bindSymbol(symbol + 1, value);\n      if (hasEval) lookup![callerNames[i]] = value;\n    }\n\n    let inverseSymbol = symbols.indexOf('&inverse');\n    let inverse = stack.pop<Option<Block>>();\n\n    if (inverseSymbol !== -1) {\n      scope.bindBlock(inverseSymbol + 1, inverse);\n    }\n\n    if (lookup) lookup['&inverse'] = inverse;\n\n    let defaultSymbol = symbols.indexOf('&default');\n    let defaultBlock = stack.pop<Option<Block>>();\n\n    if (defaultSymbol !== -1) {\n      scope.bindBlock(defaultSymbol + 1, defaultBlock);\n    }\n\n    if (lookup) lookup['&default'] = defaultBlock;\n    if (lookup) scope.bindEvalScope(lookup);\n\n    vm.pushFrame();\n    vm.call(layout!.start);\n  }\n}\n\nSTATEMENTS.add(Ops.Component, (sexp: S.Component, builder) => {\n  let [, tag, attrs, args, block] = sexp;\n\n  if (builder.env.hasComponentDefinition(tag, builder.meta.templateMeta)) {\n    let child = builder.template(block);\n    let attrsBlock = new RawInlineBlock(builder.env, builder.meta, attrs, EMPTY_ARRAY);\n    let definition = builder.env.getComponentDefinition(tag, builder.meta.templateMeta);\n    builder.pushComponentManager(definition);\n    builder.invokeComponent(attrsBlock, null, args, child && child.scan());\n  } else if (block && block.parameters.length) {\n    throw new Error(`Compile Error: Cannot find component ${tag}`);\n  } else {\n    builder.openPrimitiveElement(tag);\n    attrs.forEach(attr => STATEMENTS.compile(attr, builder));\n    builder.flushElement();\n    if (block) block.statements.forEach(s => STATEMENTS.compile(s, builder));\n    builder.closeElement();\n  }\n});\n\nexport class PartialInvoker implements DynamicInvoker<ProgramSymbolTable> {\n  constructor(private outerSymbols: string[], private evalInfo: WireFormat.Core.EvalInfo) {}\n\n  invoke(vm: VM, _partial: Option<CompiledDynamicProgram>) {\n    let partial = _partial;\n    let partialSymbols = partial.symbolTable.symbols;\n    let outerScope = vm.scope();\n    let partialScope = vm.pushRootScope(partialSymbols.length, false);\n    partialScope.bindCallerScope(outerScope.getCallerScope());\n    partialScope.bindEvalScope(outerScope.getEvalScope());\n    partialScope.bindSelf(outerScope.getSelf());\n\n    let { evalInfo, outerSymbols } = this;\n\n    let locals = dict<VersionedPathReference<Opaque>>();\n\n    evalInfo.forEach(slot => {\n      let name = outerSymbols[slot - 1];\n      let ref  = outerScope.getSymbol(slot);\n      locals[name] = ref;\n    });\n\n    let evalScope = outerScope.getEvalScope()!;\n    partialSymbols.forEach((name, i) => {\n      let symbol = i + 1;\n      let value = evalScope[name];\n\n      if (value !== undefined) partialScope.bind(symbol, value);\n    });\n\n    partialScope.bindPartialMap(locals);\n\n    vm.pushFrame();\n    vm.call(partial.start);\n  }\n}\n\nSTATEMENTS.add(Ops.Partial, (sexp: S.Partial, builder) => {\n  let [, name, evalInfo] = sexp;\n\n  let { templateMeta, symbols } = builder.meta;\n\n  function helper(vm: PublicVM, args: IArguments) {\n    let { env } = vm;\n    let nameRef = args.positional.at(0);\n\n    return map(nameRef, name => {\n      if (typeof name === 'string' && name) {\n        if (!env.hasPartial(name, templateMeta)) {\n          throw new Error(`Could not find a partial named \"${name}\"`);\n        }\n\n        return env.lookupPartial(name, templateMeta);\n      } else if (name) {\n        throw new Error(`Could not find a partial named \"${String(name)}\"`);\n      } else {\n        return null;\n      }\n    });\n  }\n\n  builder.startLabels();\n\n  builder.pushFrame();\n\n  builder.returnTo('END');\n\n  expr(name, builder);\n  builder.pushImmediate(EMPTY_ARRAY);\n  builder.pushArgs(1, true);\n  builder.helper(helper);\n\n  builder.dup();\n  builder.test('simple');\n\n  builder.enter(2);\n\n  builder.jumpUnless('ELSE');\n\n  builder.getPartialTemplate();\n  builder.compileDynamicBlock();\n  builder.invokeDynamic(new PartialInvoker(symbols, evalInfo));\n  builder.popScope();\n  builder.popFrame();\n\n  builder.label('ELSE');\n  builder.exit();\n  builder.return();\n\n  builder.label('END');\n  builder.popFrame();\n\n  builder.stopLabels();\n});\n\nclass InvokeDynamicYield implements DynamicInvoker<BlockSymbolTable> {\n  constructor(private callerCount: number) {}\n\n  invoke(vm: VM, block: Option<CompiledDynamicBlock>) {\n    let { callerCount } = this;\n    let stack = vm.stack;\n\n    if (!block) {\n      // To balance the pop{Frame,Scope}\n      vm.pushFrame();\n      vm.pushCallerScope();\n\n      return;\n    }\n\n    let table = block.symbolTable;\n    let locals = table.parameters; // always present in inline blocks\n\n    let calleeCount = locals ? locals.length : 0;\n    let count = Math.min(callerCount, calleeCount);\n\n    vm.pushFrame();\n    vm.pushCallerScope(calleeCount > 0);\n\n    let scope = vm.scope();\n\n    for (let i=0; i<count; i++) {\n      scope.bindSymbol(locals![i], stack.fromBase<VersionedPathReference<Opaque>>(callerCount-i));\n    }\n\n    vm.call(block.start);\n  }\n}\n\nSTATEMENTS.add(Ops.Yield, (sexp: WireFormat.Statements.Yield, builder) => {\n  let [, to, params] = sexp;\n\n  let count = compileList(params, builder);\n\n  builder.getBlock(to);\n  builder.compileDynamicBlock();\n  builder.invokeDynamic(new InvokeDynamicYield(count));\n  builder.popScope();\n  builder.popFrame();\n\n  if (count) {\n    builder.pop(count);\n  }\n});\n\nSTATEMENTS.add(Ops.Debugger, (sexp: WireFormat.Statements.Debugger, builder: OpcodeBuilder) => {\n  let [, evalInfo] = sexp;\n\n  builder.debugger(builder.meta.symbols, evalInfo);\n});\n\nSTATEMENTS.add(Ops.ClientSideStatement, (sexp: WireFormat.Statements.ClientSide, builder) => {\n  CLIENT_SIDE.compile(sexp as ClientSide.ClientSideStatement, builder);\n});\n\nconst EXPRESSIONS = new Compilers<WireFormat.Expression>();\nconst CLIENT_SIDE_EXPRS = new Compilers<ClientSide.ClientSideExpression>(1);\n\nimport E = WireFormat.Expressions;\nimport C = WireFormat.Core;\n\nexport function expr(expression: WireFormat.Expression, builder: OpcodeBuilder): void {\n  if (Array.isArray(expression)) {\n    EXPRESSIONS.compile(expression, builder);\n  } else {\n    builder.primitive(expression);\n  }\n}\n\nEXPRESSIONS.add(Ops.Unknown, (sexp: E.Unknown, builder: OpcodeBuilder) => {\n  let name = sexp[1];\n\n  if (builder.env.hasHelper(name, builder.meta.templateMeta)) {\n    EXPRESSIONS.compile([Ops.Helper, name, EMPTY_ARRAY, null], builder);\n  } else if (builder.meta.asPartial) {\n    builder.resolveMaybeLocal(name);\n  } else {\n    builder.getVariable(0);\n    builder.getProperty(name);\n  }\n});\n\nEXPRESSIONS.add(Ops.Concat, ((sexp: E.Concat, builder: OpcodeBuilder) => {\n  let parts = sexp[1];\n  parts.forEach(p => expr(p, builder));\n  builder.concat(parts.length);\n}) as any);\n\nCLIENT_SIDE_EXPRS.add(ClientSide.Ops.FunctionExpression, (sexp: ClientSide.FunctionExpression, builder: OpcodeBuilder) => {\n  builder.function(sexp[2]);\n});\n\nEXPRESSIONS.add(Ops.Helper, (sexp: E.Helper, builder: OpcodeBuilder) => {\n  let { env, meta } = builder;\n  let [, name, params, hash] = sexp;\n\n  if (env.hasHelper(name, meta.templateMeta)) {\n    builder.compileArgs(params, hash, true);\n    builder.helper(env.lookupHelper(name, meta.templateMeta));\n  } else {\n    throw new Error(`Compile Error: ${name} is not a helper`);\n  }\n});\n\nEXPRESSIONS.add(Ops.Get, (sexp: E.Get, builder) => {\n  let [, head, path] = sexp;\n  builder.getVariable(head);\n  path.forEach(p => builder.getProperty(p));\n});\n\nEXPRESSIONS.add(Ops.MaybeLocal, (sexp: E.MaybeLocal, builder) => {\n  let [, path] = sexp;\n\n  if (builder.meta.asPartial) {\n    let head = path[0];\n    path = path.slice(1);\n\n    builder.resolveMaybeLocal(head);\n  } else {\n    builder.getVariable(0);\n  }\n\n  path.forEach(p => builder.getProperty(p));\n});\n\nEXPRESSIONS.add(Ops.Undefined, (_sexp, builder) => {\n  return builder.primitive(undefined);\n});\n\nEXPRESSIONS.add(Ops.HasBlock, (sexp: E.HasBlock, builder) => {\n  builder.hasBlock(sexp[1]);\n});\n\nEXPRESSIONS.add(Ops.HasBlockParams, (sexp: E.HasBlockParams, builder) => {\n  builder.hasBlockParams(sexp[1]);\n});\n\nEXPRESSIONS.add(Ops.ClientSideExpression, (sexp: E.ClientSide, builder) => {\n  CLIENT_SIDE_EXPRS.compile(sexp as ClientSide.ClientSideExpression, builder);\n});\n\nexport function compileList(params: Option<WireFormat.Expression[]>, builder: OpcodeBuilder): number {\n  if (!params) return 0;\n  params.forEach(p => expr(p, builder));\n  return params.length;\n}\n\nexport type BlockMacro = (params: C.Params, hash: C.Hash, template: Option<Block>, inverse: Option<Block>, builder: OpcodeBuilder) => void;\nexport type MissingBlockMacro = (name: string, params: C.Params, hash: C.Hash, template: Option<Block>, inverse: Option<Block>, builder: OpcodeBuilder) => void;\n\nexport class Blocks {\n  private names = dict<number>();\n  private funcs: BlockMacro[] = [];\n  private missing: MissingBlockMacro;\n\n  add(name: string, func: BlockMacro) {\n    this.funcs.push(func);\n    this.names[name] = this.funcs.length - 1;\n  }\n\n  addMissing(func: MissingBlockMacro) {\n    this.missing = func;\n  }\n\n  compile(name: string, params: C.Params, hash: C.Hash, template: Option<Block>, inverse: Option<Block>, builder: OpcodeBuilder): void {\n    let index = this.names[name];\n\n    if (index === undefined) {\n      let func = this.missing;\n      let handled = func(name, params, hash, template, inverse, builder);\n    } else {\n      let func = this.funcs[index];\n      func(params, hash, template, inverse, builder);\n    }\n  }\n}\n\nexport const BLOCKS = new Blocks();\n\nexport type AppendSyntax = S.Append;\nexport type AppendMacro = (name: string, params: Option<C.Params>, hash: Option<C.Hash>, builder: OpcodeBuilder) => ['expr', WireFormat.Expression] | true | false;\n\nexport class Inlines {\n  private names = dict<number>();\n  private funcs: AppendMacro[] = [];\n  private missing: AppendMacro;\n\n  add(name: string, func: AppendMacro) {\n    this.funcs.push(func);\n    this.names[name] = this.funcs.length - 1;\n  }\n\n  addMissing(func: AppendMacro) {\n    this.missing = func;\n  }\n\n  compile(sexp: AppendSyntax, builder: OpcodeBuilder): ['expr', WireFormat.Expression] | true {\n    let value = sexp[1];\n\n    // TODO: Fix this so that expression macros can return\n    // things like components, so that {{component foo}}\n    // is the same as {{(component foo)}}\n\n    if (!Array.isArray(value)) return ['expr', value];\n\n    let name: string;\n    let params: Option<C.Params>;\n    let hash: Option<C.Hash>;\n\n    if (value[0] === Ops.Helper) {\n      name = value[1];\n      params = value[2];\n      hash = value[3];\n    } else if (value[0] === Ops.Unknown) {\n      name = value[1];\n      params = hash = null;\n    } else {\n      return ['expr', value];\n    }\n\n    let index = this.names[name];\n\n    if (index === undefined && this.missing) {\n      let func = this.missing;\n      let returned = func(name, params, hash, builder);\n      return returned === false ? ['expr', value] : returned;\n    } else if (index !== undefined) {\n      let func = this.funcs[index];\n      let returned = func(name, params, hash, builder);\n      return returned === false ? ['expr', value] : returned;\n    } else {\n      return ['expr', value];\n    }\n  }\n}\n\nexport const INLINES = new Inlines();\n\npopulateBuiltins(BLOCKS, INLINES);\n\nexport function populateBuiltins(blocks: Blocks = new Blocks(), inlines: Inlines = new Inlines()): { blocks: Blocks, inlines: Inlines } {\n  blocks.add('if', (params, _hash, template, inverse, builder) => {\n    //        PutArgs\n    //        Test(Environment)\n    //        Enter(BEGIN, END)\n    // BEGIN: Noop\n    //        JumpUnless(ELSE)\n    //        Evaluate(default)\n    //        Jump(END)\n    // ELSE:  Noop\n    //        Evalulate(inverse)\n    // END:   Noop\n    //        Exit\n\n    if (!params || params.length !== 1) {\n      throw new Error(`SYNTAX ERROR: #if requires a single argument`);\n    }\n\n    builder.startLabels();\n\n    builder.pushFrame();\n\n    builder.returnTo('END');\n\n    expr(params[0], builder);\n\n    builder.test('environment');\n\n    builder.enter(1);\n\n    builder.jumpUnless('ELSE');\n\n    builder.invokeStatic(template);\n\n    if (inverse) {\n      builder.jump('EXIT');\n\n      builder.label('ELSE');\n      builder.invokeStatic(inverse);\n\n      builder.label('EXIT');\n      builder.exit();\n      builder.return();\n    } else {\n      builder.label('ELSE');\n      builder.exit();\n      builder.return();\n    }\n\n    builder.label('END');\n    builder.popFrame();\n\n    builder.stopLabels();\n  });\n\n  blocks.add('unless', (params, _hash, template, inverse, builder) => {\n    //        PutArgs\n    //        Test(Environment)\n    //        Enter(BEGIN, END)\n    // BEGIN: Noop\n    //        JumpUnless(ELSE)\n    //        Evaluate(default)\n    //        Jump(END)\n    // ELSE:  Noop\n    //        Evalulate(inverse)\n    // END:   Noop\n    //        Exit\n\n    if (!params || params.length !== 1) {\n      throw new Error(`SYNTAX ERROR: #unless requires a single argument`);\n    }\n\n    builder.startLabels();\n\n    builder.pushFrame();\n\n    builder.returnTo('END');\n\n    expr(params[0], builder);\n\n    builder.test('environment');\n\n    builder.enter(1);\n\n    builder.jumpIf('ELSE');\n\n    builder.invokeStatic(template);\n\n    if (inverse) {\n      builder.jump('EXIT');\n\n      builder.label('ELSE');\n      builder.invokeStatic(inverse);\n\n      builder.label('EXIT');\n      builder.exit();\n      builder.return();\n    } else {\n      builder.label('ELSE');\n      builder.exit();\n      builder.return();\n    }\n\n    builder.label('END');\n    builder.popFrame();\n\n    builder.stopLabels();\n  });\n\n  blocks.add('with', (params, _hash, template, inverse, builder) => {\n    //        PutArgs\n    //        Test(Environment)\n    //        Enter(BEGIN, END)\n    // BEGIN: Noop\n    //        JumpUnless(ELSE)\n    //        Evaluate(default)\n    //        Jump(END)\n    // ELSE:  Noop\n    //        Evalulate(inverse)\n    // END:   Noop\n    //        Exit\n\n    if (!params || params.length !== 1) {\n      throw new Error(`SYNTAX ERROR: #with requires a single argument`);\n    }\n\n    builder.startLabels();\n\n    builder.pushFrame();\n\n    builder.returnTo('END');\n\n    expr(params[0], builder);\n\n    builder.dup();\n    builder.test('environment');\n\n    builder.enter(2);\n\n    builder.jumpUnless('ELSE');\n\n    builder.invokeStatic(template, 1);\n\n    if (inverse) {\n      builder.jump('EXIT');\n\n      builder.label('ELSE');\n      builder.invokeStatic(inverse);\n\n      builder.label('EXIT');\n      builder.exit();\n      builder.return();\n    } else {\n      builder.label('ELSE');\n      builder.exit();\n      builder.return();\n    }\n\n    builder.label('END');\n    builder.popFrame();\n\n    builder.stopLabels();\n  });\n\n  blocks.add('each', (params, hash, template, inverse, builder) => {\n    //         Enter(BEGIN, END)\n    // BEGIN:  Noop\n    //         PutArgs\n    //         PutIterable\n    //         JumpUnless(ELSE)\n    //         EnterList(BEGIN2, END2)\n    // ITER:   Noop\n    //         NextIter(BREAK)\n    // BEGIN2: Noop\n    //         PushChildScope\n    //         Evaluate(default)\n    //         PopScope\n    // END2:   Noop\n    //         Exit\n    //         Jump(ITER)\n    // BREAK:  Noop\n    //         ExitList\n    //         Jump(END)\n    // ELSE:   Noop\n    //         Evalulate(inverse)\n    // END:    Noop\n    //         Exit\n\n    builder.startLabels();\n\n    builder.pushFrame();\n\n    builder.returnTo('END');\n\n    if (hash && hash[0][0] === 'key') {\n      expr(hash[1][0], builder);\n    } else {\n      throw new Error('Compile error: #each without key');\n    }\n\n    expr(params[0], builder);\n\n    builder.enter(2);\n\n    builder.putIterator();\n\n    builder.jumpUnless('ELSE');\n\n    builder.pushFrame();\n\n    builder.returnTo('ITER');\n\n    builder.dup(Register.fp, 1);\n\n    builder.enterList('BODY');\n\n    builder.label('ITER');\n    builder.iterate('BREAK');\n\n    builder.label('BODY');\n    builder.invokeStatic(template, 2);\n    builder.pop(2);\n    builder.exit();\n    builder.return();\n\n    builder.label('BREAK');\n    builder.exitList();\n    builder.popFrame();\n\n    if (inverse) {\n      builder.jump('EXIT');\n\n      builder.label('ELSE');\n      builder.invokeStatic(inverse);\n\n      builder.label('EXIT');\n      builder.exit();\n      builder.return();\n    } else {\n      builder.label('ELSE');\n      builder.exit();\n      builder.return();\n    }\n\n    builder.label('END');\n    builder.popFrame();\n\n    builder.stopLabels();\n  });\n\n  blocks.add('-in-element', (params, hash, template, _inverse, builder) => {\n    if (!params || params.length !== 1) {\n      throw new Error(`SYNTAX ERROR: #-in-element requires a single argument`);\n    }\n\n    builder.startLabels();\n\n    builder.pushFrame();\n\n    builder.returnTo('END');\n\n    if (hash && hash[0].length) {\n      let [ keys, values ] = hash;\n\n      if (keys.length === 1 && keys[0] === 'nextSibling') {\n        expr(values[0], builder);\n      } else {\n        throw new Error(`SYNTAX ERROR: #-in-element does not take a \\`${keys[0]}\\` option`);\n      }\n    } else {\n      expr(null, builder);\n    }\n\n    expr(params[0], builder);\n\n    builder.dup();\n    builder.test('simple');\n\n    builder.enter(3);\n\n    builder.jumpUnless('ELSE');\n\n    builder.pushRemoteElement();\n    builder.invokeStatic(template);\n    builder.popRemoteElement();\n\n    builder.label('ELSE');\n    builder.exit();\n    builder.return();\n\n    builder.label('END');\n    builder.popFrame();\n\n    builder.stopLabels();\n  });\n\n  blocks.add('-with-dynamic-vars', (_params, hash, template, _inverse, builder) => {\n    if (hash) {\n      let [names, expressions] = hash;\n\n      compileList(expressions, builder);\n\n      builder.pushDynamicScope();\n      builder.bindDynamicScope(names);\n      builder.invokeStatic(template);\n      builder.popDynamicScope();\n    } else {\n      builder.invokeStatic(template);\n    }\n  });\n\n  return { blocks, inlines };\n}\n","import { VersionedPathReference } from \"@glimmer/reference\";\nimport { Opaque } from \"@glimmer/interfaces\";\n\nimport { NULL_REFERENCE, UNDEFINED_REFERENCE } from '../references';\nimport { Block } from \"../scanner\";\n\nexport type ConstantType = 'slice' | 'block' | 'reference' | 'string' | 'number' | 'expression';\nexport type ConstantReference =  number;\nexport type ConstantString = number;\nexport type ConstantExpression = number;\nexport type ConstantSlice = number;\nexport type ConstantBlock = number;\nexport type ConstantFunction = number;\nexport type ConstantArray = number;\nexport type ConstantOther = number;\n\nexport class Constants {\n  // `0` means NULL\n\n  private references: VersionedPathReference<Opaque>[] = [];\n  private strings: string[] = [];\n  private expressions: Opaque[] = [];\n  private arrays: number[][] = [];\n  private blocks: Block[] = [];\n  private functions: Function[] = [];\n  private others: Opaque[] = [];\n\n  public NULL_REFERENCE: number;\n  public UNDEFINED_REFERENCE: number;\n\n  constructor() {\n    this.NULL_REFERENCE = this.reference(NULL_REFERENCE);\n    this.UNDEFINED_REFERENCE = this.reference(UNDEFINED_REFERENCE);\n  }\n\n  getReference<T extends Opaque>(value: ConstantReference): VersionedPathReference<T> {\n    return this.references[value - 1] as VersionedPathReference<T>;\n  }\n\n  reference(value: VersionedPathReference<Opaque>): ConstantReference {\n    let index = this.references.length;\n    this.references.push(value);\n    return index + 1;\n  }\n\n  getString(value: ConstantString): string {\n    return this.strings[value - 1];\n  }\n\n  string(value: string): ConstantString {\n    let index = this.strings.length;\n    this.strings.push(value);\n    return index + 1;\n  }\n\n  getExpression<T>(value: ConstantExpression): T {\n    return this.expressions[value - 1] as T;\n  }\n\n  getArray(value: ConstantArray): number[] {\n    return this.arrays[value - 1];\n  }\n\n  getNames(value: ConstantArray): string[] {\n    return this.getArray(value).map(n => this.getString(n));\n  }\n\n  array(values: number[]): ConstantArray {\n    let index = this.arrays.length;\n    this.arrays.push(values);\n    return index + 1;\n  }\n\n  getBlock(value: ConstantBlock): Block {\n    return this.blocks[value - 1];\n  }\n\n  block(block: Block): ConstantBlock {\n    let index = this.blocks.length;\n    this.blocks.push(block);\n    return index + 1;\n  }\n\n  getFunction<T extends Function>(value: ConstantFunction): T {\n    return this.functions[value - 1] as T;\n  }\n\n  function(f: Function): ConstantFunction {\n    let index = this.functions.length;\n    this.functions.push(f);\n    return index + 1;\n  }\n\n  getOther<T>(value: ConstantOther): T {\n    return this.others[value - 1] as T;\n  }\n\n  other(other: Opaque): ConstantOther {\n    let index = this.others.length;\n    this.others.push(other);\n    return index + 1;\n  }\n}\n","import { Opaque, Option } from '@glimmer/util';\nimport { normalizeTextValue } from '../compiled/opcodes/content';\nimport { isSafeString } from '../upsert';\nimport { Environment } from '../environment';\nimport * as Simple from './interfaces';\n\nconst badProtocols = [\n  'javascript:',\n  'vbscript:'\n];\n\nconst badTags = [\n  'A',\n  'BODY',\n  'LINK',\n  'IMG',\n  'IFRAME',\n  'BASE',\n  'FORM'\n];\n\nconst badTagsForDataURI = [\n  'EMBED'\n];\n\nconst badAttributes = [\n  'href',\n  'src',\n  'background',\n  'action'\n];\n\nconst badAttributesForDataURI = [\n  'src'\n];\n\nfunction has(array: Array<string>, item: string): boolean {\n  return array.indexOf(item) !== -1;\n}\n\nfunction checkURI(tagName: Option<string>, attribute: string): boolean {\n  return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);\n}\n\nfunction checkDataURI(tagName: Option<string>, attribute: string): boolean {\n  if (tagName === null) return false;\n  return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);\n}\n\nexport function requiresSanitization(tagName: string, attribute: string): boolean {\n  return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);\n}\n\nexport function sanitizeAttributeValue(env: Environment, element: Simple.Element, attribute: string, value: Opaque): Opaque {\n  let tagName: Option<string> = null;\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (isSafeString(value)) {\n    return value.toHTML();\n  }\n\n  if (!element) {\n    tagName = null;\n  } else {\n    tagName = element.tagName.toUpperCase();\n  }\n\n  let str = normalizeTextValue(value);\n\n  if (checkURI(tagName, attribute)) {\n    let protocol = env.protocolForURL(str);\n    if (has(badProtocols, protocol)) {\n      return `unsafe:${str}`;\n    }\n  }\n\n  if (checkDataURI(tagName, attribute)) {\n    return `unsafe:${str}`;\n  }\n\n  return str;\n}\n","import { Opaque } from '@glimmer/util';\nimport { Simple } from '@glimmer/interfaces';\n\n/*\n * @method normalizeProperty\n * @param element {HTMLElement}\n * @param slotName {String}\n * @returns {Object} { name, type }\n */\nexport function normalizeProperty(element: Simple.Element, slotName: string) {\n  let type, normalized;\n\n  if (slotName in element) {\n    normalized = slotName;\n    type = 'prop';\n  } else {\n    let lower = slotName.toLowerCase();\n    if (lower in element) {\n      type = 'prop';\n      normalized = lower;\n    } else {\n      type = 'attr';\n      normalized = slotName;\n    }\n  }\n\n  if (type === 'prop' &&\n      (normalized.toLowerCase() === 'style' ||\n       preferAttr(element.tagName, normalized))) {\n    type = 'attr';\n  }\n\n  return { normalized, type };\n}\n\nexport function normalizePropertyValue(value: Opaque): Opaque {\n  if (value === '') {\n    return true;\n  }\n\n  return value;\n}\n\n// properties that MUST be set as attributes, due to:\n// * browser bug\n// * strange spec outlier\nconst ATTR_OVERRIDES = {\n\n  // phantomjs < 2.0 lets you set it as a prop but won't reflect it\n  // back to the attribute. button.getAttribute('type') === null\n  BUTTON: { type: true, form: true },\n\n  INPUT: {\n    // Some version of IE (like IE9) actually throw an exception\n    // if you set input.type = 'something-unknown'\n    type: true,\n    form: true,\n    // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false\n    // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false\n    // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true\n    autocorrect: true,\n    // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true\n    // Safari 9.1.3: 'list' in document.createElement('input') === false\n    list: true\n  },\n\n  // element.form is actually a legitimate readOnly property, that is to be\n  // mutated, but must be mutated by setAttribute...\n  SELECT:   { form: true },\n  OPTION:   { form: true },\n  TEXTAREA: { form: true },\n  LABEL:    { form: true },\n  FIELDSET: { form: true },\n  LEGEND:   { form: true },\n  OBJECT:   { form: true }\n};\n\nfunction preferAttr(tagName: string, propName: string) {\n  let tag = ATTR_OVERRIDES[tagName.toUpperCase()];\n  return tag && tag[propName.toLowerCase()] || false;\n}\n","import { Bounds, ConcreteBounds } from '../bounds';\nimport { moveNodesBefore, DOMChanges, DOMTreeConstruction } from '../dom/helper';\nimport { Option } from '@glimmer/util';\n\ninterface Wrapper {\n  depth: number;\n  before: string;\n  after: string;\n}\n\nlet innerHTMLWrapper = {\n  colgroup: { depth: 2, before: '<table><colgroup>', after: '</colgroup></table>' },\n  table:    { depth: 1, before: '<table>', after: '</table>' },\n  tbody:    { depth: 2, before: '<table><tbody>', after: '</tbody></table>' },\n  tfoot:    { depth: 2, before: '<table><tfoot>', after: '</tfoot></table>' },\n  thead:    { depth: 2, before: '<table><thead>', after: '</thead></table>' },\n  tr:       { depth: 3, before: '<table><tbody><tr>', after: '</tr></tbody></table>' }\n};\n\n// Patch:    innerHTML Fix\n// Browsers: IE9\n// Reason:   IE9 don't allow us to set innerHTML on col, colgroup, frameset,\n//           html, style, table, tbody, tfoot, thead, title, tr.\n// Fix:      Wrap the innerHTML we are about to set in its parents, apply the\n//           wrapped innerHTML on a div, then move the unwrapped nodes into the\n//           target position.\nexport function domChanges(document: Option<Document>, DOMChangesClass: typeof DOMChanges): typeof DOMChanges {\n  if (!document) return DOMChangesClass;\n\n  if (!shouldApplyFix(document)) {\n    return DOMChangesClass;\n  }\n\n  let div = document.createElement('div');\n\n  return class DOMChangesWithInnerHTMLFix extends DOMChangesClass {\n    insertHTMLBefore(parent: HTMLElement, nextSibling: Node, html: string): Bounds {\n      if (html === null || html === '') {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      let parentTag = parent.tagName.toLowerCase();\n      let wrapper = innerHTMLWrapper[parentTag];\n\n      if(wrapper === undefined) {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      return fixInnerHTML(parent, wrapper, div, html, nextSibling);\n    }\n  };\n}\n\nexport function treeConstruction(document: Option<Document>, DOMTreeConstructionClass: typeof DOMTreeConstruction): typeof DOMTreeConstruction {\n  if (!document) return DOMTreeConstructionClass;\n\n  if (!shouldApplyFix(document)) {\n    return DOMTreeConstructionClass;\n  }\n\n  let div = document.createElement('div');\n\n  return class DOMTreeConstructionWithInnerHTMLFix extends DOMTreeConstructionClass {\n    insertHTMLBefore(parent: HTMLElement, html: string, reference: Node): Bounds {\n      if (html === null || html === '') {\n        return super.insertHTMLBefore(parent, html, reference);\n      }\n\n      let parentTag = parent.tagName.toLowerCase();\n      let wrapper = innerHTMLWrapper[parentTag];\n\n      if(wrapper === undefined) {\n        return super.insertHTMLBefore(parent, html, reference);\n      }\n\n      return fixInnerHTML(parent, wrapper, div, html, reference);\n    }\n  };\n}\n\nfunction fixInnerHTML(parent: HTMLElement, wrapper: Wrapper, div: HTMLElement, html: string, reference: Node): Bounds {\n  let wrappedHtml = wrapper.before + html + wrapper.after;\n\n  div.innerHTML = wrappedHtml;\n\n  let parentNode: Node = div;\n\n  for (let i=0; i<wrapper.depth; i++) {\n    parentNode = parentNode.childNodes[0];\n  }\n\n  let [first, last] = moveNodesBefore(parentNode, parent, reference);\n  return new ConcreteBounds(parent, first, last);\n}\n\nfunction shouldApplyFix(document: Document) {\n  let table = document.createElement('table');\n  try {\n    table.innerHTML = '<tbody></tbody>';\n  } catch (e) {\n  } finally {\n    if (table.childNodes.length !== 0) {\n      // It worked as expected, no fix required\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { Bounds, ConcreteBounds } from '../bounds';\nimport { moveNodesBefore, DOMChanges, DOMTreeConstruction } from '../dom/helper';\nimport { Option } from '@glimmer/util';\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport type SVG_NAMESPACE = typeof SVG_NAMESPACE;\n\n// Patch:    insertAdjacentHTML on SVG Fix\n// Browsers: Safari, IE, Edge, Firefox ~33-34\n// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is\n//           present but throws an exception on IE and Edge. Old versions of\n//           Firefox create nodes in the incorrect namespace.\n// Fix:      Since IE and Edge silently fail to create SVG nodes using\n//           innerHTML, and because Firefox may create nodes in the incorrect\n//           namespace using innerHTML on SVG elements, an HTML-string wrapping\n//           approach is used. A pre/post SVG tag is added to the string, then\n//           that whole string is added to a div. The created nodes are plucked\n//           out and applied to the target location on DOM.\nexport function domChanges(document: Option<Document>, DOMChangesClass: typeof DOMChanges, svgNamespace: SVG_NAMESPACE): typeof DOMChanges {\n  if (!document) return DOMChangesClass;\n\n  if (!shouldApplyFix(document, svgNamespace)) {\n    return DOMChangesClass;\n  }\n\n  let div = document.createElement('div');\n\n  return class DOMChangesWithSVGInnerHTMLFix extends DOMChangesClass {\n    insertHTMLBefore(parent: HTMLElement, nextSibling: Node, html: string): Bounds {\n      if (html === null || html === '') {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      if (parent.namespaceURI !== svgNamespace) {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      return fixSVG(parent, div, html, nextSibling);\n    }\n  };\n}\n\nexport function treeConstruction(document: Option<Document>, TreeConstructionClass: typeof DOMTreeConstruction, svgNamespace: SVG_NAMESPACE): typeof DOMTreeConstruction {\n  if (!document) return TreeConstructionClass;\n\n  if (!shouldApplyFix(document, svgNamespace)) {\n    return TreeConstructionClass;\n  }\n\n  let div = document.createElement('div');\n\n  return class TreeConstructionWithSVGInnerHTMLFix extends TreeConstructionClass {\n    insertHTMLBefore(parent: HTMLElement, html: string,  reference: Node,): Bounds {\n      if (html === null || html === '') {\n        return super.insertHTMLBefore(parent, html, reference);\n      }\n\n      if (parent.namespaceURI !== svgNamespace) {\n        return super.insertHTMLBefore(parent, html, reference);\n      }\n\n      return fixSVG(parent, div, html, reference);\n    }\n  };\n}\n\nfunction fixSVG(parent: Element, div: HTMLElement, html: string, reference: Node): Bounds {\n  // IE, Edge: also do not correctly support using `innerHTML` on SVG\n  // namespaced elements. So here a wrapper is used.\n  let wrappedHtml = '<svg>' + html + '</svg>';\n\n  div.innerHTML = wrappedHtml;\n\n  let [first, last] = moveNodesBefore(div.firstChild as Node, parent, reference);\n  return new ConcreteBounds(parent, first, last);\n}\n\nfunction shouldApplyFix(document: Document, svgNamespace: SVG_NAMESPACE) {\n  let svg = document.createElementNS(svgNamespace, 'svg');\n\n  try {\n    svg['insertAdjacentHTML']('beforeEnd', '<circle></circle>');\n  } catch (e) {\n    // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG\n    // Safari: Will throw, insertAdjacentHTML is not present on SVG\n  } finally {\n    // FF: Old versions will create a node in the wrong namespace\n    if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE) {\n      // The test worked as expected, no fix required\n      return false;\n    }\n\n    return true;\n  }\n}\n","import { Bounds } from '../bounds';\nimport { DOMChanges, DOMTreeConstruction } from '../dom/helper';\nimport { Option } from '@glimmer/util';\n\n// Patch:    Adjacent text node merging fix\n// Browsers: IE, Edge, Firefox w/o inspector open\n// Reason:   These browsers will merge adjacent text nodes. For exmaple given\n//           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers\n//           with proper behavior will populate div.childNodes with two items.\n//           These browsers will populate it with one merged node instead.\n// Fix:      Add these nodes to a wrapper element, then iterate the childNodes\n//           of that wrapper and move the nodes to their target location. Note\n//           that potential SVG bugs will have been handled before this fix.\n//           Note that this fix must only apply to the previous text node, as\n//           the base implementation of `insertHTMLBefore` already handles\n//           following text nodes correctly.\nexport function domChanges(document: Option<Document>, DOMChangesClass: typeof DOMChanges): typeof DOMChanges {\n  if (!document) return DOMChangesClass;\n\n  if (!shouldApplyFix(document)) {\n    return DOMChangesClass;\n  }\n\n  return class DOMChangesWithTextNodeMergingFix extends DOMChangesClass {\n    private uselessComment: Comment;\n\n    constructor(document: Document) {\n      super(document);\n      this.uselessComment = document.createComment('');\n    }\n\n    insertHTMLBefore(parent: HTMLElement, nextSibling: Node, html: string): Bounds {\n      if (html === null) {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      let didSetUselessComment = false;\n\n      let nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n      if (nextPrevious && nextPrevious instanceof Text) {\n        didSetUselessComment = true;\n        parent.insertBefore(this.uselessComment, nextSibling);\n      }\n\n      let bounds = super.insertHTMLBefore(parent, nextSibling, html);\n\n      if (didSetUselessComment) {\n        parent.removeChild(this.uselessComment);\n      }\n\n      return bounds;\n    }\n  };\n}\n\nexport function treeConstruction(document: Option<Document>, TreeConstructionClass: typeof DOMTreeConstruction): typeof DOMTreeConstruction {\n  if (!document) return TreeConstructionClass;\n\n  if (!shouldApplyFix(document)) {\n    return TreeConstructionClass;\n  }\n\n  return class TreeConstructionWithTextNodeMergingFix extends TreeConstructionClass {\n    private uselessComment: Comment;\n\n    constructor(document: Document) {\n      super(document);\n      this.uselessComment = this.createComment('') as Comment;\n    }\n\n    insertHTMLBefore(parent: HTMLElement, html: string, reference: Node): Bounds {\n      if (html === null) {\n        return super.insertHTMLBefore(parent, html, reference);\n      }\n\n      let didSetUselessComment = false;\n\n      let nextPrevious = reference ? reference.previousSibling : parent.lastChild;\n      if (nextPrevious && nextPrevious instanceof Text) {\n        didSetUselessComment = true;\n        parent.insertBefore(this.uselessComment, reference);\n      }\n\n      let bounds = super.insertHTMLBefore(parent, html, reference);\n\n      if (didSetUselessComment) {\n        parent.removeChild(this.uselessComment);\n      }\n\n      return bounds;\n    }\n  };\n}\n\nfunction shouldApplyFix(document: Document) {\n  let mergingTextDiv: HTMLDivElement = document.createElement('div');\n\n  mergingTextDiv.innerHTML = 'first';\n  mergingTextDiv.insertAdjacentHTML('beforeEnd', 'second');\n\n  if (mergingTextDiv.childNodes.length === 2) {\n    // It worked as expected, no fix required\n    return false;\n  }\n\n  return true;\n}\n","import { ConcreteBounds, SingleNodeBounds, Bounds } from '../bounds';\nimport {\n  domChanges as domChangesTableElementFix,\n  treeConstruction as treeConstructionTableElementFix\n} from '../compat/inner-html-fix';\nimport {\n  domChanges as domChangesSvgElementFix,\n  treeConstruction as treeConstructionSvgElementFix\n} from '../compat/svg-inner-html-fix';\nimport {\n  domChanges as domChangesNodeMergingFix,\n  treeConstruction as treeConstructionNodeMergingFix\n} from '../compat/text-node-merging-fix';\nimport * as Simple from './interfaces';\n\nimport { Option } from '@glimmer/util';\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n// http://www.w3.org/TR/html/syntax.html#html-integration-point\nconst SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };\n\n// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes\n// TODO: Adjust SVG attributes\n\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\n// TODO: Adjust SVG elements\n\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\nexport const BLACKLIST_TABLE = Object.create(null);\n\n([\n  \"b\", \"big\", \"blockquote\", \"body\", \"br\", \"center\", \"code\", \"dd\", \"div\", \"dl\", \"dt\", \"em\", \"embed\",\n  \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"hr\", \"i\", \"img\", \"li\", \"listing\", \"main\", \"meta\", \"nobr\",\n  \"ol\", \"p\", \"pre\", \"ruby\", \"s\", \"small\", \"span\", \"strong\", \"strike\", \"sub\", \"sup\", \"table\", \"tt\", \"u\",\n  \"ul\", \"var\"\n]).forEach(tag => BLACKLIST_TABLE[tag] = 1);\n\nconst WHITESPACE = /[\\t-\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]/;\n\nlet doc: Option<Document> = typeof document === 'undefined' ? null : document;\n\nexport function isWhitespace(string: string) {\n  return WHITESPACE.test(string);\n}\n\nexport function moveNodesBefore(source: Simple.Node, target: Simple.Element, nextSibling: Simple.Node) {\n  let first = source.firstChild;\n  let last = null;\n  let current = first;\n  while (current) {\n    last = current;\n    current = current.nextSibling;\n    target.insertBefore(last, nextSibling);\n  }\n  return [first, last];\n}\n\nexport namespace DOM {\n  export type Node = Simple.Node;\n  export type Element = Simple.Element;\n  export type Document = Simple.Document;\n  export type Comment = Simple.Comment;\n  export type Text = Simple.Text;\n  export type Namespace = Simple.Namespace;\n  export type HTMLElement = Simple.HTMLElement;\n\n  export class TreeConstruction {\n    protected uselessElement: HTMLElement;\n    constructor(protected document: Document) {\n      this.setupUselessElement();\n    }\n\n    protected setupUselessElement() {\n      this.uselessElement = this.document.createElement('div');\n    }\n\n    createElement(tag: string, context?: Element): Element {\n      let isElementInSVGNamespace, isHTMLIntegrationPoint;\n\n      if (context) {\n        isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE || tag === 'svg';\n        isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];\n      } else {\n        isElementInSVGNamespace = tag === 'svg';\n        isHTMLIntegrationPoint = false;\n      }\n\n      if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {\n        // FIXME: This does not properly handle <font> with color, face, or\n        // size attributes, which is also disallowed by the spec. We should fix\n        // this.\n        if (BLACKLIST_TABLE[tag]) {\n          throw new Error(`Cannot create a ${tag} inside an SVG context`);\n        }\n\n        return this.document.createElementNS(SVG_NAMESPACE as Namespace, tag);\n      } else {\n        return this.document.createElement(tag);\n      }\n    }\n\n    createElementNS(namespace: Namespace, tag: string): Element {\n      return this.document.createElementNS(namespace, tag);\n    }\n\n    setAttribute(element: Element, name: string, value: string, namespace?: string) {\n      if (namespace) {\n        element.setAttributeNS(namespace, name, value);\n      } else {\n        element.setAttribute(name, value);\n      }\n    }\n\n    createTextNode(text: string): Text {\n      return this.document.createTextNode(text);\n    }\n\n    createComment(data: string): Comment {\n      return this.document.createComment(data);\n    }\n\n    insertBefore(parent: Element, node: Node, reference: Option<Node>) {\n      parent.insertBefore(node, reference);\n    }\n\n    insertHTMLBefore(parent: Element, html: string, reference: Option<Node>): Bounds {\n      return insertHTMLBefore(this.uselessElement, parent, reference, html);\n    };\n  }\n\n  let appliedTreeContruction = TreeConstruction;\n  appliedTreeContruction = treeConstructionNodeMergingFix(doc, appliedTreeContruction);\n  appliedTreeContruction = treeConstructionTableElementFix(doc, appliedTreeContruction);\n  appliedTreeContruction = treeConstructionSvgElementFix(doc, appliedTreeContruction, SVG_NAMESPACE);\n\n  export const DOMTreeConstruction = appliedTreeContruction;\n  export type DOMTreeConstruction = TreeConstruction;\n}\n\nexport class DOMChanges {\n  protected namespace: Option<string>;\n  private uselessElement: HTMLElement;\n\n  constructor(protected document: HTMLDocument) {\n    this.namespace = null;\n    this.uselessElement = this.document.createElement('div');\n  }\n\n  setAttribute(element: Simple.Element, name: string, value: string) {\n    element.setAttribute(name, value);\n  }\n\n  setAttributeNS(element: Simple.Element, namespace: string, name: string, value: string) {\n    element.setAttributeNS(namespace, name, value);\n  }\n\n  removeAttribute(element: Simple.Element, name: string) {\n    element.removeAttribute(name);\n  }\n\n  removeAttributeNS(element: Simple.Element, namespace: string, name: string) {\n    element.removeAttributeNS(namespace, name);\n  }\n\n  createTextNode(text: string): Simple.Text {\n    return this.document.createTextNode(text);\n  }\n\n  createComment(data: string): Simple.Comment {\n    return this.document.createComment(data);\n  }\n\n  createElement(tag: string, context?: Simple.Element): Simple.Element {\n    let isElementInSVGNamespace, isHTMLIntegrationPoint;\n\n    if (context) {\n      isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE || tag === 'svg';\n      isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];\n    } else {\n      isElementInSVGNamespace = tag === 'svg';\n      isHTMLIntegrationPoint = false;\n    }\n\n    if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {\n      // FIXME: This does not properly handle <font> with color, face, or\n      // size attributes, which is also disallowed by the spec. We should fix\n      // this.\n      if (BLACKLIST_TABLE[tag]) {\n        throw new Error(`Cannot create a ${tag} inside an SVG context`);\n      }\n\n      return this.document.createElementNS(SVG_NAMESPACE as Simple.Namespace, tag);\n    } else {\n      return this.document.createElement(tag);\n    }\n  }\n\n  insertHTMLBefore(_parent: Element, nextSibling: Node, html: string): Bounds {\n    return insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);\n  }\n\n  insertNodeBefore(parent: Simple.Element, node: Simple.Node, reference: Simple.Node): Bounds {\n    if (isDocumentFragment(node)) {\n      let { firstChild, lastChild } = node;\n      this.insertBefore(parent, node, reference);\n      return new ConcreteBounds(parent, firstChild, lastChild);\n    } else {\n      this.insertBefore(parent, node, reference);\n      return new SingleNodeBounds(parent, node);\n    }\n  }\n\n  insertTextBefore(parent: Simple.Element, nextSibling: Simple.Node, text: string): Simple.Text {\n    let textNode = this.createTextNode(text);\n    this.insertBefore(parent, textNode, nextSibling);\n    return textNode;\n  }\n\n  insertBefore(element: Simple.Element, node: Simple.Node, reference: Option<Simple.Node>) {\n    element.insertBefore(node, reference);\n  }\n\n  insertAfter(element: Simple.Element, node: Simple.Node, reference: Simple.Node) {\n    this.insertBefore(element, node, reference.nextSibling);\n  }\n}\n\nexport function insertHTMLBefore(this: void, _useless: Simple.HTMLElement, _parent: Simple.Element, _nextSibling: Option<Simple.Node>, html: string): Bounds { // tslint:disable-line\n  // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`\n  // only exists on `HTMLElement` but not on `Element`. We actually work with the\n  // newer version of the DOM API here (and monkey-patch this method in `./compat`\n  // when we detect older browsers). This is a hack to work around this limitation.\n  let parent = _parent as HTMLElement;\n  let useless = _useless as HTMLElement;\n  let nextSibling = _nextSibling as Node;\n\n  let prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n  let last;\n\n  if (html === null || html === '') {\n    return new ConcreteBounds(parent, null, null);\n  }\n\n  if (nextSibling === null) {\n    parent.insertAdjacentHTML('beforeEnd', html);\n    last = parent.lastChild;\n  } else if (nextSibling instanceof HTMLElement) {\n    nextSibling.insertAdjacentHTML('beforeBegin', html);\n    last = nextSibling.previousSibling;\n  } else {\n    // Non-element nodes do not support insertAdjacentHTML, so add an\n    // element and call it on that element. Then remove the element.\n    //\n    // This also protects Edge, IE and Firefox w/o the inspector open\n    // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts\n    parent.insertBefore(useless, nextSibling);\n    useless.insertAdjacentHTML('beforeBegin', html);\n    last = useless.previousSibling;\n    parent.removeChild(useless);\n  }\n\n  let first = prev ? prev.nextSibling : parent.firstChild;\n  return new ConcreteBounds(parent, first, last);\n}\n\nfunction isDocumentFragment(node: Simple.Node): node is DocumentFragment {\n  return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n\nlet helper = DOMChanges;\n\nhelper = domChangesNodeMergingFix(doc, helper);\nhelper = domChangesTableElementFix(doc, helper);\nhelper = domChangesSvgElementFix(doc, helper, SVG_NAMESPACE);\n\nexport default helper;\nexport const DOMTreeConstruction = DOM.DOMTreeConstruction;\nexport type DOMTreeConstruction = DOM.DOMTreeConstruction;\nexport { Namespace as DOMNamespace } from './interfaces';\n","import { FIXME, Opaque, Option, Maybe } from '@glimmer/util';\nimport { DOMNamespace } from './helper';\nimport * as Simple from './interfaces';\nimport {\n  sanitizeAttributeValue,\n  requiresSanitization\n} from './sanitized-values';\nimport { normalizeProperty } from './props';\nimport { SVG_NAMESPACE } from './helper';\nimport { normalizeTextValue } from '../compiled/opcodes/content';\nimport { Environment } from '../environment';\n\nexport function defaultManagers(element: Simple.Element, attr: string, _isTrusting: boolean, _namespace: Option<string>): AttributeManager {\n  let tagName = element.tagName;\n  let isSVG = element.namespaceURI === SVG_NAMESPACE;\n\n  if (isSVG) {\n    return defaultAttributeManagers(tagName, attr);\n  }\n\n  let { type, normalized } = normalizeProperty(element, attr);\n\n  if (type === 'attr') {\n    return defaultAttributeManagers(tagName, normalized);\n  } else {\n    return defaultPropertyManagers(tagName, normalized);\n  }\n}\n\nexport function defaultPropertyManagers(tagName: string, attr: string): AttributeManager {\n  if (requiresSanitization(tagName, attr)) {\n    return new SafePropertyManager(attr);\n  }\n\n  if (isUserInputValue(tagName, attr)) {\n    return INPUT_VALUE_PROPERTY_MANAGER;\n  }\n\n  if (isOptionSelected(tagName, attr)) {\n    return OPTION_SELECTED_MANAGER;\n  }\n\n  return new PropertyManager(attr);\n}\n\nexport function defaultAttributeManagers(tagName: string, attr: string): AttributeManager {\n  if (requiresSanitization(tagName, attr)) {\n    return new SafeAttributeManager(attr);\n  }\n\n  return new AttributeManager(attr);\n}\n\nexport function readDOMAttr(element: Element, attr: string) {\n  let isSVG = element.namespaceURI === SVG_NAMESPACE;\n  let { type, normalized } = normalizeProperty(element, attr);\n\n  if (isSVG) {\n    return element.getAttribute(normalized);\n  }\n\n  if (type === 'attr') {\n    return element.getAttribute(normalized);\n  } {\n    return element[normalized];\n  }\n};\n\nexport class AttributeManager {\n  constructor(public attr: string) {}\n\n  setAttribute(env: Environment, element: Simple.Element, value: Opaque, namespace?: DOMNamespace) {\n    let dom = env.getAppendOperations();\n    let normalizedValue = normalizeAttributeValue(value);\n\n    if (!isAttrRemovalValue(normalizedValue)) {\n      dom.setAttribute(element, this.attr, normalizedValue, namespace);\n    }\n  }\n\n  updateAttribute(env: Environment, element: Element, value: Opaque, namespace?: DOMNamespace) {\n    if (value === null || value === undefined || value === false) {\n      if (namespace) {\n        env.getDOM().removeAttributeNS(element, namespace, this.attr);\n      } else {\n        env.getDOM().removeAttribute(element, this.attr);\n      }\n    } else {\n      this.setAttribute(env, element, value);\n    }\n  }\n};\n\nexport class PropertyManager extends AttributeManager {\n  setAttribute(_env: Environment, element: Simple.Element, value: Opaque, _namespace?: DOMNamespace) {\n    if (!isAttrRemovalValue(value)) {\n      element[this.attr] = value;\n    }\n  }\n\n  protected removeAttribute(env: Environment, element: Element, namespace?: DOMNamespace) {\n    // TODO this sucks but to preserve properties first and to meet current\n    // semantics we must do this.\n    let { attr } = this;\n    if (namespace) {\n      env.getDOM().removeAttributeNS(element, namespace, attr);\n    } else {\n      env.getDOM().removeAttribute(element, attr);\n    }\n  }\n\n  updateAttribute(env: Environment, element: Element, value: Opaque, namespace?: DOMNamespace) {\n    // ensure the property is always updated\n    element[this.attr] = value;\n\n    if (isAttrRemovalValue(value)) {\n      this.removeAttribute(env, element, namespace);\n    }\n  }\n};\n\nfunction normalizeAttributeValue(value: Opaque): Option<string> {\n  if (value === false || value === undefined || value === null) {\n    return null;\n  }\n  if (value === true) {\n    return '';\n  }\n  // onclick function etc in SSR\n  if (typeof value === 'function') {\n    return null;\n  }\n\n  return String(value);\n}\n\nfunction isAttrRemovalValue<T>(value: Maybe<T>): value is (null | undefined) {\n  return value === null || value === undefined;\n}\n\nclass SafePropertyManager extends PropertyManager {\n  setAttribute(env: Environment, element: Simple.Element, value: Opaque) {\n    super.setAttribute(env, element, sanitizeAttributeValue(env, element, this.attr, value));\n  }\n\n  updateAttribute(env: Environment, element: Element, value: Opaque) {\n    super.updateAttribute(env, element, sanitizeAttributeValue(env, element, this.attr, value));\n  }\n}\n\nfunction isUserInputValue(tagName: string, attribute: string) {\n  return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';\n}\n\nclass InputValuePropertyManager extends AttributeManager {\n  setAttribute(_env: Environment, element: Simple.Element, value: Opaque) {\n    let input = element as FIXME<HTMLInputElement, \"This breaks SSR\">;\n    input.value = normalizeTextValue(value);\n  }\n\n  updateAttribute(_env: Environment, element: Element, value: Opaque) {\n    let input = <HTMLInputElement>element;\n    let currentValue = input.value;\n    let normalizedValue = normalizeTextValue(value);\n    if (currentValue !== normalizedValue) {\n      input.value = normalizedValue;\n    }\n  }\n}\n\nexport const INPUT_VALUE_PROPERTY_MANAGER: AttributeManager = new InputValuePropertyManager('value');\n\nfunction isOptionSelected(tagName: string, attribute: string) {\n  return tagName === 'OPTION' && attribute === 'selected';\n}\n\nclass OptionSelectedManager extends PropertyManager {\n  setAttribute(_env: Environment, element: Simple.Element, value: Opaque) {\n    if (value !== null && value !== undefined && value !== false) {\n      let option = <HTMLOptionElement>element;\n      option.selected = true;\n    }\n  }\n\n  updateAttribute(_env: Environment, element: Element, value: Opaque) {\n    let option = <HTMLOptionElement>element;\n\n    if (value) {\n      option.selected = true;\n    } else {\n      option.selected = false;\n    }\n  }\n}\n\nexport const OPTION_SELECTED_MANAGER: AttributeManager = new OptionSelectedManager('selected');\n\nclass SafeAttributeManager extends AttributeManager {\n  setAttribute(env: Environment, element: Element, value: Opaque) {\n    super.setAttribute(env, element, sanitizeAttributeValue(env, element, this.attr, value));\n  }\n\n  updateAttribute(env: Environment, element: Element, value: Opaque, _namespace?: DOMNamespace) {\n    super.updateAttribute(env, element, sanitizeAttributeValue(env, element, this.attr, value));\n  }\n}\n","import { VersionedPathReference } from '@glimmer/reference';\nimport { Blocks, Inlines, populateBuiltins } from './syntax/functions';\n\nimport { Constants } from './environment/constants';\n\nimport * as Simple from './dom/interfaces';\nimport { DOMChanges, DOMTreeConstruction } from './dom/helper';\nimport { Reference, OpaqueIterable } from '@glimmer/reference';\nimport { UNDEFINED_REFERENCE, ConditionalReference } from './references';\nimport {\n  defaultManagers,\n  AttributeManager\n} from './dom/attribute-managers';\n\nimport {\n  PartialDefinition\n} from './partial';\n\nimport {\n  Component,\n  ComponentManager,\n  ComponentDefinition\n} from './component/interfaces';\n\nimport {\n  ModifierManager\n} from './modifier/interfaces';\n\nimport {\n  Dict,\n  Option,\n  Destroyable,\n  Opaque,\n  HasGuid,\n  ensureGuid,\n} from '@glimmer/util';\n\nimport {\n  TemplateMeta\n} from '@glimmer/wire-format';\n\nimport { Block } from './scanner';\n\nimport { PublicVM } from './vm/append';\n\nimport { IArguments } from './vm/arguments';\n\nexport type ScopeSlot = VersionedPathReference<Opaque> | Option<Block>;\n\nexport interface DynamicScope {\n  get(key: string): VersionedPathReference<Opaque>;\n  set(key: string, reference: VersionedPathReference<Opaque>): VersionedPathReference<Opaque>;\n  child(): DynamicScope;\n}\n\nexport class Scope {\n  static root(self: VersionedPathReference<Opaque>, size = 0) {\n    let refs: VersionedPathReference<Opaque>[] = new Array(size + 1);\n\n    for (let i = 0; i <= size; i++) {\n      refs[i] = UNDEFINED_REFERENCE;\n    }\n\n    return new Scope(refs).init({ self });\n  }\n\n  static sized(size = 0) {\n    let refs: VersionedPathReference<Opaque>[] = new Array(size + 1);\n\n    for (let i = 0; i <= size; i++) {\n      refs[i] = UNDEFINED_REFERENCE;\n    }\n\n    return new Scope(refs);\n  }\n\n  constructor(\n    // the 0th slot is `self`\n    private slots: ScopeSlot[],\n    private callerScope: Option<Scope> = null,\n    // named arguments and blocks passed to a layout that uses eval\n    private evalScope: Option<Dict<ScopeSlot>> = null,\n    // locals in scope when the partial was invoked\n    private partialMap: Option<Dict<VersionedPathReference<Opaque>>> = null) {\n  }\n\n  init({ self }: { self: VersionedPathReference<Opaque> }): this {\n    this.slots[0] = self;\n    return this;\n  }\n\n  getSelf(): VersionedPathReference<Opaque> {\n    return this.get<VersionedPathReference<Opaque>>(0);\n  }\n\n  getSymbol(symbol: number): VersionedPathReference<Opaque> {\n    return this.get<VersionedPathReference<Opaque>>(symbol);\n  }\n\n  getBlock(symbol: number): Block {\n    return this.get<Block>(symbol);\n  }\n\n  getEvalScope(): Option<Dict<ScopeSlot>> {\n    return this.evalScope;\n  }\n\n  getPartialMap(): Option<Dict<VersionedPathReference<Opaque>>> {\n    return this.partialMap;\n  }\n\n  bind(symbol: number, value: ScopeSlot) {\n    this.set(symbol, value);\n  }\n\n  bindSelf(self: VersionedPathReference<Opaque>) {\n    this.set<VersionedPathReference<Opaque>>(0, self);\n  }\n\n  bindSymbol(symbol: number, value: VersionedPathReference<Opaque>) {\n    this.set<VersionedPathReference<Opaque>>(symbol, value);\n  }\n\n  bindBlock(symbol: number, value: Option<Block>) {\n    this.set<Option<Block>>(symbol, value);\n  }\n\n  bindEvalScope(map: Option<Dict<ScopeSlot>>) {\n    this.evalScope = map;\n  }\n\n  bindPartialMap(map: Dict<VersionedPathReference<Opaque>>) {\n    this.partialMap = map;\n  }\n\n  bindCallerScope(scope: Option<Scope>) {\n    this.callerScope = scope;\n  }\n\n  getCallerScope(): Option<Scope> {\n    return this.callerScope;\n  }\n\n  child(): Scope {\n    return new Scope(this.slots.slice(), this.callerScope, this.evalScope, this.partialMap);\n  }\n\n  private get<T>(index: number): T {\n    if (index >= this.slots.length) {\n      throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    }\n\n    return this.slots[index] as any as T;\n  }\n\n  private set<T>(index: number, value: T): void {\n    if (index >= this.slots.length) {\n      throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    }\n\n    this.slots[index] = value as any;\n  }\n}\n\nclass Transaction {\n  public scheduledInstallManagers: ModifierManager<Opaque>[] = [];\n  public scheduledInstallModifiers: Object[] = [];\n  public scheduledUpdateModifierManagers: ModifierManager<Opaque>[] = [];\n  public scheduledUpdateModifiers: Object[] = [];\n  public createdComponents: Component[] = [];\n  public createdManagers: ComponentManager<Component>[] = [];\n  public updatedComponents: Component[] = [];\n  public updatedManagers: ComponentManager<Component>[] = [];\n  public destructors: Destroyable[] = [];\n\n  didCreate<T>(component: T, manager: ComponentManager<T>) {\n    this.createdComponents.push(component);\n    this.createdManagers.push(manager);\n  }\n\n  didUpdate<T>(component: T, manager: ComponentManager<T>) {\n    this.updatedComponents.push(component);\n    this.updatedManagers.push(manager);\n  }\n\n  scheduleInstallModifier<T>(modifier: T, manager: ModifierManager<T>) {\n    this.scheduledInstallManagers.push(manager);\n    this.scheduledInstallModifiers.push(modifier);\n  }\n\n  scheduleUpdateModifier<T>(modifier: T, manager: ModifierManager<T>) {\n    this.scheduledUpdateModifierManagers.push(manager);\n    this.scheduledUpdateModifiers.push(modifier);\n  }\n\n  didDestroy(d: Destroyable) {\n    this.destructors.push(d);\n  }\n\n  commit() {\n    let { createdComponents, createdManagers } = this;\n\n    for (let i=0; i<createdComponents.length; i++) {\n      let component = createdComponents[i];\n      let manager = createdManagers[i];\n      manager.didCreate(component);\n    }\n\n    let { updatedComponents, updatedManagers } = this;\n\n    for (let i=0; i<updatedComponents.length; i++) {\n      let component = updatedComponents[i];\n      let manager = updatedManagers[i];\n      manager.didUpdate(component);\n    }\n\n    let { destructors } = this;\n\n    for (let i=0; i<destructors.length; i++) {\n      destructors[i].destroy();\n    }\n\n    let { scheduledInstallManagers, scheduledInstallModifiers } = this;\n\n    for (let i = 0; i < scheduledInstallManagers.length; i++) {\n      let manager = scheduledInstallManagers[i];\n      let modifier = scheduledInstallModifiers[i];\n      manager.install(modifier);\n    }\n\n    let { scheduledUpdateModifierManagers, scheduledUpdateModifiers } = this;\n\n    for (let i = 0; i < scheduledUpdateModifierManagers.length; i++) {\n      let manager = scheduledUpdateModifierManagers[i];\n      let modifier = scheduledUpdateModifiers[i];\n      manager.update(modifier);\n    }\n  }\n}\n\nexport class Opcode {\n  public offset = 0;\n  constructor(private array: Uint32Array | Array<number>) {}\n\n  get type() {\n    return this.array[this.offset];\n  }\n\n  get op1() {\n    return this.array[this.offset + 1];\n  }\n\n  get op2() {\n    return this.array[this.offset + 2];\n  }\n\n  get op3() {\n    return this.array[this.offset + 3];\n  }\n}\n\nexport class Program {\n  [key: number]: never;\n\n  private opcodes: number[] = [];\n  private _offset = 0;\n  private _opcode: Opcode;\n\n  constructor() {\n    this._opcode = new Opcode(this.opcodes);\n  }\n\n  get next(): number {\n    return this._offset;\n  }\n\n  get current(): number {\n    return this._offset - 4;\n  }\n\n  opcode(offset: number): Opcode {\n    this._opcode.offset = offset;\n    return this._opcode;\n  }\n\n  set(pos: number, type: number, op1 = 0, op2 = 0, op3 = 0) {\n    this.opcodes[pos] = type;\n    this.opcodes[pos + 1] = op1;\n    this.opcodes[pos + 2] = op2;\n    this.opcodes[pos + 3] = op3;\n  }\n\n  push(type: number, op1 = 0, op2 = 0, op3 = 0): number {\n    let offset = this._offset;\n    this.opcodes[this._offset++] = type;\n    this.opcodes[this._offset++] = op1;\n    this.opcodes[this._offset++] = op2;\n    this.opcodes[this._offset++] = op3;\n    return offset;\n  }\n}\n\nexport abstract class Environment {\n  protected updateOperations: DOMChanges;\n  protected appendOperations: DOMTreeConstruction;\n  private _macros: Option<{ blocks: Blocks, inlines: Inlines }> = null;\n  private _transaction: Option<Transaction> = null;\n  public constants: Constants = new Constants();\n  public program = new Program();\n\n  constructor({ appendOperations, updateOperations }: { appendOperations: DOMTreeConstruction, updateOperations: DOMChanges }) {\n    this.appendOperations = appendOperations;\n    this.updateOperations = updateOperations;\n  }\n\n  toConditionalReference(reference: Reference<Opaque>): Reference<boolean> {\n    return new ConditionalReference(reference);\n  }\n\n  abstract iterableFor(reference: Reference<Opaque>, key: string): OpaqueIterable;\n  abstract protocolForURL(s: string): string;\n\n  getAppendOperations(): DOMTreeConstruction { return this.appendOperations; }\n  getDOM(): DOMChanges { return this.updateOperations; }\n\n  getIdentity(object: HasGuid): string {\n    return ensureGuid(object) + '';\n  }\n\n  begin() {\n    this._transaction = new Transaction();\n  }\n\n  private get transaction(): Transaction {\n    return this._transaction;\n  }\n\n  didCreate<T>(component: T, manager: ComponentManager<T>) {\n    this.transaction.didCreate(component, manager);\n  }\n\n  didUpdate<T>(component: T, manager: ComponentManager<T>) {\n    this.transaction.didUpdate(component, manager);\n  }\n\n  scheduleInstallModifier<T>(modifier: T, manager: ModifierManager<T>) {\n    this.transaction.scheduleInstallModifier(modifier, manager);\n  }\n\n  scheduleUpdateModifier<T>(modifier: T, manager: ModifierManager<T>) {\n    this.transaction.scheduleUpdateModifier(modifier, manager);\n  }\n\n  didDestroy(d: Destroyable) {\n    this.transaction.didDestroy(d);\n  }\n\n  commit() {\n    this.transaction.commit();\n    this._transaction = null;\n  }\n\n  attributeFor(element: Simple.Element, attr: string, isTrusting: boolean, namespace?: string): AttributeManager {\n    return defaultManagers(element, attr, isTrusting, namespace === undefined ? null : namespace);\n  }\n\n  macros(): { blocks: Blocks, inlines: Inlines } {\n    let macros = this._macros;\n    if (!macros) {\n      this._macros = macros = this.populateBuiltins();\n    }\n\n    return macros;\n  }\n\n  populateBuiltins(): { blocks: Blocks, inlines: Inlines } {\n    return populateBuiltins();\n  }\n\n  abstract hasHelper(helperName: string, meta: TemplateMeta): boolean;\n  abstract lookupHelper(helperName: string, meta: TemplateMeta): Helper;\n\n  abstract hasModifier(modifierName: string, meta: TemplateMeta): boolean;\n  abstract lookupModifier(modifierName: string, meta: TemplateMeta): ModifierManager<Opaque>;\n\n  abstract hasComponentDefinition(tagName: string, meta: TemplateMeta): boolean;\n  abstract getComponentDefinition(tagName: string, meta: TemplateMeta): ComponentDefinition<Opaque>;\n\n  abstract hasPartial(partialName: string, meta: TemplateMeta): boolean;\n  abstract lookupPartial(PartialName: string, meta: TemplateMeta): PartialDefinition<TemplateMeta>;\n}\n\nexport default Environment;\n\nexport interface Helper {\n  (vm: PublicVM, args: IArguments): VersionedPathReference<Opaque>;\n}\n","import { Scope, DynamicScope, Environment } from '../environment';\nimport { DestroyableBounds, clear, move as moveBounds } from '../bounds';\nimport { ElementStack, Tracker, UpdatableTracker } from '../builder';\nimport { Option, Opaque, Stack, LinkedList, Dict, dict, expect } from '@glimmer/util';\nimport {\n  PathReference,\n  IterationArtifacts,\n  IteratorSynchronizer,\n  IteratorSynchronizerDelegate,\n\n  // Tags\n  combine,\n  Revision,\n  UpdatableTag,\n  TagWrapper,\n  combineSlice,\n  CONSTANT_TAG,\n  INITIAL\n} from '@glimmer/reference';\nimport { OpcodeJSON, UpdatingOpcode, UpdatingOpSeq } from '../opcodes';\nimport { Constants } from '../environment/constants';\nimport { DOMChanges } from '../dom/helper';\nimport * as Simple from '../dom/interfaces';\n\nimport VM, { CapturedStack, EvaluationStack } from './append';\n\nexport default class UpdatingVM {\n  public env: Environment;\n  public dom: DOMChanges;\n  public alwaysRevalidate: boolean;\n  public constants: Constants;\n\n  private frameStack: Stack<UpdatingVMFrame> = new Stack<UpdatingVMFrame>();\n\n  constructor(env: Environment, { alwaysRevalidate = false }) {\n    this.env = env;\n    this.constants = env.constants;\n    this.dom = env.getDOM();\n    this.alwaysRevalidate = alwaysRevalidate;\n  }\n\n  execute(opcodes: UpdatingOpSeq, handler: ExceptionHandler) {\n    let { frameStack } = this;\n\n    this.try(opcodes, handler);\n\n    while (true) {\n      if (frameStack.isEmpty()) break;\n\n      let opcode = this.frame.nextStatement();\n\n      if (opcode === null) {\n        this.frameStack.pop();\n        continue;\n      }\n\n      opcode.evaluate(this);\n    }\n  }\n\n  private get frame() {\n    return this.frameStack.current;\n  }\n\n  goto(op: UpdatingOpcode) {\n    this.frame.goto(op);\n  }\n\n  try(ops: UpdatingOpSeq, handler: Option<ExceptionHandler>) {\n    this.frameStack.push(new UpdatingVMFrame(this, ops, handler));\n  }\n\n  throw() {\n    this.frame.handleException();\n    this.frameStack.pop();\n  }\n\n  evaluateOpcode(opcode: UpdatingOpcode) {\n    opcode.evaluate(this);\n  }\n}\n\nexport interface ExceptionHandler {\n  handleException(): void;\n}\n\nexport interface VMState {\n  env: Environment;\n  scope: Scope;\n  dynamicScope: DynamicScope;\n  stack: CapturedStack;\n}\n\nexport abstract class BlockOpcode extends UpdatingOpcode implements DestroyableBounds {\n  public type = \"block\";\n  public next = null;\n  public prev = null;\n  public children: LinkedList<UpdatingOpcode>;\n\n  protected env: Environment;\n  protected scope: Scope;\n  protected dynamicScope: DynamicScope;\n  protected stack: CapturedStack;\n  protected bounds: DestroyableBounds;\n\n  constructor(public start: number, state: VMState, bounds: DestroyableBounds, children: LinkedList<UpdatingOpcode>) {\n    super();\n    let { env, scope, dynamicScope, stack } = state;\n    this.children = children;\n    this.env = env;\n    this.scope = scope;\n    this.dynamicScope = dynamicScope;\n    this.stack = stack;\n    this.bounds = bounds;\n  }\n\n  abstract didInitializeChildren(): void;\n\n  parentElement() {\n    return this.bounds.parentElement();\n  }\n\n  firstNode() {\n    return this.bounds.firstNode();\n  }\n\n  lastNode() {\n    return this.bounds.lastNode();\n  }\n\n  evaluate(vm: UpdatingVM) {\n    vm.try(this.children, null);\n  }\n\n  destroy() {\n    this.bounds.destroy();\n  }\n\n  didDestroy() {\n    this.env.didDestroy(this.bounds);\n  }\n}\n\nexport class TryOpcode extends BlockOpcode implements ExceptionHandler {\n  public type = \"try\";\n\n  private _tag: TagWrapper<UpdatableTag>;\n\n  protected bounds: UpdatableTracker;\n\n  constructor(start: number, state: VMState, bounds: UpdatableTracker, children: LinkedList<UpdatingOpcode>) {\n    super(start, state, bounds, children);\n    this.tag = this._tag = UpdatableTag.create(CONSTANT_TAG);\n  }\n\n  didInitializeChildren() {\n    this._tag.inner.update(combineSlice(this.children));\n  }\n\n  evaluate(vm: UpdatingVM) {\n    vm.try(this.children, this);\n  }\n\n  handleException() {\n    let { env, bounds, children, scope, dynamicScope, start, stack, prev, next } = this;\n\n    children.clear();\n\n    let elementStack = ElementStack.resume(\n      env,\n      bounds,\n      bounds.reset(env)\n    );\n\n    let vm = new VM(env, scope, dynamicScope, elementStack);\n\n    let updating = new LinkedList<UpdatingOpcode>();\n\n    vm.execute(start, vm => {\n      vm.stack = EvaluationStack.restore(stack);\n      vm.updatingOpcodeStack.push(updating);\n      vm.updateWith(this);\n      vm.updatingOpcodeStack.push(children);\n    });\n\n    this.prev = prev;\n    this.next = next;\n  }\n}\n\nclass ListRevalidationDelegate implements IteratorSynchronizerDelegate {\n  private map: Dict<BlockOpcode>;\n  private updating: LinkedList<UpdatingOpcode>;\n\n  private didInsert = false;\n  private didDelete = false;\n\n  constructor(private opcode: ListBlockOpcode, private marker: Simple.Comment) {\n    this.map = opcode.map;\n    this.updating = opcode['children'];\n  }\n\n  insert(key: string, item: PathReference<Opaque>, memo: PathReference<Opaque>, before: string) {\n    let { map, opcode, updating } = this;\n    let nextSibling: Option<Simple.Node> = null;\n    let reference: Option<BlockOpcode> = null;\n\n    if (before) {\n      reference = map[before];\n      nextSibling = reference['bounds'].firstNode();\n    } else {\n      nextSibling = this.marker;\n    }\n\n    let vm = opcode.vmForInsertion(nextSibling);\n    let tryOpcode: Option<TryOpcode> = null;\n\n    let { start } = opcode;\n\n    vm.execute(start, vm => {\n      map[key] = tryOpcode = vm.iterate(memo, item);\n      vm.updatingOpcodeStack.push(new LinkedList<UpdatingOpcode>());\n      vm.updateWith(tryOpcode);\n      vm.updatingOpcodeStack.push(tryOpcode.children);\n    });\n\n    updating.insertBefore(tryOpcode!, reference);\n\n    this.didInsert = true;\n  }\n\n  retain(_key: string, _item: PathReference<Opaque>, _memo: PathReference<Opaque>) {\n  }\n\n  move(key: string, _item: PathReference<Opaque>, _memo: PathReference<Opaque>, before: string) {\n    let { map, updating } = this;\n\n    let entry = map[key];\n    let reference = map[before] || null;\n\n    if (before) {\n      moveBounds(entry, reference.firstNode());\n    } else {\n      moveBounds(entry, this.marker);\n    }\n\n    updating.remove(entry);\n    updating.insertBefore(entry, reference);\n  }\n\n  delete(key: string) {\n    let { map } = this;\n    let opcode = map[key];\n    opcode.didDestroy();\n    clear(opcode);\n    this.updating.remove(opcode);\n    delete map[key];\n\n    this.didDelete = true;\n  }\n\n  done() {\n    this.opcode.didInitializeChildren(this.didInsert || this.didDelete);\n  }\n}\n\nexport class ListBlockOpcode extends BlockOpcode {\n  public type = \"list-block\";\n  public map = dict<BlockOpcode>();\n  public artifacts: IterationArtifacts;\n\n  private lastIterated: Revision = INITIAL;\n  private _tag: TagWrapper<UpdatableTag>;\n\n  constructor(start: number, state: VMState, bounds: Tracker, children: LinkedList<UpdatingOpcode>, artifacts: IterationArtifacts) {\n    super(start, state, bounds, children);\n    this.artifacts = artifacts;\n    let _tag = this._tag = UpdatableTag.create(CONSTANT_TAG);\n    this.tag = combine([artifacts.tag, _tag]);\n  }\n\n  didInitializeChildren(listDidChange = true) {\n    this.lastIterated = this.artifacts.tag.value();\n\n    if (listDidChange) {\n      this._tag.inner.update(combineSlice(this.children));\n    }\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { artifacts, lastIterated } = this;\n\n    if (!artifacts.tag.validate(lastIterated)) {\n      let { bounds } = this;\n      let { dom } = vm;\n\n      let marker = dom.createComment('');\n      dom.insertAfter(bounds.parentElement(), marker, bounds.lastNode());\n\n      let target = new ListRevalidationDelegate(this, marker);\n      let synchronizer = new IteratorSynchronizer({ target, artifacts });\n\n      synchronizer.sync();\n\n      this.parentElement().removeChild(marker);\n    }\n\n    // Run now-updated updating opcodes\n    super.evaluate(vm);\n  }\n\n  vmForInsertion(nextSibling: Option<Simple.Node>): VM {\n    let { env, scope, dynamicScope } = this;\n\n    let elementStack = ElementStack.forInitialRender(\n      this.env,\n      this.bounds.parentElement(),\n      nextSibling\n    );\n\n    return new VM(env, scope, dynamicScope, elementStack);\n  }\n}\n\nclass UpdatingVMFrame {\n  private current: Option<UpdatingOpcode>;\n\n  constructor(private vm: UpdatingVM, private ops: UpdatingOpSeq, private exceptionHandler: Option<ExceptionHandler>) {\n    this.vm = vm;\n    this.ops = ops;\n    this.current = ops.head();\n  }\n\n  goto(op: UpdatingOpcode) {\n    this.current = op;\n  }\n\n  nextStatement(): Option<UpdatingOpcode> {\n    let { current, ops } = this;\n    if (current) this.current = ops.nextNode(current);\n    return current;\n  }\n\n  handleException() {\n    if (this.exceptionHandler) {\n      this.exceptionHandler.handleException();\n    }\n  }\n}\n","import { Option, LinkedList } from '@glimmer/util';\nimport Environment from '../environment';\nimport { DestroyableBounds, clear } from '../bounds';\nimport UpdatingVM, { ExceptionHandler } from './update';\nimport { UpdatingOpcode } from '../opcodes';\nimport * as Simple from '../dom/interfaces';\n\nexport default class RenderResult implements DestroyableBounds, ExceptionHandler {\n  constructor(\n    private env: Environment,\n    private updating: LinkedList<UpdatingOpcode>,\n    private bounds: DestroyableBounds\n  ) {}\n\n  rerender({ alwaysRevalidate = false } = { alwaysRevalidate: false }) {\n    let { env, updating } = this;\n    let vm = new UpdatingVM(env, { alwaysRevalidate });\n    vm.execute(updating, this);\n  }\n\n  parentElement(): Simple.Element {\n    return this.bounds.parentElement();\n  }\n\n  firstNode(): Option<Simple.Node> {\n    return this.bounds.firstNode();\n  }\n\n  lastNode(): Option<Simple.Node> {\n    return this.bounds.lastNode();\n  }\n\n  opcodes(): LinkedList<UpdatingOpcode> {\n    return this.updating;\n  }\n\n  handleException() {\n    throw \"this should never happen\";\n  }\n\n  destroy() {\n    this.bounds.destroy();\n    clear(this.bounds);\n  }\n}\n","import { Register } from '../opcodes';\nimport { Scope, DynamicScope, Environment, Opcode } from '../environment';\nimport { ElementStack } from '../builder';\nimport { Option, Destroyable, Stack, LinkedList, ListSlice, Opaque } from '@glimmer/util';\nimport { ReferenceIterator, PathReference, VersionedPathReference, combineSlice } from '@glimmer/reference';\nimport { CompiledDynamicProgram } from '../compiled/blocks';\nimport { LabelOpcode, JumpIfNotModifiedOpcode, DidModifyOpcode } from '../compiled/opcodes/vm';\nimport { VMState, ListBlockOpcode, TryOpcode, BlockOpcode } from './update';\nimport RenderResult from './render-result';\n\nimport {\n  APPEND_OPCODES,\n  UpdatingOpcode\n} from '../opcodes';\n\nimport {\n  Constants,\n  ConstantString\n} from '../environment/constants';\n\nexport interface PublicVM {\n  env: Environment;\n  dynamicScope(): DynamicScope;\n  getSelf(): PathReference<Opaque>;\n  newDestroyable(d: Destroyable): void;\n}\n\nexport type CapturedStack = Opaque[];\n\nexport class EvaluationStack {\n  static empty(): EvaluationStack {\n    return new this([], 0, -1);\n  }\n\n  static restore(snapshot: CapturedStack): EvaluationStack {\n    return new this(snapshot.slice(), 0, snapshot.length - 1);\n  }\n\n  constructor(private stack: Opaque[], public fp: number, public sp: number) {\n    Object.seal(this);\n  }\n\n  isEmpty() {\n    return this.sp === -1;\n  }\n\n  push(value: Opaque): void {\n    this.stack[++this.sp] = value;\n  }\n\n  dup(position = this.sp): void {\n    this.push(this.stack[position]);\n  }\n\n  pop<T>(n = 1): T {\n    let top = this.stack[this.sp] as T;\n    this.sp -= n;\n    return top;\n  }\n\n  peek<T>(): T {\n    return this.stack[this.sp] as T;\n  }\n\n  fromBase<T>(offset: number): T {\n    return this.stack[this.fp - offset] as T;\n  }\n\n  fromTop<T>(offset: number): T {\n    return this.stack[this.sp - offset] as T;\n  }\n\n  capture(items: number): CapturedStack {\n    let end = this.sp + 1;\n    let start = end - items;\n    return this.stack.slice(start, end);\n  }\n\n  toArray() {\n    return this.stack.slice(this.fp, this.sp + 1);\n  }\n}\n\nexport type IteratorResult<T> = {\n  done: false;\n  value: null;\n} | {\n  done: true;\n  value: T;\n};\n\nexport default class VM implements PublicVM {\n  private dynamicScopeStack = new Stack<DynamicScope>();\n  private scopeStack = new Stack<Scope>();\n  public updatingOpcodeStack = new Stack<LinkedList<UpdatingOpcode>>();\n  public cacheGroups = new Stack<Option<UpdatingOpcode>>();\n  public listBlockStack = new Stack<ListBlockOpcode>();\n  public constants: Constants;\n\n  public stack = EvaluationStack.empty();\n\n  /** Registers **/\n\n  private pc = -1;\n  private ra = -1;\n\n  private get fp(): number {\n    return this.stack.fp;\n  }\n\n  private set fp(fp: number) {\n    this.stack.fp = fp;\n  }\n\n  private get sp(): number {\n    return this.stack.sp;\n  }\n\n  private set sp(sp: number) {\n    this.stack.sp = sp;\n  }\n\n  public s0: any = null;\n  public s1: any = null;\n  public t0: any = null;\n  public t1: any = null;\n\n  // Fetch a value from a register onto the stack\n  fetch(register: Register) {\n    this.stack.push(this[Register[register]]);\n  }\n\n  // Load a value from the stack into a register\n  load(register: Register) {\n    this[Register[register]] = this.stack.pop();\n  }\n\n  // Fetch a value from a register\n  fetchValue<T>(register: Register): T {\n    return this[Register[register]];\n  }\n\n  // Load a value into a register\n  loadValue<T>(register: Register, value: T) {\n    this[Register[register]] = value;\n  }\n\n  // Start a new frame and save $ra and $fp on the stack\n  pushFrame() {\n    this.stack.push(this.ra);\n    this.stack.push(this.fp);\n    this.fp = this.sp - 1;\n    // this.fp = this.sp + 1;\n  }\n\n  // Restore $ra, $sp and $fp\n  popFrame() {\n    this.sp = this.fp - 1;\n    this.ra = this.stack.fromBase<number>(0);\n    this.fp = this.stack.fromBase<number>(-1);\n  }\n\n  // Jump to an address in `program`\n  goto(pc: number) {\n    this.pc = pc;\n  }\n\n  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n  call(pc: number) {\n    this.ra = this.pc;\n    this.pc = pc;\n  }\n\n  // Put a specific `program` address in $ra\n  returnTo(ra: number) {\n    this.ra = ra;\n  }\n\n  // Return to the `program` address stored in $ra\n  return() {\n    this.pc = this.ra;\n  }\n\n  static initial(\n    env: Environment,\n    self: PathReference<Opaque>,\n    dynamicScope: DynamicScope,\n    elementStack: ElementStack,\n    program: CompiledDynamicProgram\n  ) {\n    let scope = Scope.root(self, program.symbolTable.symbols.length);\n    let vm = new VM(env, scope, dynamicScope, elementStack);\n    vm.pc = program.start;\n    vm.updatingOpcodeStack.push(new LinkedList<UpdatingOpcode>());\n    return vm;\n  }\n\n  constructor(\n    public env: Environment,\n    scope: Scope,\n    dynamicScope: DynamicScope,\n    private elementStack: ElementStack,\n  ) {\n    this.env = env;\n    this.constants = env.constants;\n    this.elementStack = elementStack;\n    this.scopeStack.push(scope);\n    this.dynamicScopeStack.push(dynamicScope);\n  }\n\n  capture(args: number): VMState {\n    return {\n      env: this.env,\n      scope: this.scope(),\n      dynamicScope: this.dynamicScope(),\n      stack: this.stack.capture(args)\n    };\n  }\n\n  beginCacheGroup() {\n    this.cacheGroups.push(this.updating().tail());\n  }\n\n  commitCacheGroup() {\n    //        JumpIfNotModified(END)\n    //        (head)\n    //        (....)\n    //        (tail)\n    //        DidModify\n    // END:   Noop\n\n    let END = new LabelOpcode(\"END\");\n\n    let opcodes = this.updating();\n    let marker = this.cacheGroups.pop();\n    let head = marker ? opcodes.nextNode(marker) : opcodes.head();\n    let tail = opcodes.tail();\n    let tag = combineSlice(new ListSlice(head, tail));\n\n    let guard = new JumpIfNotModifiedOpcode(tag, END);\n\n    opcodes.insertBefore(guard, head);\n    opcodes.append(new DidModifyOpcode(guard));\n    opcodes.append(END);\n  }\n\n  enter(args: number) {\n    let updating = new LinkedList<UpdatingOpcode>();\n\n    let state = this.capture(args);\n    let tracker = this.elements().pushUpdatableBlock();\n\n    let tryOpcode = new TryOpcode(this.pc, state, tracker, updating);\n\n    this.didEnter(tryOpcode);\n  }\n\n  iterate(memo: VersionedPathReference<Opaque>, value: VersionedPathReference<Opaque>, updating = new LinkedList<UpdatingOpcode>()): TryOpcode {\n    let stack = this.stack;\n    stack.push(value);\n    stack.push(memo);\n\n    let state = this.capture(2);\n    let tracker = this.elements().pushUpdatableBlock();\n\n    // let ip = this.ip;\n    // this.ip = end + 4;\n    // this.frames.push(ip);\n\n    return new TryOpcode(this.pc, state, tracker, updating);\n  }\n\n  enterItem(key: string, opcode: TryOpcode) {\n    this.listBlock().map[key] = opcode;\n    this.didEnter(opcode);\n  }\n\n  enterList(start: number) {\n    let updating = new LinkedList<BlockOpcode>();\n\n    let state = this.capture(0);\n    let tracker = this.elements().pushBlockList(updating);\n    let artifacts = this.stack.peek<ReferenceIterator>().artifacts;\n\n    let opcode = new ListBlockOpcode(start, state, tracker, updating, artifacts);\n\n    this.listBlockStack.push(opcode);\n\n    this.didEnter(opcode);\n  }\n\n  private didEnter(opcode: BlockOpcode) {\n    this.updateWith(opcode);\n    this.updatingOpcodeStack.push(opcode.children);\n  }\n\n  exit() {\n    this.elements().popBlock();\n    this.updatingOpcodeStack.pop();\n\n    let parent = this.updating().tail() as BlockOpcode;\n\n    parent.didInitializeChildren();\n  }\n\n  exitList() {\n    this.exit();\n    this.listBlockStack.pop();\n  }\n\n  updateWith(opcode: UpdatingOpcode) {\n    this.updating().append(opcode);\n  }\n\n  listBlock(): ListBlockOpcode {\n    return this.listBlockStack.current;\n  }\n\n  updating(): LinkedList<UpdatingOpcode> {\n    return this.updatingOpcodeStack.current;\n  }\n\n  elements(): ElementStack {\n    return this.elementStack;\n  }\n\n  scope(): Scope {\n    return this.scopeStack.current;\n  }\n\n  dynamicScope(): DynamicScope {\n    return this.dynamicScopeStack.current;\n  }\n\n  pushChildScope() {\n    this.scopeStack.push(this.scope().child());\n  }\n\n  pushCallerScope(childScope = false) {\n    let callerScope = this.scope().getCallerScope();\n    this.scopeStack.push(childScope ? callerScope.child() : callerScope);\n  }\n\n  pushDynamicScope(): DynamicScope {\n    let child = this.dynamicScope().child();\n    this.dynamicScopeStack.push(child);\n    return child;\n  }\n\n  pushRootScope(size: number, bindCaller: boolean): Scope {\n    let scope = Scope.sized(size);\n    if (bindCaller) scope.bindCallerScope(this.scope());\n    this.scopeStack.push(scope);\n    return scope;\n  }\n\n  popScope() {\n    this.scopeStack.pop();\n  }\n\n  popDynamicScope() {\n    this.dynamicScopeStack.pop();\n  }\n\n  newDestroyable(d: Destroyable) {\n    this.elements().newDestroyable(d);\n  }\n\n  /// SCOPE HELPERS\n\n  getSelf(): PathReference<any> {\n    return this.scope().getSelf();\n  }\n\n  referenceForSymbol(symbol: number): PathReference<any> {\n    return this.scope().getSymbol(symbol);\n  }\n\n  /// EXECUTION\n\n  execute(start: number, initialize?: (vm: VM) => void): RenderResult {\n    this.pc = start;\n\n    if (initialize) initialize(this);\n\n    let result: IteratorResult<RenderResult>;\n\n    while (true) {\n      result = this.next();\n      if (result.done) break;\n    }\n\n    return result.value as RenderResult;\n  }\n\n  next(): IteratorResult<RenderResult> {\n    let { env, updatingOpcodeStack, elementStack } = this;\n    let opcode: Option<Opcode>;\n\n    if (opcode = this.nextStatement(env)) {\n      APPEND_OPCODES.evaluate(this, opcode, opcode.type);\n      return { done: false, value: null };\n    }\n\n    return {\n      done: true,\n      value: new RenderResult(\n        env,\n        updatingOpcodeStack.pop(),\n        elementStack.popBlock()\n      )\n    };\n  }\n\n  private nextStatement(env: Environment): Option<Opcode> {\n    let { pc } = this;\n\n    if (pc === -1) {\n      return null;\n    }\n\n    let program = env.program;\n    this.pc += 4;\n    return program.opcode(pc);\n  }\n\n  evaluateOpcode(opcode: Opcode) {\n    APPEND_OPCODES.evaluate(this, opcode, opcode.type);\n  }\n\n  bindDynamicScope(names: ConstantString[]) {\n    let scope = this.dynamicScope();\n\n    for(let i=names.length - 1; i>=0; i--) {\n      let name = this.constants.getString(names[i]);\n      scope.set(name, this.stack.pop<VersionedPathReference<Opaque>>());\n    }\n  }\n}\n","import { EMPTY_CACHE } from '../utils';\nimport { dict } from '@glimmer/util';\nimport Meta from '../meta';\nimport { PropertyReference } from './descriptors';\nimport { VOLATILE_TAG, PathReference as IPathReference, Reference, Tag } from '@glimmer/reference';\nimport { Dict, HasGuid } from '@glimmer/util';\nimport { Option } from \"@glimmer/interfaces\";\n\nexport default class PathReference<T> implements IPathReference<T>, HasGuid {\n  private parent: IPathReference<any>;\n  private property: string;\n  protected cache: any = EMPTY_CACHE;\n  private inner: Option<Reference<T>> = null;\n  private chains: Option<Dict<PathReference<any>>> = null;\n  private lastParentValue: any = EMPTY_CACHE;\n  public _guid = 0;\n  public tag: Tag = VOLATILE_TAG;\n\n  constructor(parent: IPathReference<T>, property: string) {\n    this.parent = parent;\n    this.property = property;\n  }\n\n  value(): any {\n    let { lastParentValue, property, inner } = this;\n    let parentValue = this._parentValue();\n\n    if (parentValue === null || parentValue === undefined) {\n      return (this.cache = undefined);\n    }\n\n    if (lastParentValue === parentValue) {\n      inner = this.inner;\n    } else {\n      let ReferenceType = typeof parentValue === 'object' ? Meta.for(parentValue).referenceTypeFor(property) : PropertyReference;\n      inner = this.inner = new ReferenceType(parentValue, property, this);\n    }\n\n    // if (typeof parentValue === 'object') {\n    //   Meta.for(parentValue).addReference(property, this);\n    // }\n\n    return (this.cache = inner!.value());\n  }\n\n  get(prop: string): IPathReference<any> {\n    let chains = this._getChains();\n    if (<string>prop in chains) return chains[prop];\n    return (chains[prop] = new PathReference(this, prop));\n  }\n\n  label(): string {\n    return '[reference Direct]';\n  }\n\n  private _getChains(): Dict<PathReference<any>> {\n    if (this.chains) return this.chains;\n    return (this.chains = dict<PathReference<any>>());\n  }\n\n  private _parentValue() {\n    let parent = this.parent.value();\n    this.lastParentValue = parent;\n    return parent;\n  }\n}\n\nexport { PathReference };\n","import { Opaque, dict } from '@glimmer/util';\nimport { PathReference } from './path';\nimport { RootReference as IRootReference } from '../types';\nimport { VOLATILE_TAG, PathReference as IPathReference, Tag } from '@glimmer/reference';\nimport { Option } from \"@glimmer/interfaces\";\n\nexport default class RootReference<T> implements IRootReference<T>, IPathReference<T> {\n  private object: T;\n  private chains = dict<PathReference<any>>();\n  public tag: Tag = VOLATILE_TAG;\n\n  constructor(object: T) {\n    this.object = object;\n  }\n\n  value(): T { return this.object; }\n\n  update(object: T) {\n    this.object = object;\n    // this.notify();\n  }\n\n  get<U>(prop: string): IPathReference<U> {\n    let chains = this.chains;\n    if (<string>prop in chains) return chains[prop];\n    return (chains[prop] = new PathReference(this, prop));\n  }\n\n  chainFor<U>(prop: string): Option<IPathReference<U>> {\n    let chains = this.chains;\n    if (<string>prop in chains) return chains[prop];\n    return null;\n  }\n\n  path(string: string): IPathReference<Opaque> {\n    return string.split('.').reduce((ref, part) => ref.get(part), this as IPathReference<Opaque>);\n  }\n\n  referenceFromParts(parts: string[]): IPathReference<Opaque> {\n    return parts.reduce((ref, part) => ref.get(part) as IPathReference<Opaque>, this as IPathReference<Opaque>);\n  }\n\n  label() {\n    return '[reference Root]';\n  }\n}\n","import { PropertyReference } from './references/descriptors';\nimport RootReference from './references/root';\nimport { MetaOptions } from './types';\n\nimport { Dict, DictSet, HasGuid, Set, dict } from '@glimmer/util';\n\nimport {\n  RootReferenceFactory,\n  PathReferenceFactory,\n  Meta as IMeta,\n  RootReference as IRootReference\n} from './types';\n\nimport { PathReference as IPathReference, VOLATILE_TAG } from '@glimmer/reference';\n\nimport { InnerReferenceFactory } from './references/descriptors';\nimport { Option } from \"@glimmer/interfaces\";\n\nconst NOOP_DESTROY = { destroy() {} };\n\nclass ConstPath implements IPathReference<any> {\n  private parent: any;\n  private property: string;\n  public tag = VOLATILE_TAG;\n\n  constructor(parent: any, _property: string) {\n    this.parent = parent;\n  }\n\n  chain() { return NOOP_DESTROY; }\n  notify() {}\n\n  value() {\n    return this.parent[this.property];\n  }\n\n  get(prop: string): IPathReference<any> {\n    return new ConstPath(this.parent[this.property], prop);\n  }\n}\n\nclass ConstRoot implements IRootReference<any> {\n  private inner: any;\n  public tag = VOLATILE_TAG;\n\n  constructor(value: any) {\n    this.inner = value;\n  }\n\n  update(inner: any) {\n    this.inner = inner;\n  }\n\n  chain() { return NOOP_DESTROY; }\n  notify() {}\n\n  value(): any {\n    return this.inner;\n  }\n\n  referenceFromParts(_parts: string[]): IPathReference<any> {\n    throw new Error(\"Not implemented\");\n  }\n\n  chainFor(_prop: string): IPathReference<any> {\n    throw new Error(\"Not implemented\");\n  }\n\n  get(prop: string): IPathReference<any> {\n    return new ConstPath(this.inner, prop);\n  }\n}\n\nclass ConstMeta /*implements IMeta*/ {\n  private object: any;\n\n  constructor(object: any) {\n    this.object = object;\n  }\n\n  root(): ConstRoot {\n    return new ConstRoot(this.object);\n  }\n}\n\nexport const CLASS_META = \"df8be4c8-4e89-44e2-a8f9-550c8dacdca7\";\n\nconst hasOwnProperty = Object.hasOwnProperty;\n\nclass Meta implements IMeta, HasGuid {\n  static for(obj: any): IMeta {\n    if (obj === null || obj === undefined) return new Meta(obj, {});\n    if (hasOwnProperty.call(obj, '_meta') && obj._meta) return obj._meta;\n    if (!Object.isExtensible(obj)) return <any>new ConstMeta(obj);\n\n    let MetaToUse: typeof Meta = Meta;\n\n    if (obj.constructor && obj.constructor[CLASS_META]) {\n      let classMeta: ClassMeta = obj.constructor[CLASS_META];\n      MetaToUse = classMeta.InstanceMetaConstructor;\n    } else if (obj[CLASS_META]) {\n      MetaToUse = obj[CLASS_META].InstanceMetaConstructor;\n    }\n\n    return (obj._meta = new MetaToUse(obj, {}));\n  }\n\n  static exists(obj: any): boolean {\n    return typeof obj === 'object' && obj._meta;\n  }\n\n  static metadataForProperty(_key: string): any {\n    return null;\n  }\n\n  private object: any;\n  private RootReferenceFactory: RootReferenceFactory<any>;\n  private DefaultPathReferenceFactory: InnerReferenceFactory<any>;\n  private rootCache: IRootReference<any>;\n  private references: Option<Dict<DictSet<IPathReference<any> & HasGuid>>> = null;\n  public _guid: number;\n  protected slots: Option<Dict<any>> = null;\n  protected referenceTypes: Option<Dict<InnerReferenceFactory<any>>> = null;\n  protected propertyMetadata: Option<Dict<any>> = null;\n\n  constructor(object: any, { RootReferenceFactory, DefaultPathReferenceFactory }: MetaOptions) {\n    this.object = object;\n    this.RootReferenceFactory = (RootReferenceFactory || RootReference) as RootReferenceFactory<any>;\n    this.DefaultPathReferenceFactory = DefaultPathReferenceFactory || PropertyReference;\n  }\n\n  addReference(property: string, reference: IPathReference<any> & HasGuid) {\n    let refs = this.references = this.references || dict<DictSet<IPathReference<any> & HasGuid>>();\n    let set = refs[property] = refs[property] || new DictSet<IPathReference<any> & HasGuid>();\n    set.add(reference);\n  }\n\n  addReferenceTypeFor(property: string, type: PathReferenceFactory<any>) {\n    this.referenceTypes = this.referenceTypes || dict<PathReferenceFactory<any>>();\n    this.referenceTypes[property] = type;\n  }\n\n  referenceTypeFor(property: string): InnerReferenceFactory<any> {\n    if (!this.referenceTypes) return PropertyReference;\n    return this.referenceTypes[property] || PropertyReference;\n  }\n\n  removeReference(property: string, reference: IPathReference<any> & HasGuid) {\n    if (!this.references) return;\n    let set = this.references[property];\n    set.delete(reference);\n  }\n\n  getReferenceTypes(): Dict<InnerReferenceFactory<any>> {\n    this.referenceTypes = this.referenceTypes || dict<PathReferenceFactory<any>>();\n    return this.referenceTypes;\n  }\n\n  referencesFor(property: string): Option<Set<IPathReference<any>>> {\n    if (!this.references) return null;\n    return this.references[property];\n  }\n\n  getSlots() {\n    return (this.slots = this.slots || dict());\n  }\n\n  root(): IRootReference<any> {\n    return (this.rootCache = this.rootCache || new this.RootReferenceFactory(this.object));\n  }\n}\n\nexport default Meta;\n\ninterface ClassMeta {\n  InstanceMetaConstructor: typeof Meta;\n}\n\nexport function metaFor(obj: any): IMeta {\n  return Meta.for(obj);\n}\n","import Meta from '../meta';\nimport { Reference, VOLATILE_TAG, Tag } from '@glimmer/reference';\nimport { NotifiableReference } from '../types';\n\nexport interface InnerReferenceFactory<T> {\n  new (object: any, property: string, outer: NotifiableReference<any>): Reference<T>;\n}\n\nexport class PropertyReference<T> implements Reference<T> {\n  private object: any;\n  private property: string;\n  public tag: Tag = VOLATILE_TAG;\n\n  constructor(object: any, property: string, _outer: NotifiableReference<T>) {\n    this.object = object;\n    this.property = property;\n  }\n\n  value() { return this.object[this.property]; }\n\n  label() {\n    return '[reference Property]';\n  }\n}\n\nexport function ComputedReferenceBlueprint<T>(_property: any, dependencies: any): InnerReferenceFactory<T> {\n  return class ComputedReference<T> implements Reference<T> {\n    private object: any;\n    private property: string;\n    private dependencies: string[][];\n    private outer: NotifiableReference<T>;\n    private installed = false;\n    public tag: Tag = VOLATILE_TAG;\n\n    constructor(object: any, property: string, outer: NotifiableReference<T>) {\n      this.object = object;\n      this.property = property;\n      this.dependencies = dependencies;\n      this.outer = outer;\n    }\n\n    value(): T {\n      if (!this.installed) {\n        let root = Meta.for(this.object).root();\n\n        this.dependencies.forEach(dep => {\n          let ref = root.referenceFromParts(dep);\n          ref.value();\n        });\n\n        this.installed = true;\n      }\n\n      return this.object[this.property];\n    }\n\n    label() {\n      return '[reference Computed]';\n    }\n  };\n}\n","// import { metaFor } from './meta';\n// import { intern } from '@glimmer/util';\n\nexport function setProperty(parent: any, property: string, val: any) {\n  // let rootProp = metaFor(parent).root().chainFor(property));\n\n  // let referencesToNotify = metaFor(parent).referencesFor(property));\n\n  parent[property] = val;\n\n  // if (referencesToNotify) {\n  //   referencesToNotify.forEach(function(ref) { ref.notify(); });\n  // }\n\n  // if (rootProp) rootProp.notify();\n}\n\nexport function notifyProperty(_parent: any, _property: string) {\n  // let rootProp = metaFor(parent).root().chainFor(property));\n\n  // let referencesToNotify = metaFor(parent).referencesFor(property));\n\n  // if (referencesToNotify) {\n  //   referencesToNotify.forEach(function(ref) { ref.notify(); });\n  // }\n\n  // if (rootProp) rootProp.notify();\n}\n","import {\n  Registry,\n  RegistryAccessor,\n  RegistrationOptions,\n  Injection,\n  Resolver\n} from '@glimmer/di';\n\nfunction isTypeSpecifier(specifier: string) {\n  return specifier.indexOf(':') === -1;\n}\n\nexport default class ApplicationRegistry implements RegistryAccessor {\n  private _registry: Registry;\n  private _resolver: Resolver;\n\n  constructor(registry: Registry, resolver: Resolver) {\n    this._registry = registry;\n    this._resolver = resolver;\n  }\n\n  register(specifier: string, factory: any, options?: RegistrationOptions): void {\n    let normalizedSpecifier = this._toAbsoluteSpecifier(specifier);\n    this._registry.register(normalizedSpecifier, factory, options);\n  }\n\n  registration(specifier: string): any {\n    let normalizedSpecifier = this._toAbsoluteSpecifier(specifier);\n    return this._registry.registration(normalizedSpecifier);\n  }\n\n  unregister(specifier: string) {\n    let normalizedSpecifier = this._toAbsoluteSpecifier(specifier);\n    this._registry.unregister(normalizedSpecifier);\n  }\n\n  registerOption(specifier: string, option: string, value: any): void {\n    let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n    this._registry.registerOption(normalizedSpecifier, option, value);\n  }\n\n  registeredOption(specifier: string, option: string): any {\n    let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n    return this._registry.registeredOption(normalizedSpecifier, option);\n  }\n\n  registeredOptions(specifier: string): any {\n    let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n    return this._registry.registeredOptions(normalizedSpecifier);\n  }\n\n  unregisterOption(specifier: string, option: string): void {\n    let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n    this._registry.unregisterOption(normalizedSpecifier, option);\n  }\n\n  registerInjection(specifier: string, property: string, injection: string): void {\n    let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n    let normalizedInjection = this._toAbsoluteSpecifier(injection);\n    this._registry.registerInjection(normalizedSpecifier, property, normalizedInjection);\n  }\n\n  registeredInjections(specifier: string): Injection[] {\n    let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n    return this._registry.registeredInjections(normalizedSpecifier);\n  }\n\n  private _toAbsoluteSpecifier(specifier: string, referrer?: string): string {\n    return this._resolver.identify(specifier, referrer);\n  }\n\n  private _toAbsoluteOrTypeSpecifier(specifier: string): string {\n    if (isTypeSpecifier(specifier)) {\n      return specifier;\n    } else {\n      return this._toAbsoluteSpecifier(specifier);\n    }\n  }\n}","import {\n  assign,\n  Opaque\n} from '@glimmer/util';\nimport {\n  DynamicScope as GlimmerDynamicScope\n} from '@glimmer/runtime';\nimport {\n  PathReference\n} from '@glimmer/reference';\n\nexport default class DynamicScope implements GlimmerDynamicScope {\n  private bucket;\n\n  constructor(bucket=null) {\n    if (bucket) {\n      this.bucket = assign({}, bucket);\n    } else {\n      this.bucket = {};\n    }\n  }\n\n  get(key: string): PathReference<Opaque> {\n    return this.bucket[key];\n  }\n\n  set(key: string, reference: PathReference<Opaque>) {\n    return this.bucket[key] = reference;\n  }\n\n  child(): DynamicScope {\n    return new DynamicScope(this.bucket);\n  }\n}\n","import {\n  Opaque\n} from '@glimmer/util';\n\nimport {\n  Reference,\n  OpaqueIterator,\n  AbstractIterable,\n  IterationItem,\n  Tag\n} from \"@glimmer/reference\";\n\nimport {\n  UpdatableReference\n} from \"@glimmer/object-reference\";\n\nexport type KeyFor<T> = (item: Opaque, index: T) => string;\n\nclass ArrayIterator implements OpaqueIterator {\n  private array: Opaque[];\n  private keyFor: KeyFor<number>;\n  private position = 0;\n\n  constructor(array: Opaque[], keyFor: KeyFor<number>) {\n    this.array = array;\n    this.keyFor = keyFor;\n  }\n\n  isEmpty(): boolean {\n    return this.array.length === 0;\n  }\n\n  next(): IterationItem<Opaque, number> {\n    let { position, array, keyFor } = this;\n\n    if (position >= array.length) return null;\n\n    let value = array[position];\n    let key = keyFor(value, position);\n    let memo = position;\n\n    this.position++;\n\n    return { key, value, memo };\n  }\n}\n\nclass ObjectKeysIterator implements OpaqueIterator {\n  private keys: string[];\n  private values: Opaque[];\n  private keyFor: KeyFor<string>;\n  private position = 0;\n\n  constructor(keys: string[], values: Opaque[], keyFor: KeyFor<string>) {\n    this.keys = keys;\n    this.values = values;\n    this.keyFor = keyFor;\n  }\n\n  isEmpty(): boolean {\n    return this.keys.length === 0;\n  }\n\n  next(): IterationItem<Opaque, string> {\n    let { position, keys, values, keyFor } = this;\n\n    if (position >= keys.length) return null;\n\n    let value = values[position];\n    let memo = keys[position];\n    let key = keyFor(value, memo);\n\n    this.position++;\n\n    return { key, value, memo };\n  }\n}\n\nclass EmptyIterator implements OpaqueIterator {\n  isEmpty(): boolean {\n    return true;\n  }\n\n  next(): IterationItem<Opaque, Opaque> {\n    throw new Error(`Cannot call next() on an empty iterator`);\n  }\n}\n\nconst EMPTY_ITERATOR = new EmptyIterator();\n\nexport default class Iterable implements AbstractIterable<Opaque, Opaque, IterationItem<Opaque, Opaque>, UpdatableReference<Opaque>, UpdatableReference<Opaque>> {\n  public tag: Tag;\n  private ref: Reference<Opaque>;\n  private keyFor: KeyFor<Opaque>;\n\n  constructor(ref: Reference<Opaque>, keyFor: KeyFor<Opaque>) {\n    this.tag = ref.tag;\n    this.ref = ref;\n    this.keyFor = keyFor;\n  }\n\n  iterate(): OpaqueIterator {\n    let { ref, keyFor } = this;\n\n    let iterable = ref.value() as any;\n\n    if (Array.isArray(iterable)) {\n      return iterable.length > 0 ? new ArrayIterator(iterable, keyFor) : EMPTY_ITERATOR;\n    } else if (iterable === undefined || iterable === null) {\n      return EMPTY_ITERATOR;\n    } else if (iterable.forEach !== undefined) {\n      let array = [];\n      iterable.forEach(function(item) {\n        array.push(item);\n      });\n      return array.length > 0 ? new ArrayIterator(array, keyFor) : EMPTY_ITERATOR;\n    } else if (typeof iterable === 'object') {\n       let keys = Object.keys(iterable);\n       return keys.length > 0 ? new ObjectKeysIterator(keys, keys.map(key => iterable[key]), keyFor) : EMPTY_ITERATOR;\n     } else {\n      throw new Error(`Don't know how to {{#each ${iterable}}}`);\n    }\n  }\n\n  valueReferenceFor(item: IterationItem<Opaque, Opaque>): UpdatableReference<Opaque> {\n    return new UpdatableReference(item.value);\n  }\n\n  updateValueReference(reference: UpdatableReference<Opaque>, item: IterationItem<Opaque, Opaque>) {\n    reference.update(item.value);\n  }\n\n  memoReferenceFor(item: IterationItem<Opaque, Opaque>): UpdatableReference<Opaque> {\n    return new UpdatableReference(item.memo);\n  }\n\n  updateMemoReference(reference: UpdatableReference<Opaque>, item: IterationItem<Opaque, Opaque>) {\n    reference.update(item.memo);\n  }\n}\n","import { ConstReference, Reference } from \"@glimmer/reference\";\nimport { VM, Arguments } from \"@glimmer/runtime\";\n\nexport default function buildAction(vm: VM, _args: Arguments) {\n  let componentRef = vm.getSelf();\n  let args = _args.capture();\n\n  let actionFunc = args.positional.at(0).value() as Function;\n  if (typeof actionFunc !== 'function') {\n    throwNoActionError(actionFunc, args.positional.at(0));\n  }\n\n  return new ConstReference(function action(...invokedArgs) {\n    let curriedArgs = args.positional.value();\n    // Consume the action function that was already captured above.\n    curriedArgs.shift();\n\n    curriedArgs.push(...invokedArgs);\n\n    // Invoke the function with the component as the context, the curried\n    // arguments passed to `{{action}}`, and the arguments the bound function\n    // was invoked with.\n    actionFunc.apply(componentRef && componentRef.value(), curriedArgs);\n  });\n}\n\nfunction throwNoActionError(actionFunc: any, actionFuncReference: Reference<any>) {\n  let referenceInfo = debugInfoForReference(actionFuncReference);\n  throw new Error(`You tried to create an action with the {{action}} helper, but the first argument ${referenceInfo}was ${typeof actionFunc} instead of a function.`);\n}\n\nexport function debugInfoForReference(reference: any): string {\n  let message = '';\n  let parent;\n  let property;\n\n  if (reference == null) { return message; }\n\n  if ('parent' in reference && 'property' in reference) {\n    parent = reference['parent'].value();\n    property = reference['property'];\n  } else if ('_parentValue' in reference && '_propertyKey' in reference) {\n    parent = reference['_parentValue'];\n    property = reference['_propertyKey'];\n  }\n\n  if (property !== undefined) {\n    message += `('${property}' on ${debugName(parent)}) `;\n  }\n\n  return message;\n}\n\nfunction debugName(obj: any) {\n  let objType = typeof obj;\n  if (obj == null) {\n    return objType;\n  } else if (objType === 'number' || objType === 'boolean') {\n    return obj.toString();\n  } else {\n    if (obj['debugName']) {\n      return obj['debugName'];\n    }\n    try {\n      return JSON.stringify(obj);\n    } catch (e) { }\n    return obj.toString();\n  }\n}\n","import {\n  Dict,\n  Opaque\n} from '@glimmer/util';\n\nimport {\n  VOLATILE_TAG,\n  PathReference,\n  Reference\n} from \"@glimmer/reference\";\n\nimport {\n  Arguments,\n  CapturedArguments,\n  Helper as GlimmerHelper,\n  VM\n} from \"@glimmer/runtime\";\n\nexport type UserHelper = (args: ReadonlyArray<Opaque>, named: Dict<Opaque>) => any;\n\nexport default function buildUserHelper(helperFunc): GlimmerHelper {\n  return (_vm: VM, args: Arguments) => new HelperReference(helperFunc, args);\n}\n\nexport class SimplePathReference<T> implements PathReference<T> {\n  private parent: Reference<T>;\n  private property: string;\n  public tag = VOLATILE_TAG;\n\n  constructor(parent: Reference<T>, property: string) {\n    this.parent = parent;\n    this.property = property;\n  }\n\n  value(): T {\n    return this.parent.value()[this.property];\n  }\n\n  get(prop: string): PathReference<Opaque> {\n    return new SimplePathReference(this, prop);\n  }\n}\n\nexport class HelperReference implements PathReference<Opaque> {\n  private helper: UserHelper;\n  private args: CapturedArguments;\n  public tag = VOLATILE_TAG;\n\n  constructor(helper: UserHelper, args: Arguments) {\n    this.helper = helper;\n    this.args = args.capture();\n  }\n\n  value() {\n    let { helper, args } = this;\n\n    return helper(args.positional.value(), args.named.value());\n  }\n\n  get(prop: string): SimplePathReference<Opaque> {\n    return new SimplePathReference(this, prop);\n  }\n}\n","import {\n  DOMChanges,\n  DOMTreeConstruction,\n  Environment as GlimmerEnvironment,\n  InlineMacros,\n  ModifierManager,\n  templateFactory,\n  ComponentDefinition,\n  Component,\n  ComponentManager,\n  BlockMacros,\n  Helper as GlimmerHelper\n} from '@glimmer/runtime';\nimport {\n  Reference,\n  OpaqueIterable\n} from \"@glimmer/reference\";\nimport {\n  dict,\n  Opaque\n} from '@glimmer/util';\nimport {\n  getOwner,\n  setOwner,\n  Owner,\n  Factory\n} from '@glimmer/di';\nimport Iterable from './iterable';\nimport TemplateMeta from './template-meta';\nimport ComponentDefinitionCreator from './component-definition-creator'\nimport Application from \"./application\";\nimport {\n  blockComponentMacro,\n  inlineComponentMacro\n } from './dynamic-component';\n import action from './helpers/action';\n import buildUserHelper from './helpers/user-helper';\n\ntype KeyFor<T> = (item: Opaque, index: T) => string;\n\nexport interface EnvironmentOptions {\n  document?: HTMLDocument;\n  appendOperations?: DOMTreeConstruction;\n}\n\nclass DefaultComponentDefinition extends ComponentDefinition<any> {\n  toJSON() {\n    return `<default-component-definition name=${this.name}>`;\n  }\n}\n\nconst DEFAULT_MANAGER = 'main';\nconst DEFAULT_HELPERS = {\n  action\n};\n\nexport default class Environment extends GlimmerEnvironment {\n  private helpers = dict<GlimmerHelper>();\n  private modifiers = dict<ModifierManager<Opaque>>();\n  private components = dict<ComponentDefinition<Component>>();\n  private managers = dict<ComponentManager<Component>>();\n  private uselessAnchor: HTMLAnchorElement;\n\n  static create(options: EnvironmentOptions = {}) {\n    options.document = options.document || self.document;\n    options.appendOperations = options.appendOperations || new DOMTreeConstruction(options.document);\n\n    return new Environment(options);\n  }\n\n  constructor(options: EnvironmentOptions) {\n    super({ appendOperations: options.appendOperations, updateOperations: new DOMChanges(options.document as HTMLDocument || document) });\n\n    setOwner(this, getOwner(options));\n\n    // TODO - required for `protocolForURL` - seek alternative approach\n    // e.g. see `installPlatformSpecificProtocolForURL` in Ember\n    this.uselessAnchor = options.document.createElement('a') as HTMLAnchorElement;\n  }\n\n  protocolForURL(url: string): string {\n    // TODO - investigate alternative approaches\n    // e.g. see `installPlatformSpecificProtocolForURL` in Ember\n    this.uselessAnchor.href = url;\n    return this.uselessAnchor.protocol;\n  }\n\n  hasPartial() {\n    return false;\n  }\n\n  lookupPartial(): any {\n  }\n\n  managerFor(managerId: string = DEFAULT_MANAGER): ComponentManager<Component> {\n    let manager: ComponentManager<Component>;\n\n    manager = this.managers[managerId];\n    if (!manager) {\n      let app: Application = getOwner(this) as any as Application;\n      manager = this.managers[managerId] = getOwner(this).lookup(`component-manager:/${app.rootName}/component-managers/${managerId}`);\n      if (!manager) {\n        throw new Error(`No component manager found for ID ${managerId}.`);\n      }\n    }\n    return manager;\n  }\n\n  hasComponentDefinition(name: string, meta: TemplateMeta): boolean {\n    return !!this.getComponentDefinition(name, meta);\n  }\n\n  getComponentDefinition(name: string, meta: TemplateMeta): ComponentDefinition<Component> {\n    let owner: Owner = getOwner(this);\n    let relSpecifier: string = `template:${name}`;\n    let referrer: string = meta.specifier;\n\n    let specifier = owner.identify(relSpecifier, referrer);\n    if (specifier === undefined) {\n      if (owner.identify(`component:${name}`, referrer)) {\n        throw new Error(`The component '${name}' is missing a template. All components must have a template. Make sure there is a template.hbs in the component directory.`);\n      } else {\n        throw new Error(\"Could not find template for \" + name);\n      }\n    }\n\n    if (!this.components[specifier]) {\n      return this.registerComponent(name, specifier, meta, owner);\n    }\n\n    return this.components[specifier];\n  }\n\n  registerComponent(name: string, templateSpecifier: string, meta: TemplateMeta, owner: Owner): ComponentDefinition<Component> {\n    let serializedTemplate = owner.lookup('template', templateSpecifier);\n    let componentSpecifier = owner.identify('component', templateSpecifier);\n    let componentFactory: Factory<Component> = null;\n\n    if (componentSpecifier) {\n      componentFactory = owner.factoryFor(componentSpecifier);\n    }\n\n    let template = templateFactory<TemplateMeta>(serializedTemplate).create(this);\n    let manager: ComponentManager<Component> = this.managerFor(meta.managerId);\n    let definition: ComponentDefinition<Component>;\n\n    if (canCreateComponentDefinition(manager)) {\n      definition = manager.createComponentDefinition(name, template, componentFactory);\n    } else {\n      definition = new DefaultComponentDefinition(name, manager, componentFactory);\n    }\n\n    this.components[templateSpecifier] = definition;\n\n    return definition;\n  }\n\n  hasHelper(name: string, meta: TemplateMeta) {\n    return !!this.lookupHelper(name, meta);\n  }\n\n  lookupHelper(name: string, meta: TemplateMeta): GlimmerHelper {\n    if (DEFAULT_HELPERS[name]) {\n      return DEFAULT_HELPERS[name];\n    }\n\n    let owner: Owner = getOwner(this);\n    let relSpecifier: string = `helper:${name}`;\n    let referrer: string = meta.specifier;\n\n    let specifier = owner.identify(relSpecifier, referrer);\n    if (specifier === undefined) {\n      return;\n    }\n\n    if (!this.helpers[specifier]) {\n      return this.registerHelper(specifier, owner);\n    }\n\n    return this.helpers[specifier];\n  }\n\n  registerHelper(specifier: string, owner: Owner): GlimmerHelper {\n    let helperFunc = owner.lookup(specifier);\n\n    let userHelper = buildUserHelper(helperFunc);\n    this.helpers[specifier] = userHelper;\n\n    return userHelper;\n  }\n\n  hasModifier(modifierName: string, blockMeta: TemplateMeta): boolean {\n    return modifierName.length === 1 && (modifierName in this.modifiers);\n  }\n\n  lookupModifier(modifierName: string, blockMeta: TemplateMeta): ModifierManager<Opaque> {\n    let modifier = this.modifiers[modifierName];\n\n    if(!modifier) throw new Error(`Modifier for ${modifierName} not found.`);\n    return modifier;\n  }\n\n  iterableFor(ref: Reference<Opaque>, keyPath: string): OpaqueIterable {\n    let keyFor: KeyFor<Opaque>;\n\n    if (!keyPath) {\n      throw new Error('Must specify a key for #each');\n    }\n\n    switch (keyPath) {\n      case '@index':\n        keyFor = (_, index: number) => String(index);\n      break;\n      case '@primitive':\n        keyFor = (item: Opaque) => String(item);\n      break;\n      default:\n        keyFor = (item: Opaque) => item[keyPath];\n      break;\n    }\n\n    return new Iterable(ref, keyFor);\n  }\n\n  macros(): { blocks: BlockMacros, inlines: InlineMacros } {\n    let macros = super.macros();\n\n    populateMacros(macros.blocks, macros.inlines);\n\n    return macros;\n  }\n}\n\nfunction populateMacros(blocks: BlockMacros, inlines: InlineMacros): void {\n  blocks.add('component', blockComponentMacro);\n  inlines.add('component', inlineComponentMacro);\n}\n\nfunction canCreateComponentDefinition(manager: ComponentDefinitionCreator | ComponentManager<Component>): manager is ComponentDefinitionCreator {\n  return (manager as ComponentDefinitionCreator).createComponentDefinition !== undefined;\n}\n","export default {\"id\":\"sn4E/A3E\",\"block\":\"{\\\"symbols\\\":[\\\"root\\\"],\\\"prelude\\\":null,\\\"head\\\":null,\\\"statements\\\":[[4,\\\"each\\\",[[19,0,[\\\"roots\\\"]]],[[\\\"key\\\"],[\\\"id\\\"]],{\\\"statements\\\":[[4,\\\"-in-element\\\",[[19,1,[\\\"parent\\\"]]],[[\\\"nextSibling\\\"],[[19,1,[\\\"nextSibling\\\"]]]],{\\\"statements\\\":[[1,[25,\\\"component\\\",[[19,1,[\\\"component\\\"]]],null],false]],\\\"parameters\\\":[]},null]],\\\"parameters\\\":[1]},null]],\\\"hasEval\\\":false}\",\"meta\":{\"specifier\":\"template:/-application/templates/main.hbs\"}};","import {\n  Container,\n  Factory,\n  Owner,\n  Registry,\n  RegistryWriter,\n  Resolver,\n  setOwner,\n} from '@glimmer/di';\nimport {\n  Simple,\n  templateFactory,\n  RenderResult,\n  ComponentDefinition,\n  Component\n} from '@glimmer/runtime';\nimport {\n  UpdatableReference\n} from '@glimmer/object-reference';\nimport {\n  Option\n} from '@glimmer/util';\nimport ApplicationRegistry from './application-registry';\nimport DynamicScope from './dynamic-scope';\nimport Environment from './environment';\nimport mainTemplate from './templates/main';\n\nexport interface ApplicationOptions {\n  rootName: string;\n  resolver: Resolver;\n}\n\nexport interface Initializer {\n  name?: string;\n  initialize(registry: RegistryWriter): void;\n}\n\nexport interface AppRoot {\n  id: number,\n  component: string | ComponentDefinition<Component>,\n  parent: Simple.Node,\n  nextSibling: Option<Simple.Node>\n}\n\nexport default class Application implements Owner {\n  public rootName: string;\n  public resolver: Resolver;\n  public env: Environment;\n  private _roots: AppRoot[] = [];\n  private _rootsIndex: number = 0;\n  private _registry: Registry;\n  private _container: Container;\n  private _renderResult: RenderResult;\n  /** Whether the initial render has completed. */\n  private _rendered: boolean;\n  /** Whether a re-render has been scheduled. */\n  private _scheduled: boolean;\n  private _initializers: Initializer[] = [];\n  private _initialized = false;\n\n  constructor(options: ApplicationOptions) {\n    this.rootName = options.rootName;\n    this.resolver = options.resolver;\n  }\n\n  registerInitializer(initializer: Initializer): void {\n    this._initializers.push(initializer);\n  }\n\n  initRegistry(): void {\n    let registry = this._registry = new Registry();\n\n    // Create ApplicationRegistry as a proxy to the underlying registry\n    // that will only be available during `initialize`.\n    let appRegistry = new ApplicationRegistry(this._registry, this.resolver);\n\n    registry.register(`environment:/${this.rootName}/main/main`, Environment);\n    registry.registerOption('helper', 'instantiate', false);\n    registry.registerOption('template', 'instantiate', false);\n    registry.register(`document:/${this.rootName}/main/main`, window.document as any);\n    registry.registerOption('document', 'instantiate', false);\n    registry.registerInjection('environment', 'document', `document:/${this.rootName}/main/main`);\n    registry.registerInjection('component-manager', 'env', `environment:/${this.rootName}/main/main`);\n\n    let initializers = this._initializers;\n    for (let i = 0; i < initializers.length; i++) {\n      initializers[i].initialize(appRegistry);\n    }\n\n    this._initialized = true;\n  }\n\n  initContainer(): void {\n    this._container = new Container(this._registry, this.resolver);\n\n    // Inject `this` (the app) as the \"owner\" of every object instantiated\n    // by its container.\n    this._container.defaultInjections = (specifier: string) => {\n      let hash = {};\n      setOwner(hash, this);\n      return hash;\n    }\n  }\n\n  initialize(): void {\n    this.initRegistry();\n    this.initContainer();\n  }\n\n  boot(): void {\n    this.initialize();\n\n    this.env = this.lookup(`environment:/${this.rootName}/main/main`);\n\n    this.render();\n  }\n\n  render(): void {\n    this.env.begin();\n\n    let mainLayout = templateFactory(mainTemplate).create(this.env);\n    let self = new UpdatableReference({ roots: this._roots });\n    let appendTo = document.body;\n    let dynamicScope = new DynamicScope();\n    let templateIterator = mainLayout.render(self, appendTo, dynamicScope);\n    let result;\n    do {\n      result = templateIterator.next();\n    } while (!result.done);\n\n    this.env.commit();\n\n    this._rendered = true;\n    this._renderResult = result.value;\n  }\n\n  renderComponent(component: string | ComponentDefinition<Component>, parent: Simple.Node, nextSibling: Option<Simple.Node>): void {\n    this._roots.push({ id: this._rootsIndex++, component, parent, nextSibling });\n    this.scheduleRerender();\n  }\n\n  rerender(): void {\n    this.env.begin();\n    this._renderResult.rerender();\n    this.env.commit();\n  }\n\n  scheduleRerender(): void {\n    if (this._scheduled || !this._rendered) { return; }\n\n    this._scheduled = true;\n    requestAnimationFrame(() => {\n      this._scheduled = false;\n      this.rerender();\n    });\n  }\n\n  /**\n   * Owner interface implementation\n   */\n  identify(specifier: string, referrer?: string): string {\n    return this.resolver.identify(specifier, referrer);\n  }\n\n  factoryFor(specifier: string, referrer?: string): Factory<any> {\n    return this._container.factoryFor(this.identify(specifier, referrer));\n  }\n\n  lookup(specifier: string, referrer?: string): any {\n    return this._container.lookup(this.identify(specifier, referrer));\n  }\n}\n","import { RegistrationOptions } from './registry';\nimport { Factory } from './factory';\n\n// TODO - use symbol\nexport const OWNER = '__owner__';\n\nexport function getOwner(object: object): Owner {\n  return object[OWNER];\n}\n\nexport function setOwner(object: object, owner: Owner): void {\n  object[OWNER] = owner;\n}\n\nexport interface Owner {\n  identify(specifier: string, referrer?: string): string;\n\n  factoryFor(specifier: string, referrer?: string): Factory<any>;\n  \n  lookup(specifier: string, referrer?: string): any;\n}\n","export interface Specifier {\n  rootName?: string;\n  collection?: string;\n  namespace?: string;\n  name?: string;\n  type?: string;\n}\n\nexport function isSpecifierStringAbsolute(specifier: string): boolean {\n  let [type, path] = specifier.split(':');\n  return !!(type && path && path.indexOf('/') === 0 && path.split('/').length > 3);\n}\n\nexport function isSpecifierObjectAbsolute(specifier: Specifier): boolean {\n  return specifier.rootName !== undefined &&\n         specifier.collection !== undefined &&\n         specifier.name !== undefined &&\n         specifier.type !== undefined;\n}\n\nexport function serializeSpecifier(specifier: Specifier): string {\n  let type = specifier.type;\n  let path = serializeSpecifierPath(specifier);\n\n  if (path) {\n    return type + ':' + path;\n  } else {\n    return type;\n  }\n}\n\nexport function serializeSpecifierPath(specifier: Specifier): string {\n  let path = [];\n  if (specifier.rootName) {\n    path.push(specifier.rootName);\n  }\n  if (specifier.collection) {\n    path.push(specifier.collection);\n  }\n  if (specifier.namespace) {\n    path.push(specifier.namespace);\n  }\n  if (specifier.name) {\n    path.push(specifier.name);\n  }\n\n  if (path.length > 0) {\n    let fullPath = path.join('/');\n    if (isSpecifierObjectAbsolute(specifier)) {\n      fullPath = '/' + fullPath;\n    }\n    return fullPath;\n  }\n}\n\nexport function deserializeSpecifier(specifier: string): Specifier {\n  let obj: Specifier = {};\n\n  if (specifier.indexOf(':') > -1) {\n    let [type, path] = specifier.split(':');\n    obj.type = type;\n\n    let pathSegments;\n\n    if (path.indexOf('/') === 0) {\n      pathSegments = path.substr(1).split('/');\n      obj.rootName = pathSegments.shift();\n      obj.collection = pathSegments.shift();\n    } else {\n      pathSegments = path.split('/');\n    }\n\n    if (pathSegments.length > 0) {\n      obj.name = pathSegments.pop();\n\n      if (pathSegments.length > 0) {\n        obj.namespace = pathSegments.join('/');\n      }\n    }\n\n  } else {\n    obj.type = specifier;\n  }\n\n  return obj;\n}\n","export function assert(description: string, test: any) {\n  if (!test) {\n    throw new Error('Assertion Failed: ' + description);\n  }\n}\n","import {\n  Resolver as IResolver,\n  Specifier,\n  isSpecifierStringAbsolute,\n  isSpecifierObjectAbsolute,\n  deserializeSpecifier,\n  serializeSpecifier\n} from '@glimmer/di';\nimport { assert } from './utils/debug';\nimport { ModuleRegistry } from './module-registry';\nimport { ResolverConfiguration } from './resolver-configuration';\n\nexport default class Resolver implements IResolver {\n  public config: ResolverConfiguration;\n  public registry: ModuleRegistry;\n\n  constructor(config: ResolverConfiguration, registry: ModuleRegistry) {\n    this.config = config;\n    this.registry = registry;\n  }\n\n  identify(specifier: string, referrer?: string): string {\n    if (isSpecifierStringAbsolute(specifier)) {\n      return specifier;\n    }\n\n    let s = deserializeSpecifier(specifier);\n    let result: string;\n\n    if (referrer) {\n      let r = deserializeSpecifier(referrer);\n\n      if (isSpecifierObjectAbsolute(r)) {\n        assert('Specifier must not include a rootName, collection, or namespace when combined with an absolute referrer', s.rootName === undefined && s.collection === undefined && s.namespace === undefined);\n\n        // Look locally in the referrer's namespace\n        s.rootName = r.rootName;\n        s.collection = r.collection;\n        if (s.name) {\n          s.namespace = r.namespace ? r.namespace + '/' + r.name : r.name;\n        } else {\n          s.namespace = r.namespace;\n          s.name = r.name;\n        }\n        if (result = this._serializeAndVerify(s)) { return result; }\n\n        // Look for a private collection in the referrer's namespace\n        let privateCollection = this._definitiveCollection(s.type);\n        if (privateCollection) {\n          s.namespace += '/-' + privateCollection;\n          if (result = this._serializeAndVerify(s)) { return result; }\n        }\n\n        // Because local and private resolution has failed, clear all but `name` and `type`\n        // to proceed with top-level resolution\n        s.rootName = s.collection = s.namespace = undefined;\n      } else {\n        assert('Referrer must either be \"absolute\" or include a `type` to determine the associated type', r.type);\n\n        // Look in the definitive collection for the associated type\n        s.collection = this._definitiveCollection(r.type);\n        assert(`'${r.type}' does not have a definitive collection`, s.collection);\n      }\n    }\n\n    // If the collection is unspecified, use the definitive collection for the `type`\n    if (!s.collection) {\n      s.collection = this._definitiveCollection(s.type);\n      assert(`'${s.type}' does not have a definitive collection`, s.collection);\n    }\n\n    if (!s.rootName) {\n      // If the root name is unspecified, try the app's `rootName` first\n      s.rootName = this.config.app.rootName || 'app';\n      if (result = this._serializeAndVerify(s)) { return result; }\n\n      // Then look for an addon with a matching `rootName`\n      let addonDef;\n      if (s.namespace) {\n        addonDef = this.config.addons && this.config.addons[s.namespace];\n        s.rootName = s.namespace;\n        s.namespace = undefined;\n\n      } else {\n        addonDef = this.config.addons && this.config.addons[s.name];\n        s.rootName = s.name;\n        s.name = 'main';\n      }\n    }\n\n    if (result = this._serializeAndVerify(s)) { return result; }\n  }\n\n  retrieve(specifier: string): any {\n    return this.registry.get(specifier);\n  }\n\n  resolve(specifier: string, referrer?: string): any {\n    let id = this.identify(specifier, referrer);\n    if (id) {\n      return this.retrieve(id);\n    }\n  }\n\n  private _definitiveCollection(type: string): string {\n    let typeDef = this.config.types[type];\n    assert(`'${type}' is not a recognized type`, typeDef);\n    return typeDef.definitiveCollection;\n  }\n\n  private _serializeAndVerify(specifier: Specifier): string {\n    let serialized = serializeSpecifier(specifier);\n    if (this.registry.has(serialized)) {\n      return serialized;\n    }\n  }\n}\n","import { DEBUG } from '@glimmer/env';\nimport { Tag, DirtyableTag, TagWrapper, combine, CONSTANT_TAG } from '@glimmer/reference';\nimport { dict, Dict } from '@glimmer/util';\n\n/**\n * @decorator\n *\n * Marks a property as tracked.\n *\n * By default, a component's properties are expected to be static,\n * meaning you are not able to update them and have the template update accordingly.\n * Marking a property as tracked means that when that property changes,\n * a rerender of the component is scheduled so the template is kept up to date.\n *\n * @param dependencies Optional dependents to be tracked.\n */\nexport function tracked(...dependencies: string[]): MethodDecorator;\nexport function tracked(target: any, key: any): any;\nexport function tracked(target: any, key: any, descriptor: PropertyDescriptor): PropertyDescriptor;\nexport function tracked(...dependencies: any[]): any {\n  let [target, key, descriptor] = dependencies;\n\n  if (typeof target === \"string\") {\n    return function(target: any, key: string | Symbol, descriptor: PropertyDescriptor) {\n      return descriptorForTrackedComputedProperty(target, key, descriptor, dependencies);\n    }\n  } else {\n    if (descriptor) {\n      return descriptorForTrackedComputedProperty(target, key, descriptor, []);\n    } else {\n      installTrackedProperty(target, key);\n    }\n  }\n}\n\nfunction descriptorForTrackedComputedProperty(target: any, key: any, descriptor: PropertyDescriptor, dependencies: string[]): PropertyDescriptor {\n  let meta = metaFor(target);\n  meta.trackedProperties[key] = true;\n  meta.trackedPropertyDependencies[key] = dependencies || [];\n\n  return {\n    enumerable: true,\n    configurable: false,\n    get: descriptor.get,\n    set: function() {\n      metaFor(this).dirtyableTagFor(key).inner.dirty();\n      descriptor.set.apply(this, arguments);\n      propertyDidChange();\n    }\n  }\n}\n\nexport type Key = string;\n\n/**\n  Installs a getter/setter for change tracking. The accessor\n  acts just like a normal property, but it triggers the `propertyDidChange`\n  hook when written to.\n\n  Values are saved on the object using a \"shadow key,\" or a symbol based on the\n  tracked property name. Sets write the value to the shadow key, and gets read\n  from it.\n */\nfunction installTrackedProperty(target: any, key: Key) {\n  let value: any;\n  let shadowKey = Symbol(key);\n\n  let meta = metaFor(target);\n  meta.trackedProperties[key] = true;\n\n  if (target[key] !== undefined) {\n    value = target[key];\n  }\n\n  Object.defineProperty(target, key, {\n    configurable: true,\n\n    get() {\n      return this[shadowKey];\n    },\n\n    set(newValue) {\n      metaFor(this).dirtyableTagFor(key).inner.dirty();\n      this[shadowKey] = newValue;\n      propertyDidChange();\n    }\n  });\n}\n\n/**\n * Stores bookkeeping information about tracked properties on the target object\n * and includes helper methods for manipulating and retrieving that data.\n *\n * Computed properties (i.e., tracked getters/setters) deserve some explanation.\n * A computed property is invalidated when either it is set, or one of its\n * dependencies is invalidated. Therefore, we store two tags for each computed\n * property:\n *\n * 1. The dirtyable tag that we invalidate when the setter is invoked.\n * 2. A union tag (tag combinator) of the dirtyable tag and all of the computed\n *    property's dependencies' tags, used by Glimmer to determine \"does this\n *    computed property need to be recomputed?\"\n */\nexport default class Meta {\n  tags: Dict<Tag>;\n  computedPropertyTags: Dict<TagWrapper<DirtyableTag>>;\n  trackedProperties: Dict<boolean>;\n  trackedPropertyDependencies: Dict<string[]>;\n\n  constructor(parent: Meta) {\n    this.tags = dict<Tag>();\n    this.computedPropertyTags = dict<TagWrapper<DirtyableTag>>();\n    this.trackedProperties = parent ? Object.create(parent.trackedProperties) : dict<boolean>();\n    this.trackedPropertyDependencies = parent ? Object.create(parent.trackedPropertyDependencies) : dict<string[]>();\n  }\n\n  /**\n   * The tag representing whether the given property should be recomputed. Used\n   * by e.g. Glimmer VM to detect when a property should be re-rendered. Think\n   * of this as the \"public-facing\" tag.\n   *\n   * For static tracked properties, this is a single DirtyableTag. For computed\n   * properties, it is a combinator of the property's DirtyableTag as well as\n   * all of its dependencies' tags.\n   */\n  tagFor(key: Key): Tag {\n    let tag = this.tags[key];\n    if (tag) { return tag; }\n\n    let dependencies;\n    if (dependencies = this.trackedPropertyDependencies[key]) {\n      return this.tags[key] = combinatorForComputedProperties(this, key, dependencies);\n    }\n\n    return this.tags[key] = DirtyableTag.create();\n  }\n\n  /**\n   * The tag used internally to invalidate when a tracked property is set. For\n   * static properties, this is the same DirtyableTag returned from `tagFor`.\n   * For computed properties, it is the DirtyableTag used as one of the tags in\n   * the tag combinator of the CP and its dependencies.\n  */\n  dirtyableTagFor(key: Key): TagWrapper<DirtyableTag> {\n    let dependencies = this.trackedPropertyDependencies[key];\n    let tag;\n\n    if (dependencies) {\n      // The key is for a computed property.\n      tag = this.computedPropertyTags[key];\n      if (tag) { return tag; }\n      return this.computedPropertyTags[key] = DirtyableTag.create();\n    } else {\n      // The key is for a static property.\n      tag = this.tags[key];\n      if (tag) { return tag as TagWrapper<DirtyableTag>; }\n      return this.tags[key] = DirtyableTag.create();\n    }\n  }\n}\n\nfunction combinatorForComputedProperties(meta: Meta, key: Key, dependencies: Key[] | void): Tag {\n  // Start off with the tag for the CP's own dirty state.\n  let tags: Tag[] = [meta.dirtyableTagFor(key)];\n\n  // Next, add in all of the tags for its dependencies.\n  if (dependencies && dependencies.length) {\n    for (let i = 0; i < dependencies.length; i++) {\n      tags.push(meta.tagFor(dependencies[i]));\n    }\n  }\n\n  // Return a combinator across the CP's tags and its dependencies' tags.\n  return combine(tags);\n}\n\nexport interface Interceptors {\n  [key: string]: boolean;\n}\n\nlet META = Symbol(\"ember-object\");\n\nexport function metaFor(obj: any): Meta {\n  let meta = obj[META];\n  if (meta && hasOwnProperty(obj, META)) {\n    return meta;\n  }\n\n  return obj[META] = new Meta(meta);\n}\n\nlet hOP = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj: any, key: symbol) {\n  return hOP.call(obj, key);\n}\n\nlet propertyDidChange = function() {};\n\nexport function setPropertyDidChange(cb: () => void) {\n  propertyDidChange = cb;\n}\n\nexport function hasTag(obj: any, key: string): boolean {\n  let meta = obj[META] as Meta;\n\n  if (!obj[META]) { return false; }\n  if (!meta.trackedProperties[key]) { return false; }\n\n  return true;\n}\n\nexport class UntrackedPropertyError extends Error {\n  static for(obj: any, key: string): UntrackedPropertyError {\n    return new UntrackedPropertyError(obj, key, `The property '${key}' on ${obj} was changed after being rendered. If you want to change a property used in a template after the component has rendered, mark the property as a tracked property with the @tracked decorator.`);\n  }\n\n  constructor(public target: any, public key: string, message: string) {\n    super(message);\n  }\n}\n\n/**\n * Function that can be used in development mode to generate more meaningful\n * error messages.\n */\nexport interface UntrackedPropertyErrorThrower {\n  (obj: any, key: string): void;\n}\n\nfunction defaultErrorThrower(obj: any, key: string): UntrackedPropertyError {\n  throw UntrackedPropertyError.for(obj, key);\n}\n\nexport function tagForProperty(obj: any, key: string, throwError: UntrackedPropertyErrorThrower = defaultErrorThrower): Tag {\n  if (typeof obj === 'object' && obj) {\n    if (DEBUG && !hasTag(obj, key)) {\n      installDevModeErrorInterceptor(obj, key, throwError);\n    }\n\n    let meta = metaFor(obj);\n    return meta.tagFor(key);\n  } else {\n    return CONSTANT_TAG;\n  }\n}\n\n/**\n * In development mode only, we install an ad hoc setter on properties where a\n * tag is requested (i.e., it was used in a template) without being tracked. In\n * cases where the property is set, we raise an error.\n */\nfunction installDevModeErrorInterceptor(obj: object, key: string, throwError: UntrackedPropertyErrorThrower) {\n  let target = obj;\n  let descriptor: PropertyDescriptor;\n\n  // Find the descriptor for the current property. We may need to walk the\n  // prototype chain to do so. If the property is undefined, we may never get a\n  // descriptor here.\n  let hasOwnDescriptor = true;\n  while (target) {\n    descriptor = Object.getOwnPropertyDescriptor(target, key);\n    if (descriptor) { break; }\n    hasOwnDescriptor = false;\n    target = Object.getPrototypeOf(target);\n  }\n\n  // If possible, define a property descriptor that passes through the current\n  // value on reads but throws an exception on writes.\n  if (descriptor) {\n    if (descriptor.configurable || !hasOwnDescriptor) {\n      Object.defineProperty(obj, key, {\n        configurable: descriptor.configurable,\n        enumerable: descriptor.enumerable,\n\n        get() {\n          if (descriptor.get) {\n            return descriptor.get.call(this);\n          } else {\n            return descriptor.value;\n          }\n        },\n\n        set() {\n          throwError(this, key);\n        }\n      });\n    }\n  } else {\n    Object.defineProperty(obj, key, {\n      set() {\n        throwError(this, key);\n      }\n    });\n  }\n}\n","import { Simple } from '@glimmer/runtime';\nimport { metaFor } from './tracked';\n\n/**\n * The `Component` class defines an encapsulated UI element that is rendered to\n * the DOM. A component is made up of a template and, optionally, this component\n * object.\n *\n * ## Defining a Component\n *\n * To define a component, subclass `Component` and add your own properties,\n * methods and lifecycle hooks:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n * }\n * ```\n *\n * ## Lifecycle Hooks\n *\n * Lifecycle hooks allow you to respond to changes to a component, such as when\n * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a\n * component, implement the hook as a method on your component subclass.\n *\n * For example, to be notified when Glimmer has rendered your component so you\n * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   didInsertElement() {\n *     $(this.element).pickadate();\n *   }\n * }\n * ```\n *\n * ## Data for Templates\n *\n * `Component`s have two different kinds of data, or state, that can be\n * displayed in templates:\n *\n * 1. Arguments\n * 2. Properties\n *\n * Arguments are data that is passed in to a component from its parent\n * component. For example, if I have a `user-greeting` component, I can pass it\n * a name and greeting to use:\n *\n * ```hbs\n * <user-greeting @name=\"Ricardo\" @greeting=\"Olá\">\n * ```\n *\n * Inside my `user-greeting` template, I can access the `@name` and `@greeting`\n * arguments that I've been given:\n *\n * ```hbs\n * {{@greeting}}, {{@name}}!\n * ```\n *\n * Arguments are also available inside my component:\n *\n * ```ts\n * console.log(this.args.greeting); // prints \"Olá\"\n * ```\n *\n * Properties, on the other hand, are internal to the component and declared in\n * the class. You can use properties to store data that you want to show in the\n * template, or pass to another component as an argument.\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   user = {\n *     name: 'Robbie'\n *   }\n * }\n * ```\n *\n * In the above example, we've defined a component with a `user` property that\n * contains an object with its own `name` property.\n *\n * We can render that property in our template:\n *\n * ```hbs\n * Hello, {{user.name}}!\n * ```\n *\n * We can also take that property and pass it as an argument to the\n * `user-greeting` component we defined above:\n *\n * ```hbs\n * <user-greeting @greeting=\"Hello\" @name={{user.name}} />\n * ```\n *\n * ## Arguments vs. Properties\n *\n * Remember, arguments are data that was given to your component by its parent\n * component, and properties are data your component has defined for itself.\n *\n * You can tell the difference between arguments and properties in templates\n * because arguments always start with an `@` sign (think \"A is for arguments\"):\n *\n * ```hbs\n * {{@firstName}}\n * ```\n *\n * We know that `@firstName` came from the parent component, not the current\n * component, because it starts with `@` and is therefore an argument.\n *\n * On the other hand, if we see:\n *\n * ```hbs\n * {{name}}\n * ```\n *\n * We know that `name` is a property on the component. If we want to know where\n * the data is coming from, we can go look at our component class to find out.\n *\n * Inside the component itself, arguments always show up inside the component's\n * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,\n * inside the component `this.args.firstName` would also be `Tom`.\n */\nclass Component {\n  /**\n   * The element corresponding to the top-level element of the component's template.\n   * You should not try to access this property until after the component's `didInsertElement()`\n   * lifecycle hook is called.\n   */\n  element: Simple.Element = null;\n\n  /**\n   * Development-mode only name of the component, useful for debugging.\n   */\n  debugName: string = null;\n\n  /**\n   * Named arguments passed to the component from its parent component.\n   * They can be accessed in JavaScript via `this.args.argumentName` and in the template via `@argumentName`.\n   *\n   * Say you have the following component, which will have two `args`, `firstName` and `lastName`:\n   *\n   * ```hbs\n   * <my-component @firstName=\"Arthur\" @lastName=\"Dent\" />\n   * ```\n   *\n   * If you needed to calculate `fullName` by combining both of them, you would do:\n   *\n   * ```ts\n   * didInsertElement() {\n   *   console.log(`Hi, my full name is ${this.args.firstName} ${this.args.lastName}`);\n   * }\n   * ```\n   *\n   * While in the template you could do:\n   *\n   * ```hbs\n   * <p>Welcome, {{@firstName}} {{@lastName}}!</p>\n   * ```\n   *\n   */\n  get args() {\n    return this.__args__;\n  }\n\n  set args(args) {\n    this.__args__ = args;\n    metaFor(this).dirtyableTagFor('args').inner.dirty();\n  }\n\n  /** @private\n   * Slot on the component to save Arguments object passed to the `args` setter.\n   */\n  private __args__: any = null;\n\n  static create(injections: any) {\n    return new this(injections);\n  }\n\n  /**\n   * Constructs a new component and assigns itself the passed properties. You\n   * should not construct new components yourself. Instead, Glimmer will\n   * instantiate new components automatically as it renders.\n   *\n   * @param options\n   */\n  constructor(options: object) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Called when the component has been inserted into the DOM.\n   * Override this function to do any set up that requires an element in the document body.\n   */\n  didInsertElement() { }\n\n  /**\n   * Called when the component has updated and rerendered itself.\n   * Called only during a rerender, not during an initial render.\n   */\n  didUpdate() { }\n\n  /**\n   * Called before the component has been removed from the DOM.\n   */\n  willDestroy() { }\n\n  destroy() {\n    this.willDestroy();\n  }\n\n  toString() {\n    return `${this.debugName} component`;\n  }\n}\n\nexport default Component;\n\nexport interface ComponentFactory {\n  create(injections: object): Component;\n}\n","import {\n  dict\n} from '@glimmer/util';\nimport {\n  PathReference,\n  CONSTANT_TAG,\n  ConstReference,\n  DirtyableTag,\n  UpdatableTag,\n  combine,\n  isConst,\n  Tag,\n  TagWrapper\n} from '@glimmer/reference';\nimport {\n  ConditionalReference as GlimmerConditionalReference,\n  PrimitiveReference\n} from '@glimmer/runtime';\nimport { tagForProperty, UntrackedPropertyError } from \"./tracked\";\n\n/**\n * The base PathReference.\n */\nexport abstract class ComponentPathReference<T> implements PathReference<T> {\n  abstract value(): T;\n  abstract get tag(): Tag;\n\n  get(key: string): PathReference<any> {\n    return PropertyReference.create(this, key);\n  }\n}\n\nexport abstract class CachedReference<T> extends ComponentPathReference<T> {\n  private _lastRevision: number | null = null;\n  private _lastValue: any = null;\n\n  abstract compute(): T;\n\n  value() {\n    let { tag, _lastRevision, _lastValue } = this;\n\n    if (!_lastRevision || !tag.validate(_lastRevision)) {\n      _lastValue = this._lastValue = this.compute();\n      this._lastRevision = tag.value();\n    }\n\n    return _lastValue;\n  }\n}\n\nexport class RootReference extends ConstReference<object> {\n  private children = dict<RootPropertyReference>();\n\n  get(propertyKey: string) {\n    let ref = this.children[propertyKey];\n\n    if (!ref) {\n      ref = this.children[propertyKey] = new RootPropertyReference(this.inner, propertyKey);\n    }\n\n    return ref;\n  }\n}\n\nexport abstract class PropertyReference extends CachedReference<any> {\n  static create(parentReference: PathReference<any>, propertyKey: string) {\n    if (isConst(parentReference)) {\n      return new RootPropertyReference(parentReference.value(), propertyKey);\n    } else {\n      return new NestedPropertyReference(parentReference, propertyKey);\n    }\n  }\n\n  get(key: string): PathReference<any>  {\n    return new NestedPropertyReference(this, key);\n  }\n}\n\nfunction buildError(obj: any, key: string) {\n  let message = `The '${key}' property on the ${obj} was changed after it had been rendered. Properties that change after being rendered must be tracked. Use the @tracked decorator to mark this as a tracked property.`;\n  throw new UntrackedPropertyError(obj, key, message);\n}\n\nexport class RootPropertyReference extends PropertyReference {\n  tag: Tag;\n  private _parentValue: object;\n  private _propertyKey: string;\n\n  constructor(parentValue: object, propertyKey: string) {\n    super();\n\n    this._parentValue = parentValue;\n    this._propertyKey = propertyKey;\n    this.tag = tagForProperty(parentValue, propertyKey, buildError);\n  }\n\n  compute(): any {\n    return (this._parentValue as any)[this._propertyKey];\n  }\n}\n\nexport class NestedPropertyReference extends PropertyReference {\n  public tag: Tag;\n  private _parentReference: PathReference<any>;\n  private _parentObjectTag: TagWrapper<UpdatableTag>;\n  private _propertyKey: string;\n\n  constructor(parentReference: PathReference<any>, propertyKey: string) {\n    super();\n\n    let parentReferenceTag = parentReference.tag;\n    let parentObjectTag = UpdatableTag.create(CONSTANT_TAG);\n\n    this._parentReference = parentReference;\n    this._parentObjectTag = parentObjectTag;\n    this._propertyKey = propertyKey;\n\n    this.tag = combine([parentReferenceTag, parentObjectTag]);\n  }\n\n  compute() {\n    let { _parentReference, _parentObjectTag, _propertyKey } = this;\n\n    let parentValue = _parentReference.value();\n\n    _parentObjectTag.inner.update(tagForProperty(parentValue, _propertyKey));\n\n    if (typeof parentValue === 'string' && _propertyKey === 'length') {\n      return parentValue.length;\n    }\n\n    if (typeof parentValue === 'object' && parentValue) {\n      return parentValue[_propertyKey];\n    } else {\n      return undefined;\n    }\n  }\n}\n\nexport class UpdatableReference<T> extends ComponentPathReference<T> {\n  public tag: TagWrapper<DirtyableTag>;\n  private _value: T;\n\n  constructor(value: T) {\n    super();\n\n    this.tag = DirtyableTag.create();\n    this._value = value;\n  }\n\n  value() {\n    return this._value;\n  }\n\n  update(value: T) {\n    let { _value } = this;\n\n    if (value !== _value) {\n      this.tag.inner.dirty();\n      this._value = value;\n    }\n  }\n}\n\nexport class ConditionalReference extends GlimmerConditionalReference {\n  static create(reference: PathReference<any>) {\n    if (isConst(reference)) {\n      let value = reference.value();\n      return PrimitiveReference.create(value);\n    }\n\n    return new ConditionalReference(reference);\n  }\n}\n","import {\n  getOwner,\n  setOwner,\n  Factory,\n  Owner\n} from '@glimmer/di';\nimport {\n  Bounds,\n  ComponentManager as GlimmerComponentManager,\n  DynamicScope,\n  Environment,\n  Simple,\n  CompiledDynamicProgram,\n  Arguments,\n  Template,\n  CapturedArguments\n} from '@glimmer/runtime';\nimport Component from './component';\nimport ComponentDefinition from './component-definition';\nimport { RootReference } from './references';\nimport { Dict, Destroyable } from \"@glimmer/util\";\n\nexport interface ConstructorOptions {\n  env: Environment;\n}\n\nexport class ComponentStateBucket {\n  public name: string;\n  public component: Component;\n  private args: CapturedArguments;\n\n  constructor(definition: ComponentDefinition, args: CapturedArguments, owner: Owner) {\n    let componentFactory = definition.componentFactory;\n    let name = definition.name;\n\n    this.args = args;\n\n    let injections = {\n      debugName: name,\n      args: this.namedArgsSnapshot()\n    };\n\n    setOwner(injections, owner);\n    this.component = componentFactory.create(injections);\n  }\n\n  namedArgsSnapshot(): Readonly<Dict<object | void>> {\n    return Object.freeze(this.args.named.value());\n  }\n}\n\nexport default class ComponentManager implements GlimmerComponentManager<ComponentStateBucket> {\n  private env: Environment;\n\n  static create(options: ConstructorOptions): ComponentManager {\n    return new ComponentManager(options);\n  }\n\n  constructor(options: ConstructorOptions) {\n    this.env = options.env;\n  }\n\n  prepareArgs(definition: ComponentDefinition, args: Arguments): null {\n    return null;\n  }\n\n  create(environment: Environment, definition: ComponentDefinition, volatileArgs: Arguments): ComponentStateBucket | null {\n    let componentFactory = definition.componentFactory;\n    if (!componentFactory) { return null; }\n\n    let owner = getOwner(this.env);\n    return new ComponentStateBucket(definition, volatileArgs.capture(), owner);\n  }\n\n  createComponentDefinition(name: string, template: Template<any>, componentFactory?: Factory<Component>): ComponentDefinition {\n    return new ComponentDefinition(name, this, template, componentFactory);\n  }\n\n  layoutFor(definition: ComponentDefinition, bucket: ComponentStateBucket, env: Environment): CompiledDynamicProgram {\n    let template = definition.template;\n    let compiledLayout = template.asLayout().compileDynamic(this.env);\n\n    return compiledLayout;\n  }\n\n  getSelf(bucket: ComponentStateBucket) {\n    if (!bucket) { return null; }\n    return new RootReference(bucket.component);\n  }\n\n  didCreateElement(bucket: ComponentStateBucket, element: Simple.Element) {\n    if (!bucket) { return; }\n    bucket.component.element = element;\n  }\n\n  didRenderLayout(bucket: ComponentStateBucket, bounds: Bounds) {\n  }\n\n  didCreate(bucket: ComponentStateBucket) {\n    bucket && bucket.component.didInsertElement();\n  }\n\n  getTag(): null {\n    return null;\n  }\n\n  update(bucket: ComponentStateBucket, scope: DynamicScope) {\n    if (!bucket) { return; }\n\n    // TODO: This should be moved to `didUpdate`, but there's currently a\n    // Glimmer bug that causes it not to be called if the layout doesn't update.\n    let { component } = bucket;\n\n    component.args = bucket.namedArgsSnapshot();\n    component.didUpdate();\n  }\n\n  didUpdateLayout() {}\n\n  didUpdate(bucket: ComponentStateBucket) { }\n\n  getDestructor(bucket: ComponentStateBucket): Destroyable {\n    if (!bucket) { return; }\n\n    return bucket.component;\n  }\n}\n","export default {\"id\":\"pTOL7/Ia\",\"block\":\"{\\\"symbols\\\":[],\\\"prelude\\\":[[6,\\\"div\\\"]],\\\"head\\\":[[9,\\\"class\\\",\\\"comic-panel-layer\\\"],[10,\\\"style\\\",[18,\\\"bgStyle\\\"],null],[7]],\\\"statements\\\":[[8],[0,\\\"\\\\n\\\"]],\\\"hasEval\\\":false}\",\"meta\":{\"specifier\":\"template:/comic-panel/components/comic-panel/comic-panel-layer\",\"<template-meta>\":true}};","import Component, { tracked } from \"@glimmer/component\";\n/* global document.timeline, KeyframeEffect, GroupEffect */\ndeclare var KeyframeEffect: any;\ndeclare var GroupEffect: any;\ndeclare var document, timeline: any;\n\nexport default class ComicPanel extends Component {\n\n  @tracked isAnimationRunning = false;\n  keyframeEffects = [];\n  frameTotal = 6;\n  animation = null;\n\n  animations = [{\n    layerId: 'comic-panel-layer-1',\n    image: '/img/racoonhero.png',\n    frameTotal: this.frameTotal,\n    keyframeSet: [\n      { backgroundPosition: '0 0' },\n      { backgroundPosition: '0 100%' }\n    ],\n    keyframeOptions: {\n      duration: 400,\n      fill: 'none',\n      direction: 'normal',\n      easing: `steps(${this.frameTotal - 1})`,\n      iterations: 'Infinity'\n    }\n  }];\n\n  @tracked('isAnimationRunning')\n  get isPlaying() {\n    return this.isAnimationRunning;\n  }\n\n  didInsertElement() {\n    const animation = this.animations[0];\n    const keyFrames = animation.keyframeSet;\n    const layerElement = document.getElementById(animation.layerId);\n    const timings = animation.keyframeOptions;\n    const layerKeyframe = new KeyframeEffect(layerElement, keyFrames, timings);\n    this.keyframeEffects = [\n      ...this.keyframeEffects,\n      layerKeyframe\n    ];\n    const groupEffect = new GroupEffect(this.keyframeEffects);\n    const animationInstance = document.timeline.play(groupEffect);\n    animationInstance.pause();\n    this.animation = animationInstance;\n  }\n\n  togglePlayState() {\n    this.isAnimationRunning = !this.isAnimationRunning;\n    if (this.isAnimationRunning) {\n      this.animation.play();\n    }\n    else {\n      this.animation.pause();\n    }\n  }\n}\n","export default {\"id\":\"99dZ9S7y\",\"block\":\"{\\\"symbols\\\":[\\\"@play\\\",\\\"@pause\\\",\\\"@isPlaying\\\"],\\\"prelude\\\":[[6,\\\"button\\\"]],\\\"head\\\":[[7]],\\\"statements\\\":[[4,\\\"if\\\",[[19,3,[]]],null,{\\\"statements\\\":[[1,[19,2,[]],false]],\\\"parameters\\\":[]},{\\\"statements\\\":[[1,[19,1,[]],false]],\\\"parameters\\\":[]}],[8],[0,\\\"\\\\n\\\"]],\\\"hasEval\\\":false}\",\"meta\":{\"specifier\":\"template:/comic-panel/components/comic-panel/play-button\",\"<template-meta>\":true}};","export default {\"id\":\"Uz8Nwnh0\",\"block\":\"{\\\"symbols\\\":[\\\"layer\\\"],\\\"prelude\\\":[[6,\\\"div\\\"]],\\\"head\\\":[[9,\\\"class\\\",\\\"comic-panel\\\"],[7]],\\\"statements\\\":[[0,\\\"\\\\n\\\"],[4,\\\"each\\\",[[19,0,[\\\"animations\\\"]]],[[\\\"key\\\"],[\\\"@index\\\"]],{\\\"statements\\\":[[0,\\\"    \\\"],[5,\\\"comic-panel-layer\\\",[[10,\\\"id\\\",[19,1,[\\\"layerId\\\"]],null]],[[\\\"@image\\\",\\\"@frameTotal\\\"],[[19,1,[\\\"image\\\"]],[19,1,[\\\"frameTotal\\\"]]]],{\\\"statements\\\":[],\\\"parameters\\\":[]}],[0,\\\"\\\\n\\\"]],\\\"parameters\\\":[1]},null],[0,\\\"  \\\"],[5,\\\"play-button\\\",[[9,\\\"class\\\",\\\"play-button\\\"],[10,\\\"onclick\\\",[25,\\\"action\\\",[[19,0,[\\\"togglePlayState\\\"]]],null],null]],[[\\\"@isPlaying\\\",\\\"@play\\\",\\\"@pause\\\"],[[18,\\\"isPlaying\\\"],\\\"Play\\\",\\\"Stap it\\\"]],{\\\"statements\\\":[],\\\"parameters\\\":[]}],[0,\\\"\\\\n\\\"],[8],[0,\\\"\\\\n\\\"]],\\\"hasEval\\\":false}\",\"meta\":{\"specifier\":\"template:/comic-panel/components/comic-panel\",\"<template-meta>\":true}};","import { default as __ui_components_comic_panel_comic_panel_layer_component__ } from '../src/ui/components/comic-panel/comic-panel-layer/component';\nimport { default as __ui_components_comic_panel_comic_panel_layer_template__ } from '../src/ui/components/comic-panel/comic-panel-layer/template';\nimport { default as __ui_components_comic_panel_component__ } from '../src/ui/components/comic-panel/component';\nimport { default as __ui_components_comic_panel_play_button_component__ } from '../src/ui/components/comic-panel/play-button/component';\nimport { default as __ui_components_comic_panel_play_button_template__ } from '../src/ui/components/comic-panel/play-button/template';\nimport { default as __ui_components_comic_panel_template__ } from '../src/ui/components/comic-panel/template';\nexport default {'component:/comic-panel/components/comic-panel/comic-panel-layer': __ui_components_comic_panel_comic_panel_layer_component__,'template:/comic-panel/components/comic-panel/comic-panel-layer': __ui_components_comic_panel_comic_panel_layer_template__,'component:/comic-panel/components/comic-panel': __ui_components_comic_panel_component__,'component:/comic-panel/components/comic-panel/play-button': __ui_components_comic_panel_play_button_component__,'template:/comic-panel/components/comic-panel/play-button': __ui_components_comic_panel_play_button_template__,'template:/comic-panel/components/comic-panel': __ui_components_comic_panel_template__};\n","export default {\"app\":{\"name\":\"comic-panel\",\"rootName\":\"comic-panel\"},\"types\":{\"application\":{\"definitiveCollection\":\"main\"},\"component\":{\"definitiveCollection\":\"components\"},\"helper\":{\"definitiveCollection\":\"components\"},\"renderer\":{\"definitiveCollection\":\"main\"},\"template\":{\"definitiveCollection\":\"components\"}},\"collections\":{\"main\":{\"types\":[\"application\",\"renderer\"]},\"components\":{\"group\":\"ui\",\"types\":[\"component\",\"template\",\"helper\"],\"defaultType\":\"component\",\"privateCollections\":[\"utils\"]},\"styles\":{\"group\":\"ui\",\"unresolvable\":true},\"utils\":{\"unresolvable\":true}}};\n","import Application from '@glimmer/application';\nimport Resolver, { ResolverConfiguration, BasicModuleRegistry } from '@glimmer/resolver';\nimport moduleMap from '../config/module-map';\nimport resolverConfiguration from '../config/resolver-configuration';\n\nexport default class App extends Application {\n  constructor() {\n    let moduleRegistry = new BasicModuleRegistry(moduleMap);\n    let resolver = new Resolver(resolverConfiguration, moduleRegistry);\n\n    super({\n      rootName: resolverConfiguration.app.rootName,\n      resolver\n    });\n  }\n}\n","import Application from '@glimmer/application';\n\nexport default function initializeCustomElements(app: Application, customElementDefinitions: string[]): void {\n  customElementDefinitions.forEach((name) => {\n    initializeCustomElement(app, name);\n  });\n}\n\nfunction initializeCustomElement(app: Application, name: string): void {\n  function GlimmerElement() {\n    return Reflect.construct(HTMLElement, [], GlimmerElement);\n  }\n  GlimmerElement.prototype = Object.create(HTMLElement.prototype, {\n    constructor: { value: GlimmerElement },\n    connectedCallback: {\n      value: function connectedCallback() {\n        let placeholder = document.createTextNode('');\n        let parent = this.parentNode;\n\n        parent.insertBefore(placeholder, this);\n        parent.removeChild(this);\n\n        app.renderComponent(name, parent, placeholder);\n      }\n    }\n  });\n\n  window.customElements.define(name, GlimmerElement);\n}\n","import App from './main';\nimport { ComponentManager, setPropertyDidChange } from '@glimmer/component';\nimport initializeCustomElements from '@glimmer/web-component';\n\nconst app = new App();\nconst containerElement = document.getElementById('app');\n\nsetPropertyDidChange(() => {\n  app.scheduleRerender();\n});\n\napp.registerInitializer({\n  initialize(registry) {\n    registry.register(`component-manager:/${app.rootName}/component-managers/main`, ComponentManager)\n  }\n});\n\napp.renderComponent('comic-panel', containerElement, null);\n\napp.boot();\ninitializeCustomElements(app, ['comic-panel']);\n"],"names":["isConst","bounds","layout","Ops","WireFormat.Ops","SVG_NAMESPACE","map","Environment","isSpecifierObjectAbsolute","__ui_components_comic_panel_comic_panel_layer_component__","__ui_components_comic_panel_comic_panel_layer_template__","__ui_components_comic_panel_component__","__ui_components_comic_panel_play_button_component__","__ui_components_comic_panel_play_button_template__","__ui_components_comic_panel_template__"],"mappings":"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"}